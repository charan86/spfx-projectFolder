b56014dff3290445c9b997d6f1db7fa3
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const LegacyAdapters_1 = require("./LegacyAdapters");
/**
 * Operations for sorting collections.
 *
 * @remarks
 * NOTE: Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.  For maximum
 * compatibility, consider using {@link LegacyAdapters.sortStable} instead of `Array.sort()`.
 *
 * @public
 */
class Sort {
    /**
     * Compares `x` and `y` using the JavaScript `>` and `<` operators.  This function is suitable for usage as
     * the callback for `array.sort()`.
     *
     * @remarks
     *
     * The JavaScript ordering is generalized so that `undefined` \< `null` \< all other values.
     *
     * @returns -1 if `x` is smaller than `y`, 1 if `x` is greater than `y`, or 0 if the values are equal.
     *
     * @example
     *
     * ```ts
     * let array: number[] = [3, 6, 2];
     * array.sort(Sort.compareByValue);  // [2, 3, 6]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static compareByValue(x, y) {
        if (x === y) {
            return 0;
        }
        // Undefined is smaller than anything else
        if (x === undefined) {
            return -1;
        }
        if (y === undefined) {
            return 1;
        }
        // Null is smaller than anything except undefined
        if (x === null) {
            // eslint-disable-line @rushstack/no-null
            return -1;
        }
        if (y === null) {
            // eslint-disable-line @rushstack/no-null
            return 1;
        }
        // These comparisons always return false if either of the arguments is "undefined".
        // These comparisons return nonsense for "null" (true for "null > -1", but false for "null < 0" and "null > 0")
        if (x < y) {
            return -1;
        }
        if (x > y) {
            return 1;
        }
        return 0;
    }
    /**
     * Sorts the array according to a key which is obtained from the array elements.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'aaa', 'bb', 'c' ];
     * Sort.sortBy(array, x => x.length);  // [ 'c', 'bb', 'aaa' ]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortBy(array, keySelector, comparer = Sort.compareByValue) {
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(keySelector(x), keySelector(y)));
    }
    /**
     * Returns true if the array is already sorted.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSorted(array, comparer = Sort.compareByValue) {
        let previous = undefined;
        for (const element of array) {
            if (comparer(previous, element) > 0) {
                return false;
            }
            previous = element;
        }
        return true;
    }
    /**
     * Returns true if the array is already sorted by the specified key.
     *
     * @example
     *
     * ```ts
     * let array: string[] = [ 'a', 'bb', 'ccc' ];
     * Sort.isSortedBy(array, x => x.length); // true
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isSortedBy(array, keySelector, comparer = Sort.compareByValue) {
        let previousKey = undefined;
        for (const element of array) {
            const key = keySelector(element);
            if (comparer(previousKey, key) > 0) {
                return false;
            }
            previousKey = key;
        }
        return true;
    }
    /**
     * Sorts the entries in a Map object according to the map keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let map: Map<string, number> = new Map<string, number>();
     * map.set('zebra', 1);
     * map.set('goose', 2);
     * map.set('aardvark', 3);
     * Sort.sortMapKeys(map);
     * console.log(JSON.stringify(Array.from(map.keys()))); // ["aardvark","goose","zebra"]
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortMapKeys(map, keyComparer = Sort.compareByValue) {
        const pairs = Array.from(map.entries());
        // Sorting a map is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(pairs, x => x[0], keyComparer)) {
            return;
        }
        Sort.sortBy(pairs, x => x[0], keyComparer);
        map.clear();
        for (const pair of pairs) {
            map.set(pair[0], pair[1]);
        }
    }
    /**
     * Sorts the entries in a Set object according to the specified keys.
     * The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('aaa');
     * set.add('bb');
     * set.add('c');
     * Sort.sortSetBy(set, x => x.length);
     * console.log(Array.from(set)); // ['c', 'bb', 'aaa']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSetBy(set, keySelector, keyComparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSortedBy(array, keySelector, keyComparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => keyComparer(keySelector(x), keySelector(y)));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
    /**
     * Sorts the entries in a Set object.  The result is guaranteed to be a stable sort.
     *
     * @example
     *
     * ```ts
     * let set: Set<string> = new Set<string>();
     * set.add('zebra');
     * set.add('goose');
     * set.add('aardvark');
     * Sort.sortSet(set);
     * console.log(Array.from(set)); // ['aardvark', 'goose', 'zebra']
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static sortSet(set, comparer = Sort.compareByValue) {
        const array = Array.from(set);
        // Sorting a set is expensive, so first check whether it's already sorted.
        if (Sort.isSorted(array, comparer)) {
            return;
        }
        LegacyAdapters_1.LegacyAdapters.sortStable(array, (x, y) => comparer(x, y));
        set.clear();
        for (const item of array) {
            set.add(item);
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=Sort.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNvcnQuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMZWdhY3lBZGFwdGVyc18xIiwicmVxdWlyZSIsIlNvcnQiLCJjb21wYXJlQnlWYWx1ZSIsIngiLCJ5IiwidW5kZWZpbmVkIiwic29ydEJ5IiwiYXJyYXkiLCJrZXlTZWxlY3RvciIsImNvbXBhcmVyIiwiTGVnYWN5QWRhcHRlcnMiLCJzb3J0U3RhYmxlIiwiaXNTb3J0ZWQiLCJwcmV2aW91cyIsImVsZW1lbnQiLCJpc1NvcnRlZEJ5IiwicHJldmlvdXNLZXkiLCJrZXkiLCJzb3J0TWFwS2V5cyIsIm1hcCIsImtleUNvbXBhcmVyIiwicGFpcnMiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJwYWlyIiwic2V0Iiwic29ydFNldEJ5IiwiaXRlbSIsImFkZCIsInNvcnRTZXQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQUEsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkMsRUFBRUMsT0FBTyxJQUFULEVBQTdDO0FBQ0EsTUFBTUMsbUJBQW1CQyxRQUFRLGtCQUFSLENBQXpCO0FBQ0E7Ozs7Ozs7OztBQVNBLE1BQU1DLElBQU4sQ0FBVztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBLFdBQU9DLGNBQVAsQ0FBc0JDLENBQXRCLEVBQXlCQyxDQUF6QixFQUE0QjtBQUN4QixZQUFJRCxNQUFNQyxDQUFWLEVBQWE7QUFDVCxtQkFBTyxDQUFQO0FBQ0g7QUFDRDtBQUNBLFlBQUlELE1BQU1FLFNBQVYsRUFBcUI7QUFDakIsbUJBQU8sQ0FBQyxDQUFSO0FBQ0g7QUFDRCxZQUFJRCxNQUFNQyxTQUFWLEVBQXFCO0FBQ2pCLG1CQUFPLENBQVA7QUFDSDtBQUNEO0FBQ0EsWUFBSUYsTUFBTSxJQUFWLEVBQWdCO0FBQUU7QUFDZCxtQkFBTyxDQUFDLENBQVI7QUFDSDtBQUNELFlBQUlDLE1BQU0sSUFBVixFQUFnQjtBQUFFO0FBQ2QsbUJBQU8sQ0FBUDtBQUNIO0FBQ0Q7QUFDQTtBQUNBLFlBQUlELElBQUlDLENBQVIsRUFBVztBQUNQLG1CQUFPLENBQUMsQ0FBUjtBQUNIO0FBQ0QsWUFBSUQsSUFBSUMsQ0FBUixFQUFXO0FBQ1AsbUJBQU8sQ0FBUDtBQUNIO0FBQ0QsZUFBTyxDQUFQO0FBQ0g7QUFDRDs7Ozs7Ozs7Ozs7QUFXQTtBQUNBLFdBQU9FLE1BQVAsQ0FBY0MsS0FBZCxFQUFxQkMsV0FBckIsRUFBa0NDLFdBQVdSLEtBQUtDLGNBQWxELEVBQWtFO0FBQzlESCx5QkFBaUJXLGNBQWpCLENBQWdDQyxVQUFoQyxDQUEyQ0osS0FBM0MsRUFBa0QsQ0FBQ0osQ0FBRCxFQUFJQyxDQUFKLEtBQVVLLFNBQVNELFlBQVlMLENBQVosQ0FBVCxFQUF5QkssWUFBWUosQ0FBWixDQUF6QixDQUE1RDtBQUNIO0FBQ0Q7OztBQUdBO0FBQ0EsV0FBT1EsUUFBUCxDQUFnQkwsS0FBaEIsRUFBdUJFLFdBQVdSLEtBQUtDLGNBQXZDLEVBQXVEO0FBQ25ELFlBQUlXLFdBQVdSLFNBQWY7QUFDQSxhQUFLLE1BQU1TLE9BQVgsSUFBc0JQLEtBQXRCLEVBQTZCO0FBQ3pCLGdCQUFJRSxTQUFTSSxRQUFULEVBQW1CQyxPQUFuQixJQUE4QixDQUFsQyxFQUFxQztBQUNqQyx1QkFBTyxLQUFQO0FBQ0g7QUFDREQsdUJBQVdDLE9BQVg7QUFDSDtBQUNELGVBQU8sSUFBUDtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7QUFVQTtBQUNBLFdBQU9DLFVBQVAsQ0FBa0JSLEtBQWxCLEVBQXlCQyxXQUF6QixFQUFzQ0MsV0FBV1IsS0FBS0MsY0FBdEQsRUFBc0U7QUFDbEUsWUFBSWMsY0FBY1gsU0FBbEI7QUFDQSxhQUFLLE1BQU1TLE9BQVgsSUFBc0JQLEtBQXRCLEVBQTZCO0FBQ3pCLGtCQUFNVSxNQUFNVCxZQUFZTSxPQUFaLENBQVo7QUFDQSxnQkFBSUwsU0FBU08sV0FBVCxFQUFzQkMsR0FBdEIsSUFBNkIsQ0FBakMsRUFBb0M7QUFDaEMsdUJBQU8sS0FBUDtBQUNIO0FBQ0RELDBCQUFjQyxHQUFkO0FBQ0g7QUFDRCxlQUFPLElBQVA7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBLFdBQU9DLFdBQVAsQ0FBbUJDLEdBQW5CLEVBQXdCQyxjQUFjbkIsS0FBS0MsY0FBM0MsRUFBMkQ7QUFDdkQsY0FBTW1CLFFBQVFDLE1BQU1DLElBQU4sQ0FBV0osSUFBSUssT0FBSixFQUFYLENBQWQ7QUFDQTtBQUNBLFlBQUl2QixLQUFLYyxVQUFMLENBQWdCTSxLQUFoQixFQUF1QmxCLEtBQUtBLEVBQUUsQ0FBRixDQUE1QixFQUFrQ2lCLFdBQWxDLENBQUosRUFBb0Q7QUFDaEQ7QUFDSDtBQUNEbkIsYUFBS0ssTUFBTCxDQUFZZSxLQUFaLEVBQW1CbEIsS0FBS0EsRUFBRSxDQUFGLENBQXhCLEVBQThCaUIsV0FBOUI7QUFDQUQsWUFBSU0sS0FBSjtBQUNBLGFBQUssTUFBTUMsSUFBWCxJQUFtQkwsS0FBbkIsRUFBMEI7QUFDdEJGLGdCQUFJUSxHQUFKLENBQVFELEtBQUssQ0FBTCxDQUFSLEVBQWlCQSxLQUFLLENBQUwsQ0FBakI7QUFDSDtBQUNKO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0EsV0FBT0UsU0FBUCxDQUFpQkQsR0FBakIsRUFBc0JuQixXQUF0QixFQUFtQ1ksY0FBY25CLEtBQUtDLGNBQXRELEVBQXNFO0FBQ2xFLGNBQU1LLFFBQVFlLE1BQU1DLElBQU4sQ0FBV0ksR0FBWCxDQUFkO0FBQ0E7QUFDQSxZQUFJMUIsS0FBS2MsVUFBTCxDQUFnQlIsS0FBaEIsRUFBdUJDLFdBQXZCLEVBQW9DWSxXQUFwQyxDQUFKLEVBQXNEO0FBQ2xEO0FBQ0g7QUFDRHJCLHlCQUFpQlcsY0FBakIsQ0FBZ0NDLFVBQWhDLENBQTJDSixLQUEzQyxFQUFrRCxDQUFDSixDQUFELEVBQUlDLENBQUosS0FBVWdCLFlBQVlaLFlBQVlMLENBQVosQ0FBWixFQUE0QkssWUFBWUosQ0FBWixDQUE1QixDQUE1RDtBQUNBdUIsWUFBSUYsS0FBSjtBQUNBLGFBQUssTUFBTUksSUFBWCxJQUFtQnRCLEtBQW5CLEVBQTBCO0FBQ3RCb0IsZ0JBQUlHLEdBQUosQ0FBUUQsSUFBUjtBQUNIO0FBQ0o7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBLFdBQU9FLE9BQVAsQ0FBZUosR0FBZixFQUFvQmxCLFdBQVdSLEtBQUtDLGNBQXBDLEVBQW9EO0FBQ2hELGNBQU1LLFFBQVFlLE1BQU1DLElBQU4sQ0FBV0ksR0FBWCxDQUFkO0FBQ0E7QUFDQSxZQUFJMUIsS0FBS1csUUFBTCxDQUFjTCxLQUFkLEVBQXFCRSxRQUFyQixDQUFKLEVBQW9DO0FBQ2hDO0FBQ0g7QUFDRFYseUJBQWlCVyxjQUFqQixDQUFnQ0MsVUFBaEMsQ0FBMkNKLEtBQTNDLEVBQWtELENBQUNKLENBQUQsRUFBSUMsQ0FBSixLQUFVSyxTQUFTTixDQUFULEVBQVlDLENBQVosQ0FBNUQ7QUFDQXVCLFlBQUlGLEtBQUo7QUFDQSxhQUFLLE1BQU1JLElBQVgsSUFBbUJ0QixLQUFuQixFQUEwQjtBQUN0Qm9CLGdCQUFJRyxHQUFKLENBQVFELElBQVI7QUFDSDtBQUNKO0FBcExNO0FBc0xYaEMsUUFBUUksSUFBUixHQUFlQSxJQUFmO0FBQ0EiLCJmaWxlIjoiU29ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBMZWdhY3lBZGFwdGVyc18xID0gcmVxdWlyZShcIi4vTGVnYWN5QWRhcHRlcnNcIik7XG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHNvcnRpbmcgY29sbGVjdGlvbnMuXG4gKlxuICogQHJlbWFya3NcbiAqIE5PVEU6IFByaW9yIHRvIE5vZGUgMTEueCwgdGhlIGBBcnJheS5zb3J0KClgIGFsZ29yaXRobSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuICBGb3IgbWF4aW11bVxuICogY29tcGF0aWJpbGl0eSwgY29uc2lkZXIgdXNpbmcge0BsaW5rIExlZ2FjeUFkYXB0ZXJzLnNvcnRTdGFibGV9IGluc3RlYWQgb2YgYEFycmF5LnNvcnQoKWAuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTb3J0IHtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBgeGAgYW5kIGB5YCB1c2luZyB0aGUgSmF2YVNjcmlwdCBgPmAgYW5kIGA8YCBvcGVyYXRvcnMuICBUaGlzIGZ1bmN0aW9uIGlzIHN1aXRhYmxlIGZvciB1c2FnZSBhc1xuICAgICAqIHRoZSBjYWxsYmFjayBmb3IgYGFycmF5LnNvcnQoKWAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogVGhlIEphdmFTY3JpcHQgb3JkZXJpbmcgaXMgZ2VuZXJhbGl6ZWQgc28gdGhhdCBgdW5kZWZpbmVkYCBcXDwgYG51bGxgIFxcPCBhbGwgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgLTEgaWYgYHhgIGlzIHNtYWxsZXIgdGhhbiBgeWAsIDEgaWYgYHhgIGlzIGdyZWF0ZXIgdGhhbiBgeWAsIG9yIDAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgYXJyYXk6IG51bWJlcltdID0gWzMsIDYsIDJdO1xuICAgICAqIGFycmF5LnNvcnQoU29ydC5jb21wYXJlQnlWYWx1ZSk7ICAvLyBbMiwgMywgNl1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjb21wYXJlQnlWYWx1ZSh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRlZmluZWQgaXMgc21hbGxlciB0aGFuIGFueXRoaW5nIGVsc2VcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIE51bGwgaXMgc21hbGxlciB0aGFuIGFueXRoaW5nIGV4Y2VwdCB1bmRlZmluZWRcbiAgICAgICAgaWYgKHggPT09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAcnVzaHN0YWNrL25vLW51bGxcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEBydXNoc3RhY2svbm8tbnVsbFxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgY29tcGFyaXNvbnMgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgb2YgdGhlIGFyZ3VtZW50cyBpcyBcInVuZGVmaW5lZFwiLlxuICAgICAgICAvLyBUaGVzZSBjb21wYXJpc29ucyByZXR1cm4gbm9uc2Vuc2UgZm9yIFwibnVsbFwiICh0cnVlIGZvciBcIm51bGwgPiAtMVwiLCBidXQgZmFsc2UgZm9yIFwibnVsbCA8IDBcIiBhbmQgXCJudWxsID4gMFwiKVxuICAgICAgICBpZiAoeCA8IHkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+IHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgYXJyYXkgYWNjb3JkaW5nIHRvIGEga2V5IHdoaWNoIGlzIG9idGFpbmVkIGZyb20gdGhlIGFycmF5IGVsZW1lbnRzLlxuICAgICAqIFRoZSByZXN1bHQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIHN0YWJsZSBzb3J0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IGFycmF5OiBzdHJpbmdbXSA9IFsgJ2FhYScsICdiYicsICdjJyBdO1xuICAgICAqIFNvcnQuc29ydEJ5KGFycmF5LCB4ID0+IHgubGVuZ3RoKTsgIC8vIFsgJ2MnLCAnYmInLCAnYWFhJyBdXG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgc29ydEJ5KGFycmF5LCBrZXlTZWxlY3RvciwgY29tcGFyZXIgPSBTb3J0LmNvbXBhcmVCeVZhbHVlKSB7XG4gICAgICAgIExlZ2FjeUFkYXB0ZXJzXzEuTGVnYWN5QWRhcHRlcnMuc29ydFN0YWJsZShhcnJheSwgKHgsIHkpID0+IGNvbXBhcmVyKGtleVNlbGVjdG9yKHgpLCBrZXlTZWxlY3Rvcih5KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzU29ydGVkKGFycmF5LCBjb21wYXJlciA9IFNvcnQuY29tcGFyZUJ5VmFsdWUpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlcihwcmV2aW91cywgZWxlbWVudCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IGFycmF5OiBzdHJpbmdbXSA9IFsgJ2EnLCAnYmInLCAnY2NjJyBdO1xuICAgICAqIFNvcnQuaXNTb3J0ZWRCeShhcnJheSwgeCA9PiB4Lmxlbmd0aCk7IC8vIHRydWVcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBpc1NvcnRlZEJ5KGFycmF5LCBrZXlTZWxlY3RvciwgY29tcGFyZXIgPSBTb3J0LmNvbXBhcmVCeVZhbHVlKSB7XG4gICAgICAgIGxldCBwcmV2aW91c0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlcihwcmV2aW91c0tleSwga2V5KSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0tleSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGVudHJpZXMgaW4gYSBNYXAgb2JqZWN0IGFjY29yZGluZyB0byB0aGUgbWFwIGtleXMuXG4gICAgICogVGhlIHJlc3VsdCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgc3RhYmxlIHNvcnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgbWFwOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICAgKiBtYXAuc2V0KCd6ZWJyYScsIDEpO1xuICAgICAqIG1hcC5zZXQoJ2dvb3NlJywgMik7XG4gICAgICogbWFwLnNldCgnYWFyZHZhcmsnLCAzKTtcbiAgICAgKiBTb3J0LnNvcnRNYXBLZXlzKG1hcCk7XG4gICAgICogY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShtYXAua2V5cygpKSkpOyAvLyBbXCJhYXJkdmFya1wiLFwiZ29vc2VcIixcInplYnJhXCJdXG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgc29ydE1hcEtleXMobWFwLCBrZXlDb21wYXJlciA9IFNvcnQuY29tcGFyZUJ5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBBcnJheS5mcm9tKG1hcC5lbnRyaWVzKCkpO1xuICAgICAgICAvLyBTb3J0aW5nIGEgbWFwIGlzIGV4cGVuc2l2ZSwgc28gZmlyc3QgY2hlY2sgd2hldGhlciBpdCdzIGFscmVhZHkgc29ydGVkLlxuICAgICAgICBpZiAoU29ydC5pc1NvcnRlZEJ5KHBhaXJzLCB4ID0+IHhbMF0sIGtleUNvbXBhcmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFNvcnQuc29ydEJ5KHBhaXJzLCB4ID0+IHhbMF0sIGtleUNvbXBhcmVyKTtcbiAgICAgICAgbWFwLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgZW50cmllcyBpbiBhIFNldCBvYmplY3QgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQga2V5cy5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBzdGFibGUgc29ydC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBzZXQ6IFNldDxzdHJpbmc+ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICogc2V0LmFkZCgnYWFhJyk7XG4gICAgICogc2V0LmFkZCgnYmInKTtcbiAgICAgKiBzZXQuYWRkKCdjJyk7XG4gICAgICogU29ydC5zb3J0U2V0Qnkoc2V0LCB4ID0+IHgubGVuZ3RoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhBcnJheS5mcm9tKHNldCkpOyAvLyBbJ2MnLCAnYmInLCAnYWFhJ11cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBzb3J0U2V0Qnkoc2V0LCBrZXlTZWxlY3Rvciwga2V5Q29tcGFyZXIgPSBTb3J0LmNvbXBhcmVCeVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICAvLyBTb3J0aW5nIGEgc2V0IGlzIGV4cGVuc2l2ZSwgc28gZmlyc3QgY2hlY2sgd2hldGhlciBpdCdzIGFscmVhZHkgc29ydGVkLlxuICAgICAgICBpZiAoU29ydC5pc1NvcnRlZEJ5KGFycmF5LCBrZXlTZWxlY3Rvciwga2V5Q29tcGFyZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgTGVnYWN5QWRhcHRlcnNfMS5MZWdhY3lBZGFwdGVycy5zb3J0U3RhYmxlKGFycmF5LCAoeCwgeSkgPT4ga2V5Q29tcGFyZXIoa2V5U2VsZWN0b3IoeCksIGtleVNlbGVjdG9yKHkpKSk7XG4gICAgICAgIHNldC5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIHNldC5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGVudHJpZXMgaW4gYSBTZXQgb2JqZWN0LiAgVGhlIHJlc3VsdCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgc3RhYmxlIHNvcnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgc2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAqIHNldC5hZGQoJ3plYnJhJyk7XG4gICAgICogc2V0LmFkZCgnZ29vc2UnKTtcbiAgICAgKiBzZXQuYWRkKCdhYXJkdmFyaycpO1xuICAgICAqIFNvcnQuc29ydFNldChzZXQpO1xuICAgICAqIGNvbnNvbGUubG9nKEFycmF5LmZyb20oc2V0KSk7IC8vIFsnYWFyZHZhcmsnLCAnZ29vc2UnLCAnemVicmEnXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIHNvcnRTZXQoc2V0LCBjb21wYXJlciA9IFNvcnQuY29tcGFyZUJ5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgIC8vIFNvcnRpbmcgYSBzZXQgaXMgZXhwZW5zaXZlLCBzbyBmaXJzdCBjaGVjayB3aGV0aGVyIGl0J3MgYWxyZWFkeSBzb3J0ZWQuXG4gICAgICAgIGlmIChTb3J0LmlzU29ydGVkKGFycmF5LCBjb21wYXJlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBMZWdhY3lBZGFwdGVyc18xLkxlZ2FjeUFkYXB0ZXJzLnNvcnRTdGFibGUoYXJyYXksICh4LCB5KSA9PiBjb21wYXJlcih4LCB5KSk7XG4gICAgICAgIHNldC5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIHNldC5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNvcnQgPSBTb3J0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29ydC5qcy5tYXAiXX0=