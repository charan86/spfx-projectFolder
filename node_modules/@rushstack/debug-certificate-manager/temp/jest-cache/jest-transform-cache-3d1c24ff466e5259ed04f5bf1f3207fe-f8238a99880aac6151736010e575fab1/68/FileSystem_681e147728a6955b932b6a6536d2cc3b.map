{"version":3,"sources":["FileSystem.js"],"names":["Object","defineProperty","exports","value","pathUtilities","require","fs","fsx","Text_1","FileSystem","exists","path","existsSync","getStatistics","statSync","updateTimes","times","utimesSync","accessedTime","modifiedTime","changePosixModeBits","mode","chmodSync","getPosixModeBits","formatPosixModeBits","modeBits","result","move","options","assign","overwrite","ensureFolderExists","ensureFolder","basename","sourcePath","moveSync","destinationPath","folderPath","ensureDirSync","readFolder","absolutePaths","Error","fileNames","readdirSync","map","fileName","resolve","deleteFolder","removeSync","ensureEmptyFolder","emptyDirSync","writeFile","filePath","contents","convertLineEndings","undefined","encoding","dirname","Text","convertTo","toString","writeFileSync","appendToFile","appendFileSync","readFile","readFileToBuffer","readFileSync","copyFile","copySync","deleteFile","throwIfNotExists","unlinkSync","error","getLinkStatistics","lstatSync","createSymbolicLinkJunction","symlinkSync","linkTargetPath","newLinkPath","createSymbolicLinkFile","createSymbolicLinkFolder","createHardLink","linkSync","getRealPath","linkPath","realpathSync"],"mappings":"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","file":"FileSystem.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pathUtilities = require(\"path\");\nconst fs = require(\"fs\");\nconst fsx = require(\"fs-extra\");\nconst Text_1 = require(\"./Text\");\n/**\n * The FileSystem API provides a complete set of recommended operations for interacting with the file system.\n *\n * @remarks\n * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level\n * primitives that must be mapped for each supported operating system. The FileSystem API takes a\n * philosophical approach of providing \"one obvious way\" to do each operation. We also prefer synchronous\n * operations except in cases where there would be a clear performance benefit for using async, since synchronous\n * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen\n * performance, versus improving it.\n *\n * Note that in the documentation, we refer to \"filesystem objects\", this can be a\n * file, folder, symbolic link, hard link, directory junction, etc.\n *\n * @public\n */\nclass FileSystem {\n    // ===============\n    // COMMON OPERATIONS\n    // ===============\n    /**\n     * Returns true if the path exists on disk.\n     * Behind the scenes it uses `fs.existsSync()`.\n     * @remarks\n     * There is a debate about the fact that after `fs.existsSync()` returns true,\n     * the file might be deleted before fs.readSync() is called, which would imply that everybody\n     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.\n     * We find this to be unpersuasive, since \"unexceptional exceptions\" really hinder the\n     * break-on-exception debugging experience. Also, throwing/catching is generally slow.\n     * @param path - The absolute or relative path to the filesystem object.\n     */\n    static exists(path) {\n        return fsx.existsSync(path);\n    }\n    /**\n     * Gets the statistics for a particular filesystem object.\n     * If the path is a link, this function follows the link and returns statistics about the link target.\n     * Behind the scenes it uses `fs.statSync()`.\n     * @param path - The absolute or relative path to the filesystem object.\n     */\n    static getStatistics(path) {\n        return fsx.statSync(path);\n    }\n    /**\n     * Updates the accessed and modified timestamps of the filesystem object referenced by path.\n     * Behind the scenes it uses `fs.utimesSync()`.\n     * The caller should specify both times in the `times` parameter.\n     * @param path - The path of the file that should be modified.\n     * @param times - The times that the object should be updated to reflect.\n     */\n    static updateTimes(path, times) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fsx.utimesSync(path, times.accessedTime, times.modifiedTime);\n    }\n    /**\n     * Changes the permissions (i.e. file mode bits) for a filesystem object.\n     * Behind the scenes it uses `fs.chmodSync()`.\n     * @param path - The absolute or relative path to the object that should be updated.\n     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\n     */\n    static changePosixModeBits(path, mode) {\n        fs.chmodSync(path, mode);\n    }\n    /**\n     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.\n     * Behind the scenes it uses `fs.chmodSync()`.\n     * @param path - The absolute or relative path to the object that should be updated.\n     */\n    static getPosixModeBits(path) {\n        return FileSystem.getStatistics(path).mode;\n    }\n    /**\n     * Returns a 10-character string representation of a PosixModeBits value similar to what\n     * would be displayed by a command such as \"ls -l\" on a POSIX-like operating system.\n     * @remarks\n     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as \"-rw-rw-rw-\".\n     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum\n     */\n    static formatPosixModeBits(modeBits) {\n        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)\n        result += (modeBits & 256 /* UserRead */) ? 'r' : '-';\n        result += (modeBits & 128 /* UserWrite */) ? 'w' : '-';\n        result += (modeBits & 64 /* UserExecute */) ? 'x' : '-';\n        result += (modeBits & 32 /* GroupRead */) ? 'r' : '-';\n        result += (modeBits & 16 /* GroupWrite */) ? 'w' : '-';\n        result += (modeBits & 8 /* GroupExecute */) ? 'x' : '-';\n        result += (modeBits & 4 /* OthersRead */) ? 'r' : '-';\n        result += (modeBits & 2 /* OthersWrite */) ? 'w' : '-';\n        result += (modeBits & 1 /* OthersExecute */) ? 'x' : '-';\n        return result;\n    }\n    /**\n     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.\n     * Behind the scenes it uses `fs-extra.moveSync()`\n     */\n    static move(options) {\n        options = Object.assign({ overwrite: true, ensureFolderExists: false }, options);\n        if (options.ensureFolderExists) {\n            FileSystem.ensureFolder(pathUtilities.basename(options.sourcePath));\n        }\n        fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });\n    }\n    // ===============\n    // FOLDER OPERATIONS\n    // ===============\n    /**\n     * Recursively creates a folder at a given path.\n     * Behind the scenes is uses `fs-extra.ensureDirSync()`.\n     * @remarks\n     * Throws an exception if anything in the folderPath is not a folder.\n     * @param folderPath - The absolute or relative path of the folder which should be created.\n     */\n    static ensureFolder(folderPath) {\n        fsx.ensureDirSync(folderPath);\n    }\n    /**\n     * Reads the contents of the folder, not including \".\" or \"..\".\n     * Behind the scenes it uses `fs.readdirSync()`.\n     * @param folderPath - The absolute or relative path to the folder which should be read.\n     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`\n     */\n    static readFolder(folderPath, options) {\n        options = Object.assign({ absolutePaths: false }, options);\n        if (!FileSystem.exists(folderPath)) {\n            throw new Error(`Folder does not exist: \"${folderPath}\"`);\n        }\n        const fileNames = fsx.readdirSync(folderPath);\n        if (options.absolutePaths) {\n            return fileNames.map(fileName => pathUtilities.resolve(folderPath, fileName));\n        }\n        return fileNames;\n    }\n    /**\n     * Deletes a folder, including all of its contents.\n     * Behind the scenes is uses `fs-extra.removeSync()`.\n     * @remarks\n     * Does not throw if the folderPath does not exist.\n     * @param folderPath - The absolute or relative path to the folder which should be deleted.\n     */\n    static deleteFolder(folderPath) {\n        fsx.removeSync(folderPath);\n    }\n    /**\n     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.\n     * Behind the scenes it uses `fs-extra.emptyDirSync()`.\n     * @remarks\n     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder\n     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.\n     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.\n     */\n    static ensureEmptyFolder(folderPath) {\n        fsx.emptyDirSync(folderPath);\n    }\n    // ===============\n    // FILE OPERATIONS\n    // ===============\n    /**\n     * Writes a text string to a file on disk, overwriting the file if it already exists.\n     * Behind the scenes it uses `fs.writeFileSync()`.\n     * @remarks\n     * Throws an error if the folder doesn't exist, unless ensureFolder=true.\n     * @param filePath - The absolute or relative path of the file.\n     * @param contents - The text that should be written to the file.\n     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\n     */\n    static writeFile(filePath, contents, options) {\n        options = Object.assign({ ensureFolderExists: false, convertLineEndings: undefined, encoding: \"utf8\" /* Utf8 */ }, options);\n        if (options.ensureFolderExists) {\n            const folderPath = pathUtilities.dirname(filePath);\n            FileSystem.ensureFolder(folderPath);\n        }\n        if (options.convertLineEndings) {\n            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);\n        }\n        fsx.writeFileSync(filePath, contents, { encoding: options.encoding });\n    }\n    /**\n     * Writes a text string to a file on disk, appending to the file if it already exists.\n     * Behind the scenes it uses `fs.appendFileSync()`.\n     * @remarks\n     * Throws an error if the folder doesn't exist, unless ensureFolder=true.\n     * @param filePath - The absolute or relative path of the file.\n     * @param contents - The text that should be written to the file.\n     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`\n     */\n    static appendToFile(filePath, contents, options) {\n        options = Object.assign({ ensureFolderExists: false, convertLineEndings: undefined, encoding: \"utf8\" /* Utf8 */ }, options);\n        if (options.ensureFolderExists) {\n            const folderPath = pathUtilities.dirname(filePath);\n            FileSystem.ensureFolder(folderPath);\n        }\n        if (options.convertLineEndings) {\n            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);\n        }\n        fsx.appendFileSync(filePath, contents, { encoding: options.encoding });\n    }\n    /**\n     * Reads the contents of a file into a string.\n     * Behind the scenes it uses `fs.readFileSync()`.\n     * @param filePath - The relative or absolute path to the file whose contents should be read.\n     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`\n     */\n    static readFile(filePath, options) {\n        options = Object.assign({ encoding: \"utf8\" /* Utf8 */, convertLineEndings: undefined }, options);\n        let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);\n        if (options.convertLineEndings) {\n            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);\n        }\n        return contents;\n    }\n    /**\n     * Reads the contents of a file into a buffer.\n     * Behind the scenes is uses `fs.readFileSync()`.\n     * @param filePath - The relative or absolute path to the file whose contents should be read.\n     */\n    static readFileToBuffer(filePath) {\n        return fsx.readFileSync(filePath);\n    }\n    /**\n     * Copies a file from one location to another.\n     * By default, destinationPath is overwritten if it already exists.\n     * Behind the scenes it uses `fs.copyFileSync()`.\n     */\n    static copyFile(options) {\n        fsx.copySync(options.sourcePath, options.destinationPath);\n    }\n    /**\n     * Deletes a file. Can optionally throw if the file doesn't exist.\n     * Behind the scenes it uses `fs.unlinkSync()`.\n     * @param filePath - The absolute or relative path to the file that should be deleted.\n     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`\n     */\n    static deleteFile(filePath, options) {\n        options = Object.assign({ throwIfNotExists: false }, options);\n        if (options.throwIfNotExists) {\n            fsx.unlinkSync(filePath);\n        }\n        else {\n            try {\n                fsx.unlinkSync(filePath);\n            }\n            catch (error) {\n                /* no-op */\n            }\n        }\n    }\n    // ===============\n    // LINK OPERATIONS\n    // ===============\n    /**\n     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.\n     * Behind the scenes it uses `fs.lstatSync()`.\n     * @param path - The absolute or relative path to the filesystem object.\n     */\n    static getLinkStatistics(path) {\n        return fsx.lstatSync(path);\n    }\n    /**\n     * Creates a Windows \"directory junction\". Behaves like `createSymbolicLinkToFile()` on other platforms.\n     * Behind the scenes it uses `fs.symlinkSync()`.\n     */\n    static createSymbolicLinkJunction(options) {\n        // For directories, we use a Windows \"junction\".  On POSIX operating systems, this produces a regular symlink.\n        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');\n    }\n    /**\n     * Creates a symbolic link to a file (on Windows this requires elevated permissionsBits).\n     * Behind the scenes it uses `fs.symlinkSync()`.\n     */\n    static createSymbolicLinkFile(options) {\n        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');\n    }\n    /**\n     * Creates a symbolic link to a folder (on Windows this requires elevated permissionsBits).\n     * Behind the scenes it uses `fs.symlinkSync()`.\n     */\n    static createSymbolicLinkFolder(options) {\n        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');\n    }\n    /**\n     * Creates a hard link.\n     * Behind the scenes it uses `fs.linkSync()`.\n     */\n    static createHardLink(options) {\n        fsx.linkSync(options.linkTargetPath, options.newLinkPath);\n    }\n    /**\n     * Follows a link to its destination and returns the absolute path to the final target of the link.\n     * Behind the scenes it uses `fs.realpathSync()`.\n     * @param linkPath - The path to the link.\n     */\n    static getRealPath(linkPath) {\n        return fsx.realpathSync(linkPath);\n    }\n}\nexports.FileSystem = FileSystem;\n//# sourceMappingURL=FileSystem.js.map"]}