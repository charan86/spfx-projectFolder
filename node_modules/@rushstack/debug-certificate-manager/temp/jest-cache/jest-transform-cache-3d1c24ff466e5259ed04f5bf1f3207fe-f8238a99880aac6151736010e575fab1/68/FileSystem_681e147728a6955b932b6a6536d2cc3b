7785b6e2bcc57f1d009c0933dac23b2b
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const pathUtilities = require("path");
const fs = require("fs");
const fsx = require("fs-extra");
const Text_1 = require("./Text");
/**
 * The FileSystem API provides a complete set of recommended operations for interacting with the file system.
 *
 * @remarks
 * We recommend to use this instead of the native `fs` API, because `fs` is a minimal set of low-level
 * primitives that must be mapped for each supported operating system. The FileSystem API takes a
 * philosophical approach of providing "one obvious way" to do each operation. We also prefer synchronous
 * operations except in cases where there would be a clear performance benefit for using async, since synchronous
 * code is much easier to read and debug. Also, indiscriminate parallelism has been seen to actually worsen
 * performance, versus improving it.
 *
 * Note that in the documentation, we refer to "filesystem objects", this can be a
 * file, folder, symbolic link, hard link, directory junction, etc.
 *
 * @public
 */
class FileSystem {
    // ===============
    // COMMON OPERATIONS
    // ===============
    /**
     * Returns true if the path exists on disk.
     * Behind the scenes it uses `fs.existsSync()`.
     * @remarks
     * There is a debate about the fact that after `fs.existsSync()` returns true,
     * the file might be deleted before fs.readSync() is called, which would imply that everybody
     * should catch a `readSync()` exception, and nobody should ever use `fs.existsSync()`.
     * We find this to be unpersuasive, since "unexceptional exceptions" really hinder the
     * break-on-exception debugging experience. Also, throwing/catching is generally slow.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static exists(path) {
        return fsx.existsSync(path);
    }
    /**
     * Gets the statistics for a particular filesystem object.
     * If the path is a link, this function follows the link and returns statistics about the link target.
     * Behind the scenes it uses `fs.statSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getStatistics(path) {
        return fsx.statSync(path);
    }
    /**
     * Updates the accessed and modified timestamps of the filesystem object referenced by path.
     * Behind the scenes it uses `fs.utimesSync()`.
     * The caller should specify both times in the `times` parameter.
     * @param path - The path of the file that should be modified.
     * @param times - The times that the object should be updated to reflect.
     */
    static updateTimes(path, times) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        fsx.utimesSync(path, times.accessedTime, times.modifiedTime);
    }
    /**
     * Changes the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static changePosixModeBits(path, mode) {
        fs.chmodSync(path, mode);
    }
    /**
     * Retrieves the permissions (i.e. file mode bits) for a filesystem object.
     * Behind the scenes it uses `fs.chmodSync()`.
     * @param path - The absolute or relative path to the object that should be updated.
     */
    static getPosixModeBits(path) {
        return FileSystem.getStatistics(path).mode;
    }
    /**
     * Returns a 10-character string representation of a PosixModeBits value similar to what
     * would be displayed by a command such as "ls -l" on a POSIX-like operating system.
     * @remarks
     * For example, `PosixModeBits.AllRead | PosixModeBits.AllWrite` would be formatted as "-rw-rw-rw-".
     * @param modeBits - POSIX-style file mode bits specified using the {@link PosixModeBits} enum
     */
    static formatPosixModeBits(modeBits) {
        let result = '-'; // (later we may add support for additional states such as S_IFDIR or S_ISUID)
        result += modeBits & 256 /* UserRead */ ? 'r' : '-';
        result += modeBits & 128 /* UserWrite */ ? 'w' : '-';
        result += modeBits & 64 /* UserExecute */ ? 'x' : '-';
        result += modeBits & 32 /* GroupRead */ ? 'r' : '-';
        result += modeBits & 16 /* GroupWrite */ ? 'w' : '-';
        result += modeBits & 8 /* GroupExecute */ ? 'x' : '-';
        result += modeBits & 4 /* OthersRead */ ? 'r' : '-';
        result += modeBits & 2 /* OthersWrite */ ? 'w' : '-';
        result += modeBits & 1 /* OthersExecute */ ? 'x' : '-';
        return result;
    }
    /**
     * Moves a file. The folder must exist, unless the `ensureFolderExists` option is provided.
     * Behind the scenes it uses `fs-extra.moveSync()`
     */
    static move(options) {
        options = Object.assign({ overwrite: true, ensureFolderExists: false }, options);
        if (options.ensureFolderExists) {
            FileSystem.ensureFolder(pathUtilities.basename(options.sourcePath));
        }
        fsx.moveSync(options.sourcePath, options.destinationPath, { overwrite: options.overwrite });
    }
    // ===============
    // FOLDER OPERATIONS
    // ===============
    /**
     * Recursively creates a folder at a given path.
     * Behind the scenes is uses `fs-extra.ensureDirSync()`.
     * @remarks
     * Throws an exception if anything in the folderPath is not a folder.
     * @param folderPath - The absolute or relative path of the folder which should be created.
     */
    static ensureFolder(folderPath) {
        fsx.ensureDirSync(folderPath);
    }
    /**
     * Reads the contents of the folder, not including "." or "..".
     * Behind the scenes it uses `fs.readdirSync()`.
     * @param folderPath - The absolute or relative path to the folder which should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFolderOptions`
     */
    static readFolder(folderPath, options) {
        options = Object.assign({ absolutePaths: false }, options);
        if (!FileSystem.exists(folderPath)) {
            throw new Error(`Folder does not exist: "${folderPath}"`);
        }
        const fileNames = fsx.readdirSync(folderPath);
        if (options.absolutePaths) {
            return fileNames.map(fileName => pathUtilities.resolve(folderPath, fileName));
        }
        return fileNames;
    }
    /**
     * Deletes a folder, including all of its contents.
     * Behind the scenes is uses `fs-extra.removeSync()`.
     * @remarks
     * Does not throw if the folderPath does not exist.
     * @param folderPath - The absolute or relative path to the folder which should be deleted.
     */
    static deleteFolder(folderPath) {
        fsx.removeSync(folderPath);
    }
    /**
     * Deletes the content of a folder, but not the folder itself. Also ensures the folder exists.
     * Behind the scenes it uses `fs-extra.emptyDirSync()`.
     * @remarks
     * This is a workaround for a common race condition, where the virus scanner holds a lock on the folder
     * for a brief period after it was deleted, causing EBUSY errors for any code that tries to recreate the folder.
     * @param folderPath - The absolute or relative path to the folder which should have its contents deleted.
     */
    static ensureEmptyFolder(folderPath) {
        fsx.emptyDirSync(folderPath);
    }
    // ===============
    // FILE OPERATIONS
    // ===============
    /**
     * Writes a text string to a file on disk, overwriting the file if it already exists.
     * Behind the scenes it uses `fs.writeFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static writeFile(filePath, contents, options) {
        options = Object.assign({ ensureFolderExists: false, convertLineEndings: undefined, encoding: "utf8" /* Utf8 */ }, options);
        if (options.ensureFolderExists) {
            const folderPath = pathUtilities.dirname(filePath);
            FileSystem.ensureFolder(folderPath);
        }
        if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
        }
        fsx.writeFileSync(filePath, contents, { encoding: options.encoding });
    }
    /**
     * Writes a text string to a file on disk, appending to the file if it already exists.
     * Behind the scenes it uses `fs.appendFileSync()`.
     * @remarks
     * Throws an error if the folder doesn't exist, unless ensureFolder=true.
     * @param filePath - The absolute or relative path of the file.
     * @param contents - The text that should be written to the file.
     * @param options - Optional settings that can change the behavior. Type: `IWriteFileOptions`
     */
    static appendToFile(filePath, contents, options) {
        options = Object.assign({ ensureFolderExists: false, convertLineEndings: undefined, encoding: "utf8" /* Utf8 */ }, options);
        if (options.ensureFolderExists) {
            const folderPath = pathUtilities.dirname(filePath);
            FileSystem.ensureFolder(folderPath);
        }
        if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents.toString(), options.convertLineEndings);
        }
        fsx.appendFileSync(filePath, contents, { encoding: options.encoding });
    }
    /**
     * Reads the contents of a file into a string.
     * Behind the scenes it uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     * @param options - Optional settings that can change the behavior. Type: `IReadFileOptions`
     */
    static readFile(filePath, options) {
        options = Object.assign({ encoding: "utf8" /* Utf8 */, convertLineEndings: undefined }, options);
        let contents = FileSystem.readFileToBuffer(filePath).toString(options.encoding);
        if (options.convertLineEndings) {
            contents = Text_1.Text.convertTo(contents, options.convertLineEndings);
        }
        return contents;
    }
    /**
     * Reads the contents of a file into a buffer.
     * Behind the scenes is uses `fs.readFileSync()`.
     * @param filePath - The relative or absolute path to the file whose contents should be read.
     */
    static readFileToBuffer(filePath) {
        return fsx.readFileSync(filePath);
    }
    /**
     * Copies a file from one location to another.
     * By default, destinationPath is overwritten if it already exists.
     * Behind the scenes it uses `fs.copyFileSync()`.
     */
    static copyFile(options) {
        fsx.copySync(options.sourcePath, options.destinationPath);
    }
    /**
     * Deletes a file. Can optionally throw if the file doesn't exist.
     * Behind the scenes it uses `fs.unlinkSync()`.
     * @param filePath - The absolute or relative path to the file that should be deleted.
     * @param options - Optional settings that can change the behavior. Type: `IDeleteFileOptions`
     */
    static deleteFile(filePath, options) {
        options = Object.assign({ throwIfNotExists: false }, options);
        if (options.throwIfNotExists) {
            fsx.unlinkSync(filePath);
        } else {
            try {
                fsx.unlinkSync(filePath);
            } catch (error) {
                /* no-op */
            }
        }
    }
    // ===============
    // LINK OPERATIONS
    // ===============
    /**
     * Gets the statistics of a filesystem object. Does NOT follow the link to its target.
     * Behind the scenes it uses `fs.lstatSync()`.
     * @param path - The absolute or relative path to the filesystem object.
     */
    static getLinkStatistics(path) {
        return fsx.lstatSync(path);
    }
    /**
     * Creates a Windows "directory junction". Behaves like `createSymbolicLinkToFile()` on other platforms.
     * Behind the scenes it uses `fs.symlinkSync()`.
     */
    static createSymbolicLinkJunction(options) {
        // For directories, we use a Windows "junction".  On POSIX operating systems, this produces a regular symlink.
        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'junction');
    }
    /**
     * Creates a symbolic link to a file (on Windows this requires elevated permissionsBits).
     * Behind the scenes it uses `fs.symlinkSync()`.
     */
    static createSymbolicLinkFile(options) {
        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'file');
    }
    /**
     * Creates a symbolic link to a folder (on Windows this requires elevated permissionsBits).
     * Behind the scenes it uses `fs.symlinkSync()`.
     */
    static createSymbolicLinkFolder(options) {
        fsx.symlinkSync(options.linkTargetPath, options.newLinkPath, 'dir');
    }
    /**
     * Creates a hard link.
     * Behind the scenes it uses `fs.linkSync()`.
     */
    static createHardLink(options) {
        fsx.linkSync(options.linkTargetPath, options.newLinkPath);
    }
    /**
     * Follows a link to its destination and returns the absolute path to the final target of the link.
     * Behind the scenes it uses `fs.realpathSync()`.
     * @param linkPath - The path to the link.
     */
    static getRealPath(linkPath) {
        return fsx.realpathSync(linkPath);
    }
}
exports.FileSystem = FileSystem;
//# sourceMappingURL=FileSystem.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkZpbGVTeXN0ZW0uanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXRoVXRpbGl0aWVzIiwicmVxdWlyZSIsImZzIiwiZnN4IiwiVGV4dF8xIiwiRmlsZVN5c3RlbSIsImV4aXN0cyIsInBhdGgiLCJleGlzdHNTeW5jIiwiZ2V0U3RhdGlzdGljcyIsInN0YXRTeW5jIiwidXBkYXRlVGltZXMiLCJ0aW1lcyIsInV0aW1lc1N5bmMiLCJhY2Nlc3NlZFRpbWUiLCJtb2RpZmllZFRpbWUiLCJjaGFuZ2VQb3NpeE1vZGVCaXRzIiwibW9kZSIsImNobW9kU3luYyIsImdldFBvc2l4TW9kZUJpdHMiLCJmb3JtYXRQb3NpeE1vZGVCaXRzIiwibW9kZUJpdHMiLCJyZXN1bHQiLCJtb3ZlIiwib3B0aW9ucyIsImFzc2lnbiIsIm92ZXJ3cml0ZSIsImVuc3VyZUZvbGRlckV4aXN0cyIsImVuc3VyZUZvbGRlciIsImJhc2VuYW1lIiwic291cmNlUGF0aCIsIm1vdmVTeW5jIiwiZGVzdGluYXRpb25QYXRoIiwiZm9sZGVyUGF0aCIsImVuc3VyZURpclN5bmMiLCJyZWFkRm9sZGVyIiwiYWJzb2x1dGVQYXRocyIsIkVycm9yIiwiZmlsZU5hbWVzIiwicmVhZGRpclN5bmMiLCJtYXAiLCJmaWxlTmFtZSIsInJlc29sdmUiLCJkZWxldGVGb2xkZXIiLCJyZW1vdmVTeW5jIiwiZW5zdXJlRW1wdHlGb2xkZXIiLCJlbXB0eURpclN5bmMiLCJ3cml0ZUZpbGUiLCJmaWxlUGF0aCIsImNvbnRlbnRzIiwiY29udmVydExpbmVFbmRpbmdzIiwidW5kZWZpbmVkIiwiZW5jb2RpbmciLCJkaXJuYW1lIiwiVGV4dCIsImNvbnZlcnRUbyIsInRvU3RyaW5nIiwid3JpdGVGaWxlU3luYyIsImFwcGVuZFRvRmlsZSIsImFwcGVuZEZpbGVTeW5jIiwicmVhZEZpbGUiLCJyZWFkRmlsZVRvQnVmZmVyIiwicmVhZEZpbGVTeW5jIiwiY29weUZpbGUiLCJjb3B5U3luYyIsImRlbGV0ZUZpbGUiLCJ0aHJvd0lmTm90RXhpc3RzIiwidW5saW5rU3luYyIsImVycm9yIiwiZ2V0TGlua1N0YXRpc3RpY3MiLCJsc3RhdFN5bmMiLCJjcmVhdGVTeW1ib2xpY0xpbmtKdW5jdGlvbiIsInN5bWxpbmtTeW5jIiwibGlua1RhcmdldFBhdGgiLCJuZXdMaW5rUGF0aCIsImNyZWF0ZVN5bWJvbGljTGlua0ZpbGUiLCJjcmVhdGVTeW1ib2xpY0xpbmtGb2xkZXIiLCJjcmVhdGVIYXJkTGluayIsImxpbmtTeW5jIiwiZ2V0UmVhbFBhdGgiLCJsaW5rUGF0aCIsInJlYWxwYXRoU3luYyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQSxNQUFNQyxnQkFBZ0JDLFFBQVEsTUFBUixDQUF0QjtBQUNBLE1BQU1DLEtBQUtELFFBQVEsSUFBUixDQUFYO0FBQ0EsTUFBTUUsTUFBTUYsUUFBUSxVQUFSLENBQVo7QUFDQSxNQUFNRyxTQUFTSCxRQUFRLFFBQVIsQ0FBZjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLE1BQU1JLFVBQU4sQ0FBaUI7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQSxXQUFPQyxNQUFQLENBQWNDLElBQWQsRUFBb0I7QUFDaEIsZUFBT0osSUFBSUssVUFBSixDQUFlRCxJQUFmLENBQVA7QUFDSDtBQUNEOzs7Ozs7QUFNQSxXQUFPRSxhQUFQLENBQXFCRixJQUFyQixFQUEyQjtBQUN2QixlQUFPSixJQUFJTyxRQUFKLENBQWFILElBQWIsQ0FBUDtBQUNIO0FBQ0Q7Ozs7Ozs7QUFPQSxXQUFPSSxXQUFQLENBQW1CSixJQUFuQixFQUF5QkssS0FBekIsRUFBZ0M7QUFDNUI7QUFDQVQsWUFBSVUsVUFBSixDQUFlTixJQUFmLEVBQXFCSyxNQUFNRSxZQUEzQixFQUF5Q0YsTUFBTUcsWUFBL0M7QUFD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QkQsUUFBakIsQ0FBUDtBQUNIO0FBclJZO0FBdVJqQmxGLFFBQVFPLFVBQVIsR0FBcUJBLFVBQXJCO0FBQ0EiLCJmaWxlIjoiRmlsZVN5c3RlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXRoVXRpbGl0aWVzID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGZzeCA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuL1RleHRcIik7XG4vKipcbiAqIFRoZSBGaWxlU3lzdGVtIEFQSSBwcm92aWRlcyBhIGNvbXBsZXRlIHNldCBvZiByZWNvbW1lbmRlZCBvcGVyYXRpb25zIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBmaWxlIHN5c3RlbS5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2UgcmVjb21tZW5kIHRvIHVzZSB0aGlzIGluc3RlYWQgb2YgdGhlIG5hdGl2ZSBgZnNgIEFQSSwgYmVjYXVzZSBgZnNgIGlzIGEgbWluaW1hbCBzZXQgb2YgbG93LWxldmVsXG4gKiBwcmltaXRpdmVzIHRoYXQgbXVzdCBiZSBtYXBwZWQgZm9yIGVhY2ggc3VwcG9ydGVkIG9wZXJhdGluZyBzeXN0ZW0uIFRoZSBGaWxlU3lzdGVtIEFQSSB0YWtlcyBhXG4gKiBwaGlsb3NvcGhpY2FsIGFwcHJvYWNoIG9mIHByb3ZpZGluZyBcIm9uZSBvYnZpb3VzIHdheVwiIHRvIGRvIGVhY2ggb3BlcmF0aW9uLiBXZSBhbHNvIHByZWZlciBzeW5jaHJvbm91c1xuICogb3BlcmF0aW9ucyBleGNlcHQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgd291bGQgYmUgYSBjbGVhciBwZXJmb3JtYW5jZSBiZW5lZml0IGZvciB1c2luZyBhc3luYywgc2luY2Ugc3luY2hyb25vdXNcbiAqIGNvZGUgaXMgbXVjaCBlYXNpZXIgdG8gcmVhZCBhbmQgZGVidWcuIEFsc28sIGluZGlzY3JpbWluYXRlIHBhcmFsbGVsaXNtIGhhcyBiZWVuIHNlZW4gdG8gYWN0dWFsbHkgd29yc2VuXG4gKiBwZXJmb3JtYW5jZSwgdmVyc3VzIGltcHJvdmluZyBpdC5cbiAqXG4gKiBOb3RlIHRoYXQgaW4gdGhlIGRvY3VtZW50YXRpb24sIHdlIHJlZmVyIHRvIFwiZmlsZXN5c3RlbSBvYmplY3RzXCIsIHRoaXMgY2FuIGJlIGFcbiAqIGZpbGUsIGZvbGRlciwgc3ltYm9saWMgbGluaywgaGFyZCBsaW5rLCBkaXJlY3RvcnkganVuY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEZpbGVTeXN0ZW0ge1xuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIC8vIENPTU1PTiBPUEVSQVRJT05TXG4gICAgLy8gPT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGV4aXN0cyBvbiBkaXNrLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLmV4aXN0c1N5bmMoKWAuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGVyZSBpcyBhIGRlYmF0ZSBhYm91dCB0aGUgZmFjdCB0aGF0IGFmdGVyIGBmcy5leGlzdHNTeW5jKClgIHJldHVybnMgdHJ1ZSxcbiAgICAgKiB0aGUgZmlsZSBtaWdodCBiZSBkZWxldGVkIGJlZm9yZSBmcy5yZWFkU3luYygpIGlzIGNhbGxlZCwgd2hpY2ggd291bGQgaW1wbHkgdGhhdCBldmVyeWJvZHlcbiAgICAgKiBzaG91bGQgY2F0Y2ggYSBgcmVhZFN5bmMoKWAgZXhjZXB0aW9uLCBhbmQgbm9ib2R5IHNob3VsZCBldmVyIHVzZSBgZnMuZXhpc3RzU3luYygpYC5cbiAgICAgKiBXZSBmaW5kIHRoaXMgdG8gYmUgdW5wZXJzdWFzaXZlLCBzaW5jZSBcInVuZXhjZXB0aW9uYWwgZXhjZXB0aW9uc1wiIHJlYWxseSBoaW5kZXIgdGhlXG4gICAgICogYnJlYWstb24tZXhjZXB0aW9uIGRlYnVnZ2luZyBleHBlcmllbmNlLiBBbHNvLCB0aHJvd2luZy9jYXRjaGluZyBpcyBnZW5lcmFsbHkgc2xvdy5cbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlc3lzdGVtIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhpc3RzKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZzeC5leGlzdHNTeW5jKHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0aXN0aWNzIGZvciBhIHBhcnRpY3VsYXIgZmlsZXN5c3RlbSBvYmplY3QuXG4gICAgICogSWYgdGhlIHBhdGggaXMgYSBsaW5rLCB0aGlzIGZ1bmN0aW9uIGZvbGxvd3MgdGhlIGxpbmsgYW5kIHJldHVybnMgc3RhdGlzdGljcyBhYm91dCB0aGUgbGluayB0YXJnZXQuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMuc3RhdFN5bmMoKWAuXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcGF0aCB0byB0aGUgZmlsZXN5c3RlbSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0YXRpc3RpY3MocGF0aCkge1xuICAgICAgICByZXR1cm4gZnN4LnN0YXRTeW5jKHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhY2Nlc3NlZCBhbmQgbW9kaWZpZWQgdGltZXN0YW1wcyBvZiB0aGUgZmlsZXN5c3RlbSBvYmplY3QgcmVmZXJlbmNlZCBieSBwYXRoLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLnV0aW1lc1N5bmMoKWAuXG4gICAgICogVGhlIGNhbGxlciBzaG91bGQgc3BlY2lmeSBib3RoIHRpbWVzIGluIHRoZSBgdGltZXNgIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRoYXQgc2hvdWxkIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSB0aW1lcyAtIFRoZSB0aW1lcyB0aGF0IHRoZSBvYmplY3Qgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlVGltZXMocGF0aCwgdGltZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZnN4LnV0aW1lc1N5bmMocGF0aCwgdGltZXMuYWNjZXNzZWRUaW1lLCB0aW1lcy5tb2RpZmllZFRpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBwZXJtaXNzaW9ucyAoaS5lLiBmaWxlIG1vZGUgYml0cykgZm9yIGEgZmlsZXN5c3RlbSBvYmplY3QuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMuY2htb2RTeW5jKClgLlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBhdGggdG8gdGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBtb2RlQml0cyAtIFBPU0lYLXN0eWxlIGZpbGUgbW9kZSBiaXRzIHNwZWNpZmllZCB1c2luZyB0aGUge0BsaW5rIFBvc2l4TW9kZUJpdHN9IGVudW1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhbmdlUG9zaXhNb2RlQml0cyhwYXRoLCBtb2RlKSB7XG4gICAgICAgIGZzLmNobW9kU3luYyhwYXRoLCBtb2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBwZXJtaXNzaW9ucyAoaS5lLiBmaWxlIG1vZGUgYml0cykgZm9yIGEgZmlsZXN5c3RlbSBvYmplY3QuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMuY2htb2RTeW5jKClgLlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBhdGggdG8gdGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZSB1cGRhdGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQb3NpeE1vZGVCaXRzKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uZ2V0U3RhdGlzdGljcyhwYXRoKS5tb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgMTAtY2hhcmFjdGVyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFBvc2l4TW9kZUJpdHMgdmFsdWUgc2ltaWxhciB0byB3aGF0XG4gICAgICogd291bGQgYmUgZGlzcGxheWVkIGJ5IGEgY29tbWFuZCBzdWNoIGFzIFwibHMgLWxcIiBvbiBhIFBPU0lYLWxpa2Ugb3BlcmF0aW5nIHN5c3RlbS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCBgUG9zaXhNb2RlQml0cy5BbGxSZWFkIHwgUG9zaXhNb2RlQml0cy5BbGxXcml0ZWAgd291bGQgYmUgZm9ybWF0dGVkIGFzIFwiLXJ3LXJ3LXJ3LVwiLlxuICAgICAqIEBwYXJhbSBtb2RlQml0cyAtIFBPU0lYLXN0eWxlIGZpbGUgbW9kZSBiaXRzIHNwZWNpZmllZCB1c2luZyB0aGUge0BsaW5rIFBvc2l4TW9kZUJpdHN9IGVudW1cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0UG9zaXhNb2RlQml0cyhtb2RlQml0cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJy0nOyAvLyAobGF0ZXIgd2UgbWF5IGFkZCBzdXBwb3J0IGZvciBhZGRpdGlvbmFsIHN0YXRlcyBzdWNoIGFzIFNfSUZESVIgb3IgU19JU1VJRClcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDI1NiAvKiBVc2VyUmVhZCAqLykgPyAncicgOiAnLSc7XG4gICAgICAgIHJlc3VsdCArPSAobW9kZUJpdHMgJiAxMjggLyogVXNlcldyaXRlICovKSA/ICd3JyA6ICctJztcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDY0IC8qIFVzZXJFeGVjdXRlICovKSA/ICd4JyA6ICctJztcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDMyIC8qIEdyb3VwUmVhZCAqLykgPyAncicgOiAnLSc7XG4gICAgICAgIHJlc3VsdCArPSAobW9kZUJpdHMgJiAxNiAvKiBHcm91cFdyaXRlICovKSA/ICd3JyA6ICctJztcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDggLyogR3JvdXBFeGVjdXRlICovKSA/ICd4JyA6ICctJztcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDQgLyogT3RoZXJzUmVhZCAqLykgPyAncicgOiAnLSc7XG4gICAgICAgIHJlc3VsdCArPSAobW9kZUJpdHMgJiAyIC8qIE90aGVyc1dyaXRlICovKSA/ICd3JyA6ICctJztcbiAgICAgICAgcmVzdWx0ICs9IChtb2RlQml0cyAmIDEgLyogT3RoZXJzRXhlY3V0ZSAqLykgPyAneCcgOiAnLSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgZmlsZS4gVGhlIGZvbGRlciBtdXN0IGV4aXN0LCB1bmxlc3MgdGhlIGBlbnN1cmVGb2xkZXJFeGlzdHNgIG9wdGlvbiBpcyBwcm92aWRlZC5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy1leHRyYS5tb3ZlU3luYygpYFxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBvdmVyd3JpdGU6IHRydWUsIGVuc3VyZUZvbGRlckV4aXN0czogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmVuc3VyZUZvbGRlckV4aXN0cykge1xuICAgICAgICAgICAgRmlsZVN5c3RlbS5lbnN1cmVGb2xkZXIocGF0aFV0aWxpdGllcy5iYXNlbmFtZShvcHRpb25zLnNvdXJjZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBmc3gubW92ZVN5bmMob3B0aW9ucy5zb3VyY2VQYXRoLCBvcHRpb25zLmRlc3RpbmF0aW9uUGF0aCwgeyBvdmVyd3JpdGU6IG9wdGlvbnMub3ZlcndyaXRlIH0pO1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvLyBGT0xERVIgT1BFUkFUSU9OU1xuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNyZWF0ZXMgYSBmb2xkZXIgYXQgYSBnaXZlbiBwYXRoLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGlzIHVzZXMgYGZzLWV4dHJhLmVuc3VyZURpclN5bmMoKWAuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGFueXRoaW5nIGluIHRoZSBmb2xkZXJQYXRoIGlzIG5vdCBhIGZvbGRlci5cbiAgICAgKiBAcGFyYW0gZm9sZGVyUGF0aCAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIG9mIHRoZSBmb2xkZXIgd2hpY2ggc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGVuc3VyZUZvbGRlcihmb2xkZXJQYXRoKSB7XG4gICAgICAgIGZzeC5lbnN1cmVEaXJTeW5jKGZvbGRlclBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgdGhlIGZvbGRlciwgbm90IGluY2x1ZGluZyBcIi5cIiBvciBcIi4uXCIuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMucmVhZGRpclN5bmMoKWAuXG4gICAgICogQHBhcmFtIGZvbGRlclBhdGggLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcGF0aCB0byB0aGUgZm9sZGVyIHdoaWNoIHNob3VsZCBiZSByZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gY2hhbmdlIHRoZSBiZWhhdmlvci4gVHlwZTogYElSZWFkRm9sZGVyT3B0aW9uc2BcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVhZEZvbGRlcihmb2xkZXJQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWJzb2x1dGVQYXRoczogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghRmlsZVN5c3RlbS5leGlzdHMoZm9sZGVyUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9sZGVyIGRvZXMgbm90IGV4aXN0OiBcIiR7Zm9sZGVyUGF0aH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lcyA9IGZzeC5yZWFkZGlyU3luYyhmb2xkZXJQYXRoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWJzb2x1dGVQYXRocykge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lcy5tYXAoZmlsZU5hbWUgPT4gcGF0aFV0aWxpdGllcy5yZXNvbHZlKGZvbGRlclBhdGgsIGZpbGVOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGZvbGRlciwgaW5jbHVkaW5nIGFsbCBvZiBpdHMgY29udGVudHMuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXMgdXNlcyBgZnMtZXh0cmEucmVtb3ZlU3luYygpYC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERvZXMgbm90IHRocm93IGlmIHRoZSBmb2xkZXJQYXRoIGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBwYXJhbSBmb2xkZXJQYXRoIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBhdGggdG8gdGhlIGZvbGRlciB3aGljaCBzaG91bGQgYmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlRm9sZGVyKGZvbGRlclBhdGgpIHtcbiAgICAgICAgZnN4LnJlbW92ZVN5bmMoZm9sZGVyUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGNvbnRlbnQgb2YgYSBmb2xkZXIsIGJ1dCBub3QgdGhlIGZvbGRlciBpdHNlbGYuIEFsc28gZW5zdXJlcyB0aGUgZm9sZGVyIGV4aXN0cy5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy1leHRyYS5lbXB0eURpclN5bmMoKWAuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBjb21tb24gcmFjZSBjb25kaXRpb24sIHdoZXJlIHRoZSB2aXJ1cyBzY2FubmVyIGhvbGRzIGEgbG9jayBvbiB0aGUgZm9sZGVyXG4gICAgICogZm9yIGEgYnJpZWYgcGVyaW9kIGFmdGVyIGl0IHdhcyBkZWxldGVkLCBjYXVzaW5nIEVCVVNZIGVycm9ycyBmb3IgYW55IGNvZGUgdGhhdCB0cmllcyB0byByZWNyZWF0ZSB0aGUgZm9sZGVyLlxuICAgICAqIEBwYXJhbSBmb2xkZXJQYXRoIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBhdGggdG8gdGhlIGZvbGRlciB3aGljaCBzaG91bGQgaGF2ZSBpdHMgY29udGVudHMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5zdXJlRW1wdHlGb2xkZXIoZm9sZGVyUGF0aCkge1xuICAgICAgICBmc3guZW1wdHlEaXJTeW5jKGZvbGRlclBhdGgpO1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvLyBGSUxFIE9QRVJBVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0ZXh0IHN0cmluZyB0byBhIGZpbGUgb24gZGlzaywgb3ZlcndyaXRpbmcgdGhlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMud3JpdGVGaWxlU3luYygpYC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZm9sZGVyIGRvZXNuJ3QgZXhpc3QsIHVubGVzcyBlbnN1cmVGb2xkZXI9dHJ1ZS5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcGFyYW0gY29udGVudHMgLSBUaGUgdGV4dCB0aGF0IHNob3VsZCBiZSB3cml0dGVuIHRvIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gY2hhbmdlIHRoZSBiZWhhdmlvci4gVHlwZTogYElXcml0ZUZpbGVPcHRpb25zYFxuICAgICAqL1xuICAgIHN0YXRpYyB3cml0ZUZpbGUoZmlsZVBhdGgsIGNvbnRlbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZW5zdXJlRm9sZGVyRXhpc3RzOiBmYWxzZSwgY29udmVydExpbmVFbmRpbmdzOiB1bmRlZmluZWQsIGVuY29kaW5nOiBcInV0ZjhcIiAvKiBVdGY4ICovIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVGb2xkZXJFeGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSBwYXRoVXRpbGl0aWVzLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgRmlsZVN5c3RlbS5lbnN1cmVGb2xkZXIoZm9sZGVyUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydExpbmVFbmRpbmdzKSB7XG4gICAgICAgICAgICBjb250ZW50cyA9IFRleHRfMS5UZXh0LmNvbnZlcnRUbyhjb250ZW50cy50b1N0cmluZygpLCBvcHRpb25zLmNvbnZlcnRMaW5lRW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnN4LndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnRzLCB7IGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0ZXh0IHN0cmluZyB0byBhIGZpbGUgb24gZGlzaywgYXBwZW5kaW5nIHRvIHRoZSBmaWxlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLmFwcGVuZEZpbGVTeW5jKClgLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmb2xkZXIgZG9lc24ndCBleGlzdCwgdW5sZXNzIGVuc3VyZUZvbGRlcj10cnVlLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAqIEBwYXJhbSBjb250ZW50cyAtIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIHdyaXR0ZW4gdG8gdGhlIGZpbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yLiBUeXBlOiBgSVdyaXRlRmlsZU9wdGlvbnNgXG4gICAgICovXG4gICAgc3RhdGljIGFwcGVuZFRvRmlsZShmaWxlUGF0aCwgY29udGVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBlbnN1cmVGb2xkZXJFeGlzdHM6IGZhbHNlLCBjb252ZXJ0TGluZUVuZGluZ3M6IHVuZGVmaW5lZCwgZW5jb2Rpbmc6IFwidXRmOFwiIC8qIFV0ZjggKi8gfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmVuc3VyZUZvbGRlckV4aXN0cykge1xuICAgICAgICAgICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGhVdGlsaXRpZXMuZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgICAgICBGaWxlU3lzdGVtLmVuc3VyZUZvbGRlcihmb2xkZXJQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0TGluZUVuZGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gVGV4dF8xLlRleHQuY29udmVydFRvKGNvbnRlbnRzLnRvU3RyaW5nKCksIG9wdGlvbnMuY29udmVydExpbmVFbmRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmc3guYXBwZW5kRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnRzLCB7IGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgYSBmaWxlIGludG8gYSBzdHJpbmcuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXQgdXNlcyBgZnMucmVhZEZpbGVTeW5jKClgLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlIHdob3NlIGNvbnRlbnRzIHNob3VsZCBiZSByZWFkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgdGhhdCBjYW4gY2hhbmdlIHRoZSBiZWhhdmlvci4gVHlwZTogYElSZWFkRmlsZU9wdGlvbnNgXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRGaWxlKGZpbGVQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZW5jb2Rpbmc6IFwidXRmOFwiIC8qIFV0ZjggKi8sIGNvbnZlcnRMaW5lRW5kaW5nczogdW5kZWZpbmVkIH0sIG9wdGlvbnMpO1xuICAgICAgICBsZXQgY29udGVudHMgPSBGaWxlU3lzdGVtLnJlYWRGaWxlVG9CdWZmZXIoZmlsZVBhdGgpLnRvU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0TGluZUVuZGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gVGV4dF8xLlRleHQuY29udmVydFRvKGNvbnRlbnRzLCBvcHRpb25zLmNvbnZlcnRMaW5lRW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgYSBmaWxlIGludG8gYSBidWZmZXIuXG4gICAgICogQmVoaW5kIHRoZSBzY2VuZXMgaXMgdXNlcyBgZnMucmVhZEZpbGVTeW5jKClgLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlIHdob3NlIGNvbnRlbnRzIHNob3VsZCBiZSByZWFkLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWFkRmlsZVRvQnVmZmVyKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBmc3gucmVhZEZpbGVTeW5jKGZpbGVQYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgZmlsZSBmcm9tIG9uZSBsb2NhdGlvbiB0byBhbm90aGVyLlxuICAgICAqIEJ5IGRlZmF1bHQsIGRlc3RpbmF0aW9uUGF0aCBpcyBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy5jb3B5RmlsZVN5bmMoKWAuXG4gICAgICovXG4gICAgc3RhdGljIGNvcHlGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgZnN4LmNvcHlTeW5jKG9wdGlvbnMuc291cmNlUGF0aCwgb3B0aW9ucy5kZXN0aW5hdGlvblBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgZmlsZS4gQ2FuIG9wdGlvbmFsbHkgdGhyb3cgaWYgdGhlIGZpbGUgZG9lc24ndCBleGlzdC5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy51bmxpbmtTeW5jKClgLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlIHRoYXQgc2hvdWxkIGJlIGRlbGV0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncyB0aGF0IGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yLiBUeXBlOiBgSURlbGV0ZUZpbGVPcHRpb25zYFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVGaWxlKGZpbGVQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdGhyb3dJZk5vdEV4aXN0czogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnRocm93SWZOb3RFeGlzdHMpIHtcbiAgICAgICAgICAgIGZzeC51bmxpbmtTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnN4LnVubGlua1N5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvLyBMSU5LIE9QRVJBVElPTlNcbiAgICAvLyA9PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0aXN0aWNzIG9mIGEgZmlsZXN5c3RlbSBvYmplY3QuIERvZXMgTk9UIGZvbGxvdyB0aGUgbGluayB0byBpdHMgdGFyZ2V0LlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLmxzdGF0U3luYygpYC5cbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHRvIHRoZSBmaWxlc3lzdGVtIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TGlua1N0YXRpc3RpY3MocGF0aCkge1xuICAgICAgICByZXR1cm4gZnN4LmxzdGF0U3luYyhwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdpbmRvd3MgXCJkaXJlY3RvcnkganVuY3Rpb25cIi4gQmVoYXZlcyBsaWtlIGBjcmVhdGVTeW1ib2xpY0xpbmtUb0ZpbGUoKWAgb24gb3RoZXIgcGxhdGZvcm1zLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLnN5bWxpbmtTeW5jKClgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTeW1ib2xpY0xpbmtKdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIC8vIEZvciBkaXJlY3Rvcmllcywgd2UgdXNlIGEgV2luZG93cyBcImp1bmN0aW9uXCIuICBPbiBQT1NJWCBvcGVyYXRpbmcgc3lzdGVtcywgdGhpcyBwcm9kdWNlcyBhIHJlZ3VsYXIgc3ltbGluay5cbiAgICAgICAgZnN4LnN5bWxpbmtTeW5jKG9wdGlvbnMubGlua1RhcmdldFBhdGgsIG9wdGlvbnMubmV3TGlua1BhdGgsICdqdW5jdGlvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3ltYm9saWMgbGluayB0byBhIGZpbGUgKG9uIFdpbmRvd3MgdGhpcyByZXF1aXJlcyBlbGV2YXRlZCBwZXJtaXNzaW9uc0JpdHMpLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLnN5bWxpbmtTeW5jKClgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTeW1ib2xpY0xpbmtGaWxlKG9wdGlvbnMpIHtcbiAgICAgICAgZnN4LnN5bWxpbmtTeW5jKG9wdGlvbnMubGlua1RhcmdldFBhdGgsIG9wdGlvbnMubmV3TGlua1BhdGgsICdmaWxlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzeW1ib2xpYyBsaW5rIHRvIGEgZm9sZGVyIChvbiBXaW5kb3dzIHRoaXMgcmVxdWlyZXMgZWxldmF0ZWQgcGVybWlzc2lvbnNCaXRzKS5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy5zeW1saW5rU3luYygpYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3ltYm9saWNMaW5rRm9sZGVyKG9wdGlvbnMpIHtcbiAgICAgICAgZnN4LnN5bWxpbmtTeW5jKG9wdGlvbnMubGlua1RhcmdldFBhdGgsIG9wdGlvbnMubmV3TGlua1BhdGgsICdkaXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhcmQgbGluay5cbiAgICAgKiBCZWhpbmQgdGhlIHNjZW5lcyBpdCB1c2VzIGBmcy5saW5rU3luYygpYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSGFyZExpbmsob3B0aW9ucykge1xuICAgICAgICBmc3gubGlua1N5bmMob3B0aW9ucy5saW5rVGFyZ2V0UGF0aCwgb3B0aW9ucy5uZXdMaW5rUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvbGxvd3MgYSBsaW5rIHRvIGl0cyBkZXN0aW5hdGlvbiBhbmQgcmV0dXJucyB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgZmluYWwgdGFyZ2V0IG9mIHRoZSBsaW5rLlxuICAgICAqIEJlaGluZCB0aGUgc2NlbmVzIGl0IHVzZXMgYGZzLnJlYWxwYXRoU3luYygpYC5cbiAgICAgKiBAcGFyYW0gbGlua1BhdGggLSBUaGUgcGF0aCB0byB0aGUgbGluay5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVhbFBhdGgobGlua1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZzeC5yZWFscGF0aFN5bmMobGlua1BhdGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZVN5c3RlbSA9IEZpbGVTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlU3lzdGVtLmpzLm1hcCJdfQ==