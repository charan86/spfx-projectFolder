24aa43ced73135585f0d35d9e86625b4
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
class Text {
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input, searchValue, replaceValue) {
        return input.split(searchValue).join(replaceValue);
    }
    /**
     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.
     */
    static convertToCrLf(input) {
        return input.replace(Text._newLineRegEx, '\r\n');
    }
    /**
     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    static convertToLf(input) {
        return input.replace(Text._newLineRegEx, '\n');
    }
    /**
     * Converts all newlines in the provided string to use the specified newline type.
     */
    static convertTo(input, newlineKind) {
        const newline = newlineKind === "os" /* OsDefault */ ? os.EOL : newlineKind;
        return input.replace(Text._newLineRegEx, newline);
    }
    /**
     * Append characters to the end of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padEnd(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.unshift(s);
            return paddingArray.join(paddingCharacter);
        } else {
            return s;
        }
    }
    /**
     * Append characters to the start of a string to ensure the result has a minimum length.
     * @remarks
     * If the string length already exceeds the minimum length, then the string is unchanged.
     * The string is not truncated.
     */
    static padStart(s, minimumLength, paddingCharacter = ' ') {
        if (paddingCharacter.length !== 1) {
            throw new Error('The paddingCharacter parameter must be a single character.');
        }
        if (s.length < minimumLength) {
            const paddingArray = new Array(minimumLength - s.length);
            paddingArray.push(s);
            return paddingArray.join(paddingCharacter);
        } else {
            return s;
        }
    }
    /**
     * If the string is longer than maximumLength characters, truncate it to that length
     * using "..." to indicate the truncation.
     *
     * @remarks
     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.
     */
    static truncateWithEllipsis(s, maximumLength) {
        if (maximumLength < 0) {
            throw new Error('The maximumLength cannot be a negative number');
        }
        if (s.length <= maximumLength) {
            return s;
        }
        if (s.length <= 3) {
            return s.substring(0, maximumLength);
        }
        return s.substring(0, maximumLength - 3) + '...';
    }
    /**
     * Returns the input string with a trailing `\n` character appended, if not already present.
     */
    static ensureTrailingNewline(s, newlineKind = "\n" /* Lf */) {
        // Is there already a newline?
        if (Text._newLineAtEndRegEx.test(s)) {
            return s; // yes, no change
        }
        return s + newlineKind; // no, add it
    }
}
Text._newLineRegEx = /\r\n|\n\r|\r|\n/g;
Text._newLineAtEndRegEx = /(\r\n|\n\r|\r|\n)$/;
exports.Text = Text;
//# sourceMappingURL=Text.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlRleHQuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvcyIsInJlcXVpcmUiLCJUZXh0IiwicmVwbGFjZUFsbCIsImlucHV0Iiwic2VhcmNoVmFsdWUiLCJyZXBsYWNlVmFsdWUiLCJzcGxpdCIsImpvaW4iLCJjb252ZXJ0VG9DckxmIiwicmVwbGFjZSIsIl9uZXdMaW5lUmVnRXgiLCJjb252ZXJ0VG9MZiIsImNvbnZlcnRUbyIsIm5ld2xpbmVLaW5kIiwibmV3bGluZSIsIkVPTCIsInBhZEVuZCIsInMiLCJtaW5pbXVtTGVuZ3RoIiwicGFkZGluZ0NoYXJhY3RlciIsImxlbmd0aCIsIkVycm9yIiwicGFkZGluZ0FycmF5IiwiQXJyYXkiLCJ1bnNoaWZ0IiwicGFkU3RhcnQiLCJwdXNoIiwidHJ1bmNhdGVXaXRoRWxsaXBzaXMiLCJtYXhpbXVtTGVuZ3RoIiwic3Vic3RyaW5nIiwiZW5zdXJlVHJhaWxpbmdOZXdsaW5lIiwiX25ld0xpbmVBdEVuZFJlZ0V4IiwidGVzdCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQSxNQUFNQyxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBOzs7Ozs7Ozs7QUFTQSxNQUFNQyxJQUFOLENBQVc7QUFDUDs7Ozs7OztBQU9BLFdBQU9DLFVBQVAsQ0FBa0JDLEtBQWxCLEVBQXlCQyxXQUF6QixFQUFzQ0MsWUFBdEMsRUFBb0Q7QUFDaEQsZUFBT0YsTUFBTUcsS0FBTixDQUFZRixXQUFaLEVBQXlCRyxJQUF6QixDQUE4QkYsWUFBOUIsQ0FBUDtBQUNIO0FBQ0Q7OztBQUdBLFdBQU9HLGFBQVAsQ0FBcUJMLEtBQXJCLEVBQTRCO0FBQ3hCLGVBQU9BLE1BQU1NLE9BQU4sQ0FBY1IsS0FBS1MsYUFBbkIsRUFBa0MsTUFBbEMsQ0FBUDtB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b3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB3b3JraW5nIHdpdGggc3RyaW5ncyB0aGF0IGNvbnRhaW4gdGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHV0aWxpdGllcyBwcm92aWRlZCBieSB0aGlzIGNsYXNzIGFyZSBpbnRlbmRlZCB0byBiZSBzaW1wbGUsIHNtYWxsLCBhbmQgdmVyeVxuICogYnJvYWRseSBhcHBsaWNhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2FtZSB0aGluZyBhcyB0YXJnZXRTdHJpbmcucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSwgZXhjZXB0IHRoYXRcbiAgICAgKiBhbGwgbWF0Y2hlcyBhcmUgcmVwbGFjZWQsIHJhdGhlciB0aGFuIGp1c3QgdGhlIGZpcnN0IG1hdGNoLlxuICAgICAqIEBwYXJhbSBpbnB1dCAgICAgICAgIC0gVGhlIHN0cmluZyB0byBiZSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSBzZWFyY2hWYWx1ZSAgIC0gVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3JcbiAgICAgKiBAcGFyYW0gcmVwbGFjZVZhbHVlICAtIFRoZSByZXBsYWNlbWVudCB0ZXh0XG4gICAgICovXG4gICAgc3RhdGljIHJlcGxhY2VBbGwoaW5wdXQsIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnNwbGl0KHNlYXJjaFZhbHVlKS5qb2luKHJlcGxhY2VWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBuZXdsaW5lcyBpbiB0aGUgcHJvdmlkZWQgc3RyaW5nIHRvIHVzZSBXaW5kb3dzLXN0eWxlIENSTEYgZW5kIG9mIGxpbmUgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFRvQ3JMZihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShUZXh0Ll9uZXdMaW5lUmVnRXgsICdcXHJcXG4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIG5ld2xpbmVzIGluIHRoZSBwcm92aWRlZCBzdHJpbmcgdG8gdXNlIFBPU0lYLXN0eWxlIExGIGVuZCBvZiBsaW5lIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBQT1NJWCBpcyBhIHJlZ2lzdGVyZWQgdHJhZGVtYXJrIG9mIHRoZSBJbnN0aXR1dGUgb2YgRWxlY3RyaWNhbCBhbmQgRWxlY3Ryb25pYyBFbmdpbmVlcnMsIEluYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFRvTGYoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoVGV4dC5fbmV3TGluZVJlZ0V4LCAnXFxuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBuZXdsaW5lcyBpbiB0aGUgcHJvdmlkZWQgc3RyaW5nIHRvIHVzZSB0aGUgc3BlY2lmaWVkIG5ld2xpbmUgdHlwZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydFRvKGlucHV0LCBuZXdsaW5lS2luZCkge1xuICAgICAgICBjb25zdCBuZXdsaW5lID0gbmV3bGluZUtpbmQgPT09IFwib3NcIiAvKiBPc0RlZmF1bHQgKi8gPyBvcy5FT0wgOiBuZXdsaW5lS2luZDtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoVGV4dC5fbmV3TGluZVJlZ0V4LCBuZXdsaW5lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGNoYXJhY3RlcnMgdG8gdGhlIGVuZCBvZiBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHJlc3VsdCBoYXMgYSBtaW5pbXVtIGxlbmd0aC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZSBzdHJpbmcgbGVuZ3RoIGFscmVhZHkgZXhjZWVkcyB0aGUgbWluaW11bSBsZW5ndGgsIHRoZW4gdGhlIHN0cmluZyBpcyB1bmNoYW5nZWQuXG4gICAgICogVGhlIHN0cmluZyBpcyBub3QgdHJ1bmNhdGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYWRFbmQocywgbWluaW11bUxlbmd0aCwgcGFkZGluZ0NoYXJhY3RlciA9ICcgJykge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXJhY3Rlci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZGRpbmdDaGFyYWN0ZXIgcGFyYW1ldGVyIG11c3QgYmUgYSBzaW5nbGUgY2hhcmFjdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmxlbmd0aCA8IG1pbmltdW1MZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdBcnJheSA9IG5ldyBBcnJheShtaW5pbXVtTGVuZ3RoIC0gcy5sZW5ndGgpO1xuICAgICAgICAgICAgcGFkZGluZ0FycmF5LnVuc2hpZnQocyk7XG4gICAgICAgICAgICByZXR1cm4gcGFkZGluZ0FycmF5LmpvaW4ocGFkZGluZ0NoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgY2hhcmFjdGVycyB0byB0aGUgc3RhcnQgb2YgYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSByZXN1bHQgaGFzIGEgbWluaW11bSBsZW5ndGguXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGUgc3RyaW5nIGxlbmd0aCBhbHJlYWR5IGV4Y2VlZHMgdGhlIG1pbmltdW0gbGVuZ3RoLCB0aGVuIHRoZSBzdHJpbmcgaXMgdW5jaGFuZ2VkLlxuICAgICAqIFRoZSBzdHJpbmcgaXMgbm90IHRydW5jYXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFkU3RhcnQocywgbWluaW11bUxlbmd0aCwgcGFkZGluZ0NoYXJhY3RlciA9ICcgJykge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXJhY3Rlci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZGRpbmdDaGFyYWN0ZXIgcGFyYW1ldGVyIG11c3QgYmUgYSBzaW5nbGUgY2hhcmFjdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmxlbmd0aCA8IG1pbmltdW1MZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdBcnJheSA9IG5ldyBBcnJheShtaW5pbXVtTGVuZ3RoIC0gcy5sZW5ndGgpO1xuICAgICAgICAgICAgcGFkZGluZ0FycmF5LnB1c2gocyk7XG4gICAgICAgICAgICByZXR1cm4gcGFkZGluZ0FycmF5LmpvaW4ocGFkZGluZ0NoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3RyaW5nIGlzIGxvbmdlciB0aGFuIG1heGltdW1MZW5ndGggY2hhcmFjdGVycywgdHJ1bmNhdGUgaXQgdG8gdGhhdCBsZW5ndGhcbiAgICAgKiB1c2luZyBcIi4uLlwiIHRvIGluZGljYXRlIHRoZSB0cnVuY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSB0cnVuY2F0ZVdpdGhFbGxpcHNpcygnMTIzNDU3OCcsIDUpIHdvdWxkIHByb2R1Y2UgJzEyLi4uJy5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJ1bmNhdGVXaXRoRWxsaXBzaXMocywgbWF4aW11bUxlbmd0aCkge1xuICAgICAgICBpZiAobWF4aW11bUxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG1heGltdW1MZW5ndGggY2Fubm90IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMubGVuZ3RoIDw9IG1heGltdW1MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5zdWJzdHJpbmcoMCwgbWF4aW11bUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIG1heGltdW1MZW5ndGggLSAzKSArICcuLi4nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgd2l0aCBhIHRyYWlsaW5nIGBcXG5gIGNoYXJhY3RlciBhcHBlbmRlZCwgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5zdXJlVHJhaWxpbmdOZXdsaW5lKHMsIG5ld2xpbmVLaW5kID0gXCJcXG5cIiAvKiBMZiAqLykge1xuICAgICAgICAvLyBJcyB0aGVyZSBhbHJlYWR5IGEgbmV3bGluZT9cbiAgICAgICAgaWYgKFRleHQuX25ld0xpbmVBdEVuZFJlZ0V4LnRlc3QocykpIHtcbiAgICAgICAgICAgIHJldHVybiBzOyAvLyB5ZXMsIG5vIGNoYW5nZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgbmV3bGluZUtpbmQ7IC8vIG5vLCBhZGQgaXRcbiAgICB9XG59XG5UZXh0Ll9uZXdMaW5lUmVnRXggPSAvXFxyXFxufFxcblxccnxcXHJ8XFxuL2c7XG5UZXh0Ll9uZXdMaW5lQXRFbmRSZWdFeCA9IC8oXFxyXFxufFxcblxccnxcXHJ8XFxuKSQvO1xuZXhwb3J0cy5UZXh0ID0gVGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHQuanMubWFwIl19