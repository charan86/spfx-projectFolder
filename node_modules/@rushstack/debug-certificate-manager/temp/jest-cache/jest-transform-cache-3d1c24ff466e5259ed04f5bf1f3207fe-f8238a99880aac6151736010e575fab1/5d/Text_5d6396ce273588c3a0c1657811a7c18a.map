{"version":3,"sources":["Text.js"],"names":["Object","defineProperty","exports","value","os","require","Text","replaceAll","input","searchValue","replaceValue","split","join","convertToCrLf","replace","_newLineRegEx","convertToLf","convertTo","newlineKind","newline","EOL","padEnd","s","minimumLength","paddingCharacter","length","Error","paddingArray","Array","unshift","padStart","push","truncateWithEllipsis","maximumLength","substring","ensureTrailingNewline","_newLineAtEndRegEx","test"],"mappings":"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","file":"Text.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = require(\"os\");\n/**\n * Operations for working with strings that contain text.\n *\n * @remarks\n * The utilities provided by this class are intended to be simple, small, and very\n * broadly applicable.\n *\n * @public\n */\nclass Text {\n    /**\n     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\n     * all matches are replaced, rather than just the first match.\n     * @param input         - The string to be modified\n     * @param searchValue   - The value to search for\n     * @param replaceValue  - The replacement text\n     */\n    static replaceAll(input, searchValue, replaceValue) {\n        return input.split(searchValue).join(replaceValue);\n    }\n    /**\n     * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.\n     */\n    static convertToCrLf(input) {\n        return input.replace(Text._newLineRegEx, '\\r\\n');\n    }\n    /**\n     * Converts all newlines in the provided string to use POSIX-style LF end of line characters.\n     *\n     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n     */\n    static convertToLf(input) {\n        return input.replace(Text._newLineRegEx, '\\n');\n    }\n    /**\n     * Converts all newlines in the provided string to use the specified newline type.\n     */\n    static convertTo(input, newlineKind) {\n        const newline = newlineKind === \"os\" /* OsDefault */ ? os.EOL : newlineKind;\n        return input.replace(Text._newLineRegEx, newline);\n    }\n    /**\n     * Append characters to the end of a string to ensure the result has a minimum length.\n     * @remarks\n     * If the string length already exceeds the minimum length, then the string is unchanged.\n     * The string is not truncated.\n     */\n    static padEnd(s, minimumLength, paddingCharacter = ' ') {\n        if (paddingCharacter.length !== 1) {\n            throw new Error('The paddingCharacter parameter must be a single character.');\n        }\n        if (s.length < minimumLength) {\n            const paddingArray = new Array(minimumLength - s.length);\n            paddingArray.unshift(s);\n            return paddingArray.join(paddingCharacter);\n        }\n        else {\n            return s;\n        }\n    }\n    /**\n     * Append characters to the start of a string to ensure the result has a minimum length.\n     * @remarks\n     * If the string length already exceeds the minimum length, then the string is unchanged.\n     * The string is not truncated.\n     */\n    static padStart(s, minimumLength, paddingCharacter = ' ') {\n        if (paddingCharacter.length !== 1) {\n            throw new Error('The paddingCharacter parameter must be a single character.');\n        }\n        if (s.length < minimumLength) {\n            const paddingArray = new Array(minimumLength - s.length);\n            paddingArray.push(s);\n            return paddingArray.join(paddingCharacter);\n        }\n        else {\n            return s;\n        }\n    }\n    /**\n     * If the string is longer than maximumLength characters, truncate it to that length\n     * using \"...\" to indicate the truncation.\n     *\n     * @remarks\n     * For example truncateWithEllipsis('1234578', 5) would produce '12...'.\n     */\n    static truncateWithEllipsis(s, maximumLength) {\n        if (maximumLength < 0) {\n            throw new Error('The maximumLength cannot be a negative number');\n        }\n        if (s.length <= maximumLength) {\n            return s;\n        }\n        if (s.length <= 3) {\n            return s.substring(0, maximumLength);\n        }\n        return s.substring(0, maximumLength - 3) + '...';\n    }\n    /**\n     * Returns the input string with a trailing `\\n` character appended, if not already present.\n     */\n    static ensureTrailingNewline(s, newlineKind = \"\\n\" /* Lf */) {\n        // Is there already a newline?\n        if (Text._newLineAtEndRegEx.test(s)) {\n            return s; // yes, no change\n        }\n        return s + newlineKind; // no, add it\n    }\n}\nText._newLineRegEx = /\\r\\n|\\n\\r|\\r|\\n/g;\nText._newLineAtEndRegEx = /(\\r\\n|\\n\\r|\\r|\\n)$/;\nexports.Text = Text;\n//# sourceMappingURL=Text.js.map"]}