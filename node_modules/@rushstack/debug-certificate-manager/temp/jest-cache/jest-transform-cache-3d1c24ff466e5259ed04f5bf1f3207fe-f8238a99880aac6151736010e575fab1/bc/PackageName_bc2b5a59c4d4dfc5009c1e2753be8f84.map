{"version":3,"sources":["PackageName.js"],"names":["Object","defineProperty","exports","value","PackageName","tryParse","packageName","result","scope","unscopedName","error","input","undefined","length","indexOfScopeSlash","indexOf","substr","nameWithoutScopeSymbols","slice","toLowerCase","match","_invalidNameCharactersRegExp","parse","Error","getScope","getUnscopedName","isValidName","validate","combineParts"],"mappings":"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","file":"PackageName.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Various functions for working with package names that may include scopes.\n *\n * @public\n */\nclass PackageName {\n    /**\n     * This attempts to parse a package name that may include a scope component.\n     * The packageName must not be an empty string.\n     * @remarks\n     * This function will not throw an exception.\n     *\n     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be\n     * nonempty if the string could not be parsed.\n     */\n    static tryParse(packageName) {\n        const result = {\n            scope: '',\n            unscopedName: '',\n            error: ''\n        };\n        let input = packageName;\n        if (input === null || input === undefined) {\n            result.error = 'The package name must not be null or undefined';\n            return result;\n        }\n        // Rule from npmjs.com:\n        // \"The name must be less than or equal to 214 characters. This includes the scope for scoped packages.\"\n        if (packageName.length > 214) {\n            // Don't attempt to parse a ridiculously long input\n            result.error = 'The package name cannot be longer than 214 characters';\n            return result;\n        }\n        if (input[0] === '@') {\n            const indexOfScopeSlash = input.indexOf('/');\n            if (indexOfScopeSlash <= 0) {\n                result.scope = input;\n                result.error = `Error parsing \"${packageName}\": The scope must be followed by a slash`;\n                return result;\n            }\n            // Extract the scope substring\n            result.scope = input.substr(0, indexOfScopeSlash);\n            input = input.substr(indexOfScopeSlash + 1);\n        }\n        result.unscopedName = input;\n        if (result.scope === '@') {\n            result.error = `Error parsing \"${packageName}\": The scope name cannot be empty`;\n            return result;\n        }\n        if (result.unscopedName === '') {\n            result.error = 'The package name must not be empty';\n            return result;\n        }\n        // Rule from npmjs.com:\n        // \"The name can't start with a dot or an underscore.\"\n        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {\n            result.error = `The package name \"${packageName}\" starts with an invalid character`;\n            return result;\n        }\n        // Convert \"@scope/unscoped-name\" --> \"scopeunscoped-name\"\n        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '')\n            + result.unscopedName;\n        // \"New packages must not have uppercase letters in the name.\"\n        // This can't be enforced because \"old\" packages are still actively maintained.\n        // Example: https://www.npmjs.com/package/Base64\n        // However it's pretty reasonable to require the scope to be lower case\n        if (result.scope !== result.scope.toLowerCase()) {\n            result.error = `The package scope \"${result.scope}\" must not contain upper case characters`;\n            return result;\n        }\n        // \"The name ends up being part of a URL, an argument on the command line, and a folder name.\n        // Therefore, the name can't contain any non-URL-safe characters\"\n        const match = nameWithoutScopeSymbols.match(PackageName._invalidNameCharactersRegExp);\n        if (match) {\n            result.error = `The package name \"${packageName}\" contains an invalid character: \"${match[0]}\"`;\n            return result;\n        }\n        return result;\n    }\n    /**\n     * Same as {@link PackageName.tryParse}, except this throws an exception if the input\n     * cannot be parsed.\n     * @remarks\n     * The packageName must not be an empty string.\n     */\n    static parse(packageName) {\n        const result = PackageName.tryParse(packageName);\n        if (result.error) {\n            throw new Error(result.error);\n        }\n        return result;\n    }\n    /**\n     * {@inheritDoc IParsedPackageName.scope}\n     */\n    static getScope(packageName) {\n        return PackageName.parse(packageName).scope;\n    }\n    /**\n     * {@inheritDoc IParsedPackageName.unscopedName}\n     */\n    static getUnscopedName(packageName) {\n        return PackageName.parse(packageName).unscopedName;\n    }\n    /**\n     * Returns true if the specified package name is valid, or false otherwise.\n     * @remarks\n     * This function will not throw an exception.\n     */\n    static isValidName(packageName) {\n        const result = PackageName.tryParse(packageName);\n        return !result.error;\n    }\n    /**\n     * Throws an exception if the specified name is not a valid package name.\n     * The packageName must not be an empty string.\n     */\n    static validate(packageName) {\n        PackageName.parse(packageName);\n    }\n    /**\n     * Combines an optional package scope with an unscoped root name.\n     * @param scope - Must be either an empty string, or a scope name such as \"\\@example\"\n     * @param unscopedName - Must be a nonempty package name that does not contain a scope\n     * @returns A full package name such as \"\\@example/some-library\".\n     */\n    static combineParts(scope, unscopedName) {\n        if (scope !== '') {\n            if (scope[0] !== '@') {\n                throw new Error('The scope must start with an \"@\" character');\n            }\n        }\n        if (scope.indexOf('/') >= 0) {\n            throw new Error('The scope must not contain a \"/\" character');\n        }\n        if (unscopedName[0] === '@') {\n            throw new Error('The unscopedName cannot start with an \"@\" character');\n        }\n        if (unscopedName.indexOf('/') >= 0) {\n            throw new Error('The unscopedName must not contain a \"/\" character');\n        }\n        let result;\n        if (scope === '') {\n            result = unscopedName;\n        }\n        else {\n            result = scope + '/' + unscopedName;\n        }\n        // Make sure the result is a valid package name\n        PackageName.validate(result);\n        return result;\n    }\n}\n// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )\n// However, these are disallowed because they are shell characters:       ! ~ * ' ( )\nPackageName._invalidNameCharactersRegExp = /[^A-Za-z0-9\\-_\\.]/;\nexports.PackageName = PackageName;\n//# sourceMappingURL=PackageName.js.map"]}