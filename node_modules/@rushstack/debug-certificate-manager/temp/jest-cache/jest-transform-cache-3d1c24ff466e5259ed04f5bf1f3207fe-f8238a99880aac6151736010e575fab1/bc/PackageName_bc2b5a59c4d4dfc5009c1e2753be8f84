e44393b73d601b1c8429f0390d3ce6de
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Various functions for working with package names that may include scopes.
 *
 * @public
 */
class PackageName {
    /**
     * This attempts to parse a package name that may include a scope component.
     * The packageName must not be an empty string.
     * @remarks
     * This function will not throw an exception.
     *
     * @returns an {@link IParsedPackageNameOrError} structure whose `error` property will be
     * nonempty if the string could not be parsed.
     */
    static tryParse(packageName) {
        const result = {
            scope: '',
            unscopedName: '',
            error: ''
        };
        let input = packageName;
        if (input === null || input === undefined) {
            result.error = 'The package name must not be null or undefined';
            return result;
        }
        // Rule from npmjs.com:
        // "The name must be less than or equal to 214 characters. This includes the scope for scoped packages."
        if (packageName.length > 214) {
            // Don't attempt to parse a ridiculously long input
            result.error = 'The package name cannot be longer than 214 characters';
            return result;
        }
        if (input[0] === '@') {
            const indexOfScopeSlash = input.indexOf('/');
            if (indexOfScopeSlash <= 0) {
                result.scope = input;
                result.error = `Error parsing "${packageName}": The scope must be followed by a slash`;
                return result;
            }
            // Extract the scope substring
            result.scope = input.substr(0, indexOfScopeSlash);
            input = input.substr(indexOfScopeSlash + 1);
        }
        result.unscopedName = input;
        if (result.scope === '@') {
            result.error = `Error parsing "${packageName}": The scope name cannot be empty`;
            return result;
        }
        if (result.unscopedName === '') {
            result.error = 'The package name must not be empty';
            return result;
        }
        // Rule from npmjs.com:
        // "The name can't start with a dot or an underscore."
        if (result.unscopedName[0] === '.' || result.unscopedName[0] === '_') {
            result.error = `The package name "${packageName}" starts with an invalid character`;
            return result;
        }
        // Convert "@scope/unscoped-name" --> "scopeunscoped-name"
        const nameWithoutScopeSymbols = (result.scope ? result.scope.slice(1, -1) : '') + result.unscopedName;
        // "New packages must not have uppercase letters in the name."
        // This can't be enforced because "old" packages are still actively maintained.
        // Example: https://www.npmjs.com/package/Base64
        // However it's pretty reasonable to require the scope to be lower case
        if (result.scope !== result.scope.toLowerCase()) {
            result.error = `The package scope "${result.scope}" must not contain upper case characters`;
            return result;
        }
        // "The name ends up being part of a URL, an argument on the command line, and a folder name.
        // Therefore, the name can't contain any non-URL-safe characters"
        const match = nameWithoutScopeSymbols.match(PackageName._invalidNameCharactersRegExp);
        if (match) {
            result.error = `The package name "${packageName}" contains an invalid character: "${match[0]}"`;
            return result;
        }
        return result;
    }
    /**
     * Same as {@link PackageName.tryParse}, except this throws an exception if the input
     * cannot be parsed.
     * @remarks
     * The packageName must not be an empty string.
     */
    static parse(packageName) {
        const result = PackageName.tryParse(packageName);
        if (result.error) {
            throw new Error(result.error);
        }
        return result;
    }
    /**
     * {@inheritDoc IParsedPackageName.scope}
     */
    static getScope(packageName) {
        return PackageName.parse(packageName).scope;
    }
    /**
     * {@inheritDoc IParsedPackageName.unscopedName}
     */
    static getUnscopedName(packageName) {
        return PackageName.parse(packageName).unscopedName;
    }
    /**
     * Returns true if the specified package name is valid, or false otherwise.
     * @remarks
     * This function will not throw an exception.
     */
    static isValidName(packageName) {
        const result = PackageName.tryParse(packageName);
        return !result.error;
    }
    /**
     * Throws an exception if the specified name is not a valid package name.
     * The packageName must not be an empty string.
     */
    static validate(packageName) {
        PackageName.parse(packageName);
    }
    /**
     * Combines an optional package scope with an unscoped root name.
     * @param scope - Must be either an empty string, or a scope name such as "\@example"
     * @param unscopedName - Must be a nonempty package name that does not contain a scope
     * @returns A full package name such as "\@example/some-library".
     */
    static combineParts(scope, unscopedName) {
        if (scope !== '') {
            if (scope[0] !== '@') {
                throw new Error('The scope must start with an "@" character');
            }
        }
        if (scope.indexOf('/') >= 0) {
            throw new Error('The scope must not contain a "/" character');
        }
        if (unscopedName[0] === '@') {
            throw new Error('The unscopedName cannot start with an "@" character');
        }
        if (unscopedName.indexOf('/') >= 0) {
            throw new Error('The unscopedName must not contain a "/" character');
        }
        let result;
        if (scope === '') {
            result = unscopedName;
        } else {
            result = scope + '/' + unscopedName;
        }
        // Make sure the result is a valid package name
        PackageName.validate(result);
        return result;
    }
}
// encodeURIComponent() escapes all characters except:  A-Z a-z 0-9 - _ . ! ~ * ' ( )
// However, these are disallowed because they are shell characters:       ! ~ * ' ( )
PackageName._invalidNameCharactersRegExp = /[^A-Za-z0-9\-_\.]/;
exports.PackageName = PackageName;
//# sourceMappingURL=PackageName.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlBhY2thZ2VOYW1lLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGFja2FnZU5hbWUiLCJ0cnlQYXJzZSIsInBhY2thZ2VOYW1lIiwicmVzdWx0Iiwic2NvcGUiLCJ1bnNjb3BlZE5hbWUiLCJlcnJvciIsImlucHV0IiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiaW5kZXhPZlNjb3BlU2xhc2giLCJpbmRleE9mIiwic3Vic3RyIiwibmFtZVdpdGhvdXRTY29wZVN5bWJvbHMiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJfaW52YWxpZE5hbWVDaGFyYWN0ZXJzUmVnRXhwIiwicGFyc2UiLCJFcnJvciIsImdldFNjb3BlIiwiZ2V0VW5zY29wZWROYW1lIiwiaXNWYWxpZE5hbWUiLCJ2YWxpZGF0ZSIsImNvbWJpbmVQYXJ0cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQTs7Ozs7QUFLQSxNQUFNQyxXQUFOLENBQWtCO0FBQ2Q7Ozs7Ozs7OztBQVNBLFdBQU9DLFFBQVAsQ0FBZ0JDLFdBQWhCLEVBQTZCO0FBQ3pCLGNBQU1DLFNBQVM7QUFDWEMsbUJBQU8sRUFESTtBQUVYQywwQkFBYyxFQUZIO0FBR1hDLG1CQUFPO0FBSEksU0FBZjtBQUtBLFlBQUlDLFFBQVFMLFdBQVo7QUFDQSxZQUFJSyxVQUFVLElBQVYsSUFBa0JBLFVBQVVDLFNBQWhDLEVBQTJDO0FBQ3ZDTCxtQkFBT0csS0FBUCxHQUFlLGdEQUFmO0FBQ0EsbUJBQU9ILE1BQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQSxZQUFJRCxZQUFZTyxNQUFaLEdBQXFCLEdBQXpCLEVBQThCO0FBQzFCO0FBQ0FOLG1CQUFPRyxLQUFQLEdBQWUsdURBQWY7QUFDQSxtQkFBT0gsTUFBUDtBQUNIO0FBQ0QsWUFB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QixXQUFsQjtBQUNIO0FBQ0Q7Ozs7OztBQU1BLFdBQU9zQixZQUFQLENBQW9CcEIsS0FBcEIsRUFBMkJDLFlBQTNCLEVBQXlDO0FBQ3JDLFlBQUlELFVBQVUsRUFBZCxFQUFrQjtBQUNkLGdCQUFJQSxNQUFNLENBQU4sTUFBYSxHQUFqQixFQUFzQjtBQUNsQixzQkFBTSxJQUFJZSxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNIO0FBQ0o7QUFDRCxZQUFJZixNQUFNTyxPQUFOLENBQWMsR0FBZCxLQUFzQixDQUExQixFQUE2QjtBQUN6QixrQkFBTSxJQUFJUSxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNIO0FBQ0QsWUFBSWQsYUFBYSxDQUFiLE1BQW9CLEdBQXhCLEVBQTZCO0FBQ3pCLGtCQUFNLElBQUljLEtBQUosQ0FBVSxxREFBVixDQUFOO0FBQ0g7QUFDRCxZQUFJZCxhQUFhTSxPQUFiLENBQXFCLEdBQXJCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2hDLGtCQUFNLElBQUlRLEtBQUosQ0FBVSxtREFBVixDQUFOO0FBQ0g7QUFDRCxZQUFJaEIsTUFBSjtBQUNBLFlBQUlDLFVBQVUsRUFBZCxFQUFrQjtBQUNkRCxxQkFBU0UsWUFBVDtBQUNILFNBRkQsTUFHSztBQUNERixxQkFBU0MsUUFBUSxHQUFSLEdBQWNDLFlBQXZCO0FBQ0g7QUFDRDtBQUNBTCxvQkFBWXVCLFFBQVosQ0FBcUJwQixNQUFyQjtBQUNBLGVBQU9BLE1BQVA7QUFDSDtBQWxKYTtBQW9KbEI7QUFDQTtBQUNBSCxZQUFZaUIsNEJBQVosR0FBMkMsbUJBQTNDO0FBQ0FuQixRQUFRRSxXQUFSLEdBQXNCQSxXQUF0QjtBQUNBIiwiZmlsZSI6IlBhY2thZ2VOYW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVmFyaW91cyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBwYWNrYWdlIG5hbWVzIHRoYXQgbWF5IGluY2x1ZGUgc2NvcGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGFja2FnZU5hbWUge1xuICAgIC8qKlxuICAgICAqIFRoaXMgYXR0ZW1wdHMgdG8gcGFyc2UgYSBwYWNrYWdlIG5hbWUgdGhhdCBtYXkgaW5jbHVkZSBhIHNjb3BlIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgcGFja2FnZU5hbWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiB7QGxpbmsgSVBhcnNlZFBhY2thZ2VOYW1lT3JFcnJvcn0gc3RydWN0dXJlIHdob3NlIGBlcnJvcmAgcHJvcGVydHkgd2lsbCBiZVxuICAgICAqIG5vbmVtcHR5IGlmIHRoZSBzdHJpbmcgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJ5UGFyc2UocGFja2FnZU5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc2NvcGU6ICcnLFxuICAgICAgICAgICAgdW5zY29wZWROYW1lOiAnJyxcbiAgICAgICAgICAgIGVycm9yOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaW5wdXQgPSBwYWNrYWdlTmFtZTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdUaGUgcGFja2FnZSBuYW1lIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVsZSBmcm9tIG5wbWpzLmNvbTpcbiAgICAgICAgLy8gXCJUaGUgbmFtZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyMTQgY2hhcmFjdGVycy4gVGhpcyBpbmNsdWRlcyB0aGUgc2NvcGUgZm9yIHNjb3BlZCBwYWNrYWdlcy5cIlxuICAgICAgICBpZiAocGFja2FnZU5hbWUubGVuZ3RoID4gMjE0KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIHBhcnNlIGEgcmlkaWN1bG91c2x5IGxvbmcgaW5wdXRcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdUaGUgcGFja2FnZSBuYW1lIGNhbm5vdCBiZSBsb25nZXIgdGhhbiAyMTQgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE9mU2NvcGVTbGFzaCA9IGlucHV0LmluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChpbmRleE9mU2NvcGVTbGFzaCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNjb3BlID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYEVycm9yIHBhcnNpbmcgXCIke3BhY2thZ2VOYW1lfVwiOiBUaGUgc2NvcGUgbXVzdCBiZSBmb2xsb3dlZCBieSBhIHNsYXNoYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgc2NvcGUgc3Vic3RyaW5nXG4gICAgICAgICAgICByZXN1bHQuc2NvcGUgPSBpbnB1dC5zdWJzdHIoMCwgaW5kZXhPZlNjb3BlU2xhc2gpO1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoaW5kZXhPZlNjb3BlU2xhc2ggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zY29wZWROYW1lID0gaW5wdXQ7XG4gICAgICAgIGlmIChyZXN1bHQuc2NvcGUgPT09ICdAJykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYEVycm9yIHBhcnNpbmcgXCIke3BhY2thZ2VOYW1lfVwiOiBUaGUgc2NvcGUgbmFtZSBjYW5ub3QgYmUgZW1wdHlgO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnVuc2NvcGVkTmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9ICdUaGUgcGFja2FnZSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5JztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVsZSBmcm9tIG5wbWpzLmNvbTpcbiAgICAgICAgLy8gXCJUaGUgbmFtZSBjYW4ndCBzdGFydCB3aXRoIGEgZG90IG9yIGFuIHVuZGVyc2NvcmUuXCJcbiAgICAgICAgaWYgKHJlc3VsdC51bnNjb3BlZE5hbWVbMF0gPT09ICcuJyB8fCByZXN1bHQudW5zY29wZWROYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGBUaGUgcGFja2FnZSBuYW1lIFwiJHtwYWNrYWdlTmFtZX1cIiBzdGFydHMgd2l0aCBhbiBpbnZhbGlkIGNoYXJhY3RlcmA7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgXCJAc2NvcGUvdW5zY29wZWQtbmFtZVwiIC0tPiBcInNjb3BldW5zY29wZWQtbmFtZVwiXG4gICAgICAgIGNvbnN0IG5hbWVXaXRob3V0U2NvcGVTeW1ib2xzID0gKHJlc3VsdC5zY29wZSA/IHJlc3VsdC5zY29wZS5zbGljZSgxLCAtMSkgOiAnJylcbiAgICAgICAgICAgICsgcmVzdWx0LnVuc2NvcGVkTmFtZTtcbiAgICAgICAgLy8gXCJOZXcgcGFja2FnZXMgbXVzdCBub3QgaGF2ZSB1cHBlcmNhc2UgbGV0dGVycyBpbiB0aGUgbmFtZS5cIlxuICAgICAgICAvLyBUaGlzIGNhbid0IGJlIGVuZm9yY2VkIGJlY2F1c2UgXCJvbGRcIiBwYWNrYWdlcyBhcmUgc3RpbGwgYWN0aXZlbHkgbWFpbnRhaW5lZC5cbiAgICAgICAgLy8gRXhhbXBsZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQmFzZTY0XG4gICAgICAgIC8vIEhvd2V2ZXIgaXQncyBwcmV0dHkgcmVhc29uYWJsZSB0byByZXF1aXJlIHRoZSBzY29wZSB0byBiZSBsb3dlciBjYXNlXG4gICAgICAgIGlmIChyZXN1bHQuc2NvcGUgIT09IHJlc3VsdC5zY29wZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBgVGhlIHBhY2thZ2Ugc2NvcGUgXCIke3Jlc3VsdC5zY29wZX1cIiBtdXN0IG5vdCBjb250YWluIHVwcGVyIGNhc2UgY2hhcmFjdGVyc2A7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiVGhlIG5hbWUgZW5kcyB1cCBiZWluZyBwYXJ0IG9mIGEgVVJMLCBhbiBhcmd1bWVudCBvbiB0aGUgY29tbWFuZCBsaW5lLCBhbmQgYSBmb2xkZXIgbmFtZS5cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgbmFtZSBjYW4ndCBjb250YWluIGFueSBub24tVVJMLXNhZmUgY2hhcmFjdGVyc1wiXG4gICAgICAgIGNvbnN0IG1hdGNoID0gbmFtZVdpdGhvdXRTY29wZVN5bWJvbHMubWF0Y2goUGFja2FnZU5hbWUuX2ludmFsaWROYW1lQ2hhcmFjdGVyc1JlZ0V4cCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gYFRoZSBwYWNrYWdlIG5hbWUgXCIke3BhY2thZ2VOYW1lfVwiIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyOiBcIiR7bWF0Y2hbMF19XCJgO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHtAbGluayBQYWNrYWdlTmFtZS50cnlQYXJzZX0sIGV4Y2VwdCB0aGlzIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGlucHV0XG4gICAgICogY2Fubm90IGJlIHBhcnNlZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBwYWNrYWdlTmFtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFBhY2thZ2VOYW1lLnRyeVBhcnNlKHBhY2thZ2VOYW1lKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0Bpbmhlcml0RG9jIElQYXJzZWRQYWNrYWdlTmFtZS5zY29wZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2NvcGUocGFja2FnZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFBhY2thZ2VOYW1lLnBhcnNlKHBhY2thZ2VOYW1lKS5zY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0Bpbmhlcml0RG9jIElQYXJzZWRQYWNrYWdlTmFtZS51bnNjb3BlZE5hbWV9XG4gICAgICovXG4gICAgc3RhdGljIGdldFVuc2NvcGVkTmFtZShwYWNrYWdlTmFtZSkge1xuICAgICAgICByZXR1cm4gUGFja2FnZU5hbWUucGFyc2UocGFja2FnZU5hbWUpLnVuc2NvcGVkTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcGFja2FnZSBuYW1lIGlzIHZhbGlkLCBvciBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE5hbWUocGFja2FnZU5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUGFja2FnZU5hbWUudHJ5UGFyc2UocGFja2FnZU5hbWUpO1xuICAgICAgICByZXR1cm4gIXJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lLlxuICAgICAqIFRoZSBwYWNrYWdlTmFtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlKHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIFBhY2thZ2VOYW1lLnBhcnNlKHBhY2thZ2VOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgYW4gb3B0aW9uYWwgcGFja2FnZSBzY29wZSB3aXRoIGFuIHVuc2NvcGVkIHJvb3QgbmFtZS5cbiAgICAgKiBAcGFyYW0gc2NvcGUgLSBNdXN0IGJlIGVpdGhlciBhbiBlbXB0eSBzdHJpbmcsIG9yIGEgc2NvcGUgbmFtZSBzdWNoIGFzIFwiXFxAZXhhbXBsZVwiXG4gICAgICogQHBhcmFtIHVuc2NvcGVkTmFtZSAtIE11c3QgYmUgYSBub25lbXB0eSBwYWNrYWdlIG5hbWUgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgc2NvcGVcbiAgICAgKiBAcmV0dXJucyBBIGZ1bGwgcGFja2FnZSBuYW1lIHN1Y2ggYXMgXCJcXEBleGFtcGxlL3NvbWUtbGlicmFyeVwiLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21iaW5lUGFydHMoc2NvcGUsIHVuc2NvcGVkTmFtZSkge1xuICAgICAgICBpZiAoc2NvcGUgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVbMF0gIT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNjb3BlIG11c3Qgc3RhcnQgd2l0aCBhbiBcIkBcIiBjaGFyYWN0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNjb3BlIG11c3Qgbm90IGNvbnRhaW4gYSBcIi9cIiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zY29wZWROYW1lWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHVuc2NvcGVkTmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCBhbiBcIkBcIiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zY29wZWROYW1lLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB1bnNjb3BlZE5hbWUgbXVzdCBub3QgY29udGFpbiBhIFwiL1wiIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChzY29wZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuc2NvcGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNjb3BlICsgJy8nICsgdW5zY29wZWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgcGFja2FnZSBuYW1lXG4gICAgICAgIFBhY2thZ2VOYW1lLnZhbGlkYXRlKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gZW5jb2RlVVJJQ29tcG9uZW50KCkgZXNjYXBlcyBhbGwgY2hhcmFjdGVycyBleGNlcHQ6ICBBLVogYS16IDAtOSAtIF8gLiAhIH4gKiAnICggKVxuLy8gSG93ZXZlciwgdGhlc2UgYXJlIGRpc2FsbG93ZWQgYmVjYXVzZSB0aGV5IGFyZSBzaGVsbCBjaGFyYWN0ZXJzOiAgICAgICAhIH4gKiAnICggKVxuUGFja2FnZU5hbWUuX2ludmFsaWROYW1lQ2hhcmFjdGVyc1JlZ0V4cCA9IC9bXkEtWmEtejAtOVxcLV9cXC5dLztcbmV4cG9ydHMuUGFja2FnZU5hbWUgPSBQYWNrYWdlTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhY2thZ2VOYW1lLmpzLm1hcCJdfQ==