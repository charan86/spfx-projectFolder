{"version":3,"sources":["JsonSchema.js"],"names":["Object","defineProperty","exports","value","os","require","path","Validator","JsonFile_1","FileSystem_1","JsonSchema","constructor","_dependentSchemas","_filename","_validator","undefined","_schemaObject","fromFile","filename","options","FileSystem","exists","Error","schema","dependentSchemas","fromLoadedObject","schemaObject","_collectDependentSchemas","collectedSchemas","seenObjects","seenIds","dependentSchema","has","add","schemaId","_ensureLoaded","shortName","push","_formatErrorDetails","errorDetails","_formatErrorDetailsHelper","indent","buffer","errorDetail","EOL","description","MAX_LENGTH","truncatedDescription","trim","length","substr","message","inner","schemaWithId","id","basename","ensureCompiled","newValidator","breakOnFirstError","noTypeless","noExtraKeywords","anythingSchema","setRemoteReference","Set","collectedSchema","validateSchema","getLastErrors","validateObject","jsonObject","filenameForErrors","validateObjectWithCallback","errorInfo","prefix","customErrorHeader","details","errorCallback","validate","args","JsonFile","load"],"mappings":"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","file":"JsonSchema.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst Validator = require(\"z-schema\");\nconst JsonFile_1 = require(\"./JsonFile\");\nconst FileSystem_1 = require(\"./FileSystem\");\n/**\n * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.\n * @remarks\n * The schema itself is normally loaded and compiled later, only if it is actually required to validate\n * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls\n * JsonSchema.ensureCompiled() for each of your schema objects.\n *\n * @public\n */\nclass JsonSchema {\n    constructor() {\n        this._dependentSchemas = [];\n        this._filename = '';\n        this._validator = undefined;\n        this._schemaObject = undefined;\n    }\n    /**\n     * Registers a JsonSchema that will be loaded from a file on disk.\n     * @remarks\n     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\n     * until it the schema is actually used.\n     */\n    static fromFile(filename, options) {\n        // This is a quick and inexpensive test to avoid the catch the most common errors early.\n        // Full validation will happen later in JsonSchema.compile().\n        if (!FileSystem_1.FileSystem.exists(filename)) {\n            throw new Error('Schema file not found: ' + filename);\n        }\n        const schema = new JsonSchema();\n        schema._filename = filename;\n        if (options) {\n            schema._dependentSchemas = options.dependentSchemas || [];\n        }\n        return schema;\n    }\n    /**\n     * Registers a JsonSchema that will be loaded from a file on disk.\n     * @remarks\n     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated\n     * until it the schema is actually used.\n     */\n    static fromLoadedObject(schemaObject) {\n        const schema = new JsonSchema();\n        schema._schemaObject = schemaObject;\n        return schema;\n    }\n    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {\n        for (const dependentSchema of dependentSchemas) {\n            // It's okay for the same schema to appear multiple times in the tree, but we only process it once\n            if (seenObjects.has(dependentSchema)) {\n                continue;\n            }\n            seenObjects.add(dependentSchema);\n            const schemaId = dependentSchema._ensureLoaded();\n            if (schemaId === '') {\n                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced`\n                    + ' because is missing the \"id\" field');\n            }\n            if (seenIds.has(schemaId)) {\n                throw new Error(`This schema ${dependentSchema.shortName} has the same \"id\" as`\n                    + ' another schema in this set');\n            }\n            seenIds.add(schemaId);\n            collectedSchemas.push(dependentSchema);\n            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);\n        }\n    }\n    /**\n     * Used to nicely format the ZSchema error tree.\n     */\n    static _formatErrorDetails(errorDetails) {\n        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');\n    }\n    /**\n     * Used by _formatErrorDetails.\n     */\n    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {\n        for (const errorDetail of errorDetails) {\n            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;\n            if (errorDetail.description) {\n                const MAX_LENGTH = 40;\n                let truncatedDescription = errorDetail.description.trim();\n                if (truncatedDescription.length > MAX_LENGTH) {\n                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3)\n                        + '...';\n                }\n                buffer += ` (${truncatedDescription})`;\n            }\n            buffer += os.EOL + indent + `       ${errorDetail.message}`;\n            if (errorDetail.inner) {\n                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);\n            }\n        }\n        return buffer;\n    }\n    /**\n     * Returns a short name for this schema, for use in error messages.\n     * @remarks\n     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the \"id\"\n     * field is used if available.\n     */\n    get shortName() {\n        if (!this._filename) {\n            if (this._schemaObject) {\n                const schemaWithId = this._schemaObject;\n                if (schemaWithId.id) {\n                    return schemaWithId.id;\n                }\n            }\n            return '(anonymous schema)';\n        }\n        else {\n            return path.basename(this._filename);\n        }\n    }\n    /**\n     * If not already done, this loads the schema from disk and compiles it.\n     * @remarks\n     * Any dependencies will be compiled as well.\n     */\n    ensureCompiled() {\n        this._ensureLoaded();\n        if (!this._validator) {\n            // Don't assign this to _validator until we're sure everything was successful\n            const newValidator = new Validator({\n                breakOnFirstError: false,\n                noTypeless: true,\n                noExtraKeywords: true\n            });\n            const anythingSchema = {\n                'type': [\n                    'array',\n                    'boolean',\n                    'integer',\n                    'number',\n                    'object',\n                    'string'\n                ]\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);\n            const collectedSchemas = [];\n            const seenObjects = new Set();\n            const seenIds = new Set();\n            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);\n            // Validate each schema in order.  We specifically do not supply them all together, because we want\n            // to make sure that circular references will fail to validate.\n            for (const collectedSchema of collectedSchemas) {\n                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {\n                    throw new Error(`Failed to validate schema \"${collectedSchema.shortName}\":` + os.EOL\n                        + JsonSchema._formatErrorDetails(newValidator.getLastErrors()));\n                }\n            }\n            this._validator = newValidator;\n        }\n    }\n    /**\n     * Validates the specified JSON object against this JSON schema.  If the validation fails,\n     * an exception will be thrown.\n     * @param jsonObject - The JSON data to be validated\n     * @param filenameForErrors - The filename that the JSON data was available, or an empty string\n     *    if not applicable\n     * @param options - Other options that control the validation\n     */\n    validateObject(jsonObject, filenameForErrors, options) {\n        this.validateObjectWithCallback(jsonObject, (errorInfo) => {\n            const prefix = (options && options.customErrorHeader) ? options.customErrorHeader\n                : 'JSON validation failed:';\n            throw new Error(prefix + os.EOL +\n                filenameForErrors + os.EOL + errorInfo.details);\n        });\n    }\n    /**\n     * Validates the specified JSON object against this JSON schema.  If the validation fails,\n     * a callback is called for each validation error.\n     */\n    validateObjectWithCallback(jsonObject, errorCallback) {\n        this.ensureCompiled();\n        if (!this._validator.validate(jsonObject, this._schemaObject)) {\n            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());\n            const args = {\n                details: errorDetails\n            };\n            errorCallback(args);\n        }\n    }\n    _ensureLoaded() {\n        if (!this._schemaObject) {\n            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);\n        }\n        return this._schemaObject.id || '';\n    }\n}\nexports.JsonSchema = JsonSchema;\n//# sourceMappingURL=JsonSchema.js.map"]}