0ce0caa1500304ffe5a281a1bfd18e56
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const Validator = require("z-schema");
const JsonFile_1 = require("./JsonFile");
const FileSystem_1 = require("./FileSystem");
/**
 * Represents a JSON schema that can be used to validate JSON data files loaded by the JsonFile class.
 * @remarks
 * The schema itself is normally loaded and compiled later, only if it is actually required to validate
 * an input.  To avoid schema errors at runtime, it's recommended to create a unit test that calls
 * JsonSchema.ensureCompiled() for each of your schema objects.
 *
 * @public
 */
class JsonSchema {
    constructor() {
        this._dependentSchemas = [];
        this._filename = '';
        this._validator = undefined;
        this._schemaObject = undefined;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromFile(filename, options) {
        // This is a quick and inexpensive test to avoid the catch the most common errors early.
        // Full validation will happen later in JsonSchema.compile().
        if (!FileSystem_1.FileSystem.exists(filename)) {
            throw new Error('Schema file not found: ' + filename);
        }
        const schema = new JsonSchema();
        schema._filename = filename;
        if (options) {
            schema._dependentSchemas = options.dependentSchemas || [];
        }
        return schema;
    }
    /**
     * Registers a JsonSchema that will be loaded from a file on disk.
     * @remarks
     * NOTE: An error occurs if the file does not exist; however, the file itself is not loaded or validated
     * until it the schema is actually used.
     */
    static fromLoadedObject(schemaObject) {
        const schema = new JsonSchema();
        schema._schemaObject = schemaObject;
        return schema;
    }
    static _collectDependentSchemas(collectedSchemas, dependentSchemas, seenObjects, seenIds) {
        for (const dependentSchema of dependentSchemas) {
            // It's okay for the same schema to appear multiple times in the tree, but we only process it once
            if (seenObjects.has(dependentSchema)) {
                continue;
            }
            seenObjects.add(dependentSchema);
            const schemaId = dependentSchema._ensureLoaded();
            if (schemaId === '') {
                throw new Error(`This schema ${dependentSchema.shortName} cannot be referenced` + ' because is missing the "id" field');
            }
            if (seenIds.has(schemaId)) {
                throw new Error(`This schema ${dependentSchema.shortName} has the same "id" as` + ' another schema in this set');
            }
            seenIds.add(schemaId);
            collectedSchemas.push(dependentSchema);
            JsonSchema._collectDependentSchemas(collectedSchemas, dependentSchema._dependentSchemas, seenObjects, seenIds);
        }
    }
    /**
     * Used to nicely format the ZSchema error tree.
     */
    static _formatErrorDetails(errorDetails) {
        return JsonSchema._formatErrorDetailsHelper(errorDetails, '', '');
    }
    /**
     * Used by _formatErrorDetails.
     */
    static _formatErrorDetailsHelper(errorDetails, indent, buffer) {
        for (const errorDetail of errorDetails) {
            buffer += os.EOL + indent + `Error: ${errorDetail.path}`;
            if (errorDetail.description) {
                const MAX_LENGTH = 40;
                let truncatedDescription = errorDetail.description.trim();
                if (truncatedDescription.length > MAX_LENGTH) {
                    truncatedDescription = truncatedDescription.substr(0, MAX_LENGTH - 3) + '...';
                }
                buffer += ` (${truncatedDescription})`;
            }
            buffer += os.EOL + indent + `       ${errorDetail.message}`;
            if (errorDetail.inner) {
                buffer = JsonSchema._formatErrorDetailsHelper(errorDetail.inner, indent + '  ', buffer);
            }
        }
        return buffer;
    }
    /**
     * Returns a short name for this schema, for use in error messages.
     * @remarks
     * If the schema was loaded from a file, then the base filename is used.  Otherwise, the "id"
     * field is used if available.
     */
    get shortName() {
        if (!this._filename) {
            if (this._schemaObject) {
                const schemaWithId = this._schemaObject;
                if (schemaWithId.id) {
                    return schemaWithId.id;
                }
            }
            return '(anonymous schema)';
        } else {
            return path.basename(this._filename);
        }
    }
    /**
     * If not already done, this loads the schema from disk and compiles it.
     * @remarks
     * Any dependencies will be compiled as well.
     */
    ensureCompiled() {
        this._ensureLoaded();
        if (!this._validator) {
            // Don't assign this to _validator until we're sure everything was successful
            const newValidator = new Validator({
                breakOnFirstError: false,
                noTypeless: true,
                noExtraKeywords: true
            });
            const anythingSchema = {
                'type': ['array', 'boolean', 'integer', 'number', 'object', 'string']
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newValidator.setRemoteReference('http://json-schema.org/draft-04/schema', anythingSchema);
            const collectedSchemas = [];
            const seenObjects = new Set();
            const seenIds = new Set();
            JsonSchema._collectDependentSchemas(collectedSchemas, this._dependentSchemas, seenObjects, seenIds);
            // Validate each schema in order.  We specifically do not supply them all together, because we want
            // to make sure that circular references will fail to validate.
            for (const collectedSchema of collectedSchemas) {
                if (!newValidator.validateSchema(collectedSchema._schemaObject)) {
                    throw new Error(`Failed to validate schema "${collectedSchema.shortName}":` + os.EOL + JsonSchema._formatErrorDetails(newValidator.getLastErrors()));
                }
            }
            this._validator = newValidator;
        }
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * an exception will be thrown.
     * @param jsonObject - The JSON data to be validated
     * @param filenameForErrors - The filename that the JSON data was available, or an empty string
     *    if not applicable
     * @param options - Other options that control the validation
     */
    validateObject(jsonObject, filenameForErrors, options) {
        this.validateObjectWithCallback(jsonObject, errorInfo => {
            const prefix = options && options.customErrorHeader ? options.customErrorHeader : 'JSON validation failed:';
            throw new Error(prefix + os.EOL + filenameForErrors + os.EOL + errorInfo.details);
        });
    }
    /**
     * Validates the specified JSON object against this JSON schema.  If the validation fails,
     * a callback is called for each validation error.
     */
    validateObjectWithCallback(jsonObject, errorCallback) {
        this.ensureCompiled();
        if (!this._validator.validate(jsonObject, this._schemaObject)) {
            const errorDetails = JsonSchema._formatErrorDetails(this._validator.getLastErrors());
            const args = {
                details: errorDetails
            };
            errorCallback(args);
        }
    }
    _ensureLoaded() {
        if (!this._schemaObject) {
            this._schemaObject = JsonFile_1.JsonFile.load(this._filename);
        }
        return this._schemaObject.id || '';
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkpzb25TY2hlbWEuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvcyIsInJlcXVpcmUiLCJwYXRoIiwiVmFsaWRhdG9yIiwiSnNvbkZpbGVfMSIsIkZpbGVTeXN0ZW1fMSIsIkpzb25TY2hlbWEiLCJjb25zdHJ1Y3RvciIsIl9kZXBlbmRlbnRTY2hlbWFzIiwiX2ZpbGVuYW1lIiwiX3ZhbGlkYXRvciIsInVuZGVmaW5lZCIsIl9zY2hlbWFPYmplY3QiLCJmcm9tRmlsZSIsImZpbGVuYW1lIiwib3B0aW9ucyIsIkZpbGVTeXN0ZW0iLCJleGlzdHMiLCJFcnJvciIsInNjaGVtYSIsImRlcGVuZGVudFNjaGVtYXMiLCJmcm9tTG9hZGVkT2JqZWN0Iiwic2NoZW1hT2JqZWN0IiwiX2NvbGxlY3REZXBlbmRlbnRTY2hlbWFzIiwiY29sbGVjdGVkU2NoZW1hcyIsInNlZW5PYmplY3RzIiwic2VlbklkcyIsImRlcGVuZGVudFNjaGVtYSIsImhhcyIsImFkZCIsInNjaGVtYUlkIiwiX2Vuc3VyZUxvYWRlZCIsInNob3J0TmFtZSIsInB1c2giLCJfZm9ybWF0RXJyb3JEZXRhaWxzIiwiZXJyb3JEZXRhaWxzIiwiX2Zvcm1hdEVycm9yRGV0YWlsc0hlbHBlciIsImluZGVudCIsImJ1ZmZlciIsImVycm9yRGV0YWlsIiwiRU9MIiwiZGVzY3JpcHRpb24iLCJNQVhfTEVOR1RIIiwidHJ1bmNhdGVkRGVzY3JpcHRpb24iLCJ0cmltIiwibGVuZ3RoIiwic3Vic3RyIiwibWVzc2FnZSIsImlubmVyIiwic2NoZW1hV2l0aElkIiwiaWQiLCJiYXNlbmFtZSIsImVuc3VyZUNvbXBpbGVkIiwibmV3VmFsaWRhdG9yIiwiYnJlYWtPbkZpcnN0RXJyb3IiLCJub1R5cGVsZXNzIiwibm9FeHRyYUtleXdvcmRzIiwiYW55dGhpbmdTY2hlbWEiLCJzZXRSZW1vdGVSZWZlcmVuY2UiLCJTZXQiLCJjb2xsZWN0ZWRTY2hlbWEiLCJ2YWxpZGF0ZVNjaGVtYSIsImdldExhc3RFcnJvcnMiLCJ2YWxpZGF0ZU9iamVjdCIsImpzb25PYmplY3QiLCJmaWxlbmFtZUZvckVycm9ycyIsInZhbGlkYXRlT2JqZWN0V2l0aENhbGxiYWNrIiwiZXJyb3JJbmZvIiwicHJlZml4IiwiY3VzdG9tRXJyb3JIZWFkZXIiLCJkZXRhaWxzIiwiZXJyb3JDYWxsYmFjayIsInZhbGlkYXRlIiwiYXJncyIsIkpzb25GaWxlIiwibG9hZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQSxNQUFNQyxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1DLE9BQU9ELFFBQVEsTUFBUixDQUFiO0FBQ0EsTUFBTUUsWUFBWUYsUUFBUSxVQUFSLENBQWxCO0FBQ0EsTUFBTUcsYUFBYUgsUUFBUSxZQUFSLENBQW5CO0FBQ0EsTUFBTUksZUFBZUosUUFBUSxjQUFSLENBQXJCO0FBQ0E7Ozs7Ozs7OztBQVNBLE1BQU1LLFVBQU4sQ0FBaUI7QUFDYkMsa0JBQWM7QUFDVixhQUFLQyxpQkFBTCxHQUF5QixFQUF6QjtBQUNBLGFBQUtDLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxhQUFLQyxVQUFMLEdBQWtCQyxTQUFsQjtBQUNBLGFBQUtDLGFBQUwsR0FBcUJELFNBQXJCO0FBQ0g7QUFDRDs7Ozs7O0FBTUEsV0FBT0UsUUFBUCxDQUFnQkMsUUFBaEIsRUFBMEJDLE9BQTFCLEVBQW1DO0FBQy9CO0FBQ0E7QUFDQSxZQUFJLENBQUNWLGFBQWFXLFVBQWIsQ0FBd0JDLE1BQXhCLENBQStCSCxRQUEvQixDQUFMLEVBQStDO0FBQzNDLGtCQUFNLElBQUlJLEtBQUosQ0FBVSw0QkFBNEJKLFFBQXRDLENBQU47QUFDSDtBQUNELGNBQU1LLFNBQVMsSUFBSWIsVUFBSixFQUFmO0FBQ0FhLGVBQU9WLFNBQVAsR0FBbUJLLFFBQW5CO0FBQ0EsWUFBSUMs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LyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZShcInotc2NoZW1hXCIpO1xuY29uc3QgSnNvbkZpbGVfMSA9IHJlcXVpcmUoXCIuL0pzb25GaWxlXCIpO1xuY29uc3QgRmlsZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vRmlsZVN5c3RlbVwiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIEpTT04gc2NoZW1hIHRoYXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgSlNPTiBkYXRhIGZpbGVzIGxvYWRlZCBieSB0aGUgSnNvbkZpbGUgY2xhc3MuXG4gKiBAcmVtYXJrc1xuICogVGhlIHNjaGVtYSBpdHNlbGYgaXMgbm9ybWFsbHkgbG9hZGVkIGFuZCBjb21waWxlZCBsYXRlciwgb25seSBpZiBpdCBpcyBhY3R1YWxseSByZXF1aXJlZCB0byB2YWxpZGF0ZVxuICogYW4gaW5wdXQuICBUbyBhdm9pZCBzY2hlbWEgZXJyb3JzIGF0IHJ1bnRpbWUsIGl0J3MgcmVjb21tZW5kZWQgdG8gY3JlYXRlIGEgdW5pdCB0ZXN0IHRoYXQgY2FsbHNcbiAqIEpzb25TY2hlbWEuZW5zdXJlQ29tcGlsZWQoKSBmb3IgZWFjaCBvZiB5b3VyIHNjaGVtYSBvYmplY3RzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSnNvblNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2RlcGVuZGVudFNjaGVtYXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zY2hlbWFPYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIEpzb25TY2hlbWEgdGhhdCB3aWxsIGJlIGxvYWRlZCBmcm9tIGEgZmlsZSBvbiBkaXNrLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogTk9URTogQW4gZXJyb3Igb2NjdXJzIGlmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0OyBob3dldmVyLCB0aGUgZmlsZSBpdHNlbGYgaXMgbm90IGxvYWRlZCBvciB2YWxpZGF0ZWRcbiAgICAgKiB1bnRpbCBpdCB0aGUgc2NoZW1hIGlzIGFjdHVhbGx5IHVzZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21GaWxlKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBxdWljayBhbmQgaW5leHBlbnNpdmUgdGVzdCB0byBhdm9pZCB0aGUgY2F0Y2ggdGhlIG1vc3QgY29tbW9uIGVycm9ycyBlYXJseS5cbiAgICAgICAgLy8gRnVsbCB2YWxpZGF0aW9uIHdpbGwgaGFwcGVuIGxhdGVyIGluIEpzb25TY2hlbWEuY29tcGlsZSgpLlxuICAgICAgICBpZiAoIUZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmV4aXN0cyhmaWxlbmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIGZpbGUgbm90IGZvdW5kOiAnICsgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBKc29uU2NoZW1hKCk7XG4gICAgICAgIHNjaGVtYS5fZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHNjaGVtYS5fZGVwZW5kZW50U2NoZW1hcyA9IG9wdGlvbnMuZGVwZW5kZW50U2NoZW1hcyB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBKc29uU2NoZW1hIHRoYXQgd2lsbCBiZSBsb2FkZWQgZnJvbSBhIGZpbGUgb24gZGlzay5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIE5PVEU6IEFuIGVycm9yIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdDsgaG93ZXZlciwgdGhlIGZpbGUgaXRzZWxmIGlzIG5vdCBsb2FkZWQgb3IgdmFsaWRhdGVkXG4gICAgICogdW50aWwgaXQgdGhlIHNjaGVtYSBpcyBhY3R1YWxseSB1c2VkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTG9hZGVkT2JqZWN0KHNjaGVtYU9iamVjdCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBuZXcgSnNvblNjaGVtYSgpO1xuICAgICAgICBzY2hlbWEuX3NjaGVtYU9iamVjdCA9IHNjaGVtYU9iamVjdDtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIF9jb2xsZWN0RGVwZW5kZW50U2NoZW1hcyhjb2xsZWN0ZWRTY2hlbWFzLCBkZXBlbmRlbnRTY2hlbWFzLCBzZWVuT2JqZWN0cywgc2Vlbklkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVudFNjaGVtYSBvZiBkZXBlbmRlbnRTY2hlbWFzKSB7XG4gICAgICAgICAgICAvLyBJdCdzIG9rYXkgZm9yIHRoZSBzYW1lIHNjaGVtYSB0byBhcHBlYXIgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHRyZWUsIGJ1dCB3ZSBvbmx5IHByb2Nlc3MgaXQgb25jZVxuICAgICAgICAgICAgaWYgKHNlZW5PYmplY3RzLmhhcyhkZXBlbmRlbnRTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuT2JqZWN0cy5hZGQoZGVwZW5kZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYUlkID0gZGVwZW5kZW50U2NoZW1hLl9lbnN1cmVMb2FkZWQoKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFJZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgc2NoZW1hICR7ZGVwZW5kZW50U2NoZW1hLnNob3J0TmFtZX0gY2Fubm90IGJlIHJlZmVyZW5jZWRgXG4gICAgICAgICAgICAgICAgICAgICsgJyBiZWNhdXNlIGlzIG1pc3NpbmcgdGhlIFwiaWRcIiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZW5JZHMuaGFzKHNjaGVtYUlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBzY2hlbWEgJHtkZXBlbmRlbnRTY2hlbWEuc2hvcnROYW1lfSBoYXMgdGhlIHNhbWUgXCJpZFwiIGFzYFxuICAgICAgICAgICAgICAgICAgICArICcgYW5vdGhlciBzY2hlbWEgaW4gdGhpcyBzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5JZHMuYWRkKHNjaGVtYUlkKTtcbiAgICAgICAgICAgIGNvbGxlY3RlZFNjaGVtYXMucHVzaChkZXBlbmRlbnRTY2hlbWEpO1xuICAgICAgICAgICAgSnNvblNjaGVtYS5fY29sbGVjdERlcGVuZGVudFNjaGVtYXMoY29sbGVjdGVkU2NoZW1hcywgZGVwZW5kZW50U2NoZW1hLl9kZXBlbmRlbnRTY2hlbWFzLCBzZWVuT2JqZWN0cywgc2Vlbklkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBuaWNlbHkgZm9ybWF0IHRoZSBaU2NoZW1hIGVycm9yIHRyZWUuXG4gICAgICovXG4gICAgc3RhdGljIF9mb3JtYXRFcnJvckRldGFpbHMoZXJyb3JEZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiBKc29uU2NoZW1hLl9mb3JtYXRFcnJvckRldGFpbHNIZWxwZXIoZXJyb3JEZXRhaWxzLCAnJywgJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IF9mb3JtYXRFcnJvckRldGFpbHMuXG4gICAgICovXG4gICAgc3RhdGljIF9mb3JtYXRFcnJvckRldGFpbHNIZWxwZXIoZXJyb3JEZXRhaWxzLCBpbmRlbnQsIGJ1ZmZlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVycm9yRGV0YWlsIG9mIGVycm9yRGV0YWlscykge1xuICAgICAgICAgICAgYnVmZmVyICs9IG9zLkVPTCArIGluZGVudCArIGBFcnJvcjogJHtlcnJvckRldGFpbC5wYXRofWA7XG4gICAgICAgICAgICBpZiAoZXJyb3JEZXRhaWwuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBNQVhfTEVOR1RIID0gNDA7XG4gICAgICAgICAgICAgICAgbGV0IHRydW5jYXRlZERlc2NyaXB0aW9uID0gZXJyb3JEZXRhaWwuZGVzY3JpcHRpb24udHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY2F0ZWREZXNjcmlwdGlvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgIHRydW5jYXRlZERlc2NyaXB0aW9uID0gdHJ1bmNhdGVkRGVzY3JpcHRpb24uc3Vic3RyKDAsIE1BWF9MRU5HVEggLSAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLi4uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGAgKCR7dHJ1bmNhdGVkRGVzY3JpcHRpb259KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgKz0gb3MuRU9MICsgaW5kZW50ICsgYCAgICAgICAke2Vycm9yRGV0YWlsLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIGlmIChlcnJvckRldGFpbC5pbm5lcikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEpzb25TY2hlbWEuX2Zvcm1hdEVycm9yRGV0YWlsc0hlbHBlcihlcnJvckRldGFpbC5pbm5lciwgaW5kZW50ICsgJyAgJywgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2hvcnQgbmFtZSBmb3IgdGhpcyBzY2hlbWEsIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGUgc2NoZW1hIHdhcyBsb2FkZWQgZnJvbSBhIGZpbGUsIHRoZW4gdGhlIGJhc2UgZmlsZW5hbWUgaXMgdXNlZC4gIE90aGVyd2lzZSwgdGhlIFwiaWRcIlxuICAgICAqIGZpZWxkIGlzIHVzZWQgaWYgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGdldCBzaG9ydE5hbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2hlbWFPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFXaXRoSWQgPSB0aGlzLl9zY2hlbWFPYmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVdpdGhJZC5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hV2l0aElkLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnKGFub255bW91cyBzY2hlbWEpJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKHRoaXMuX2ZpbGVuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBub3QgYWxyZWFkeSBkb25lLCB0aGlzIGxvYWRzIHRoZSBzY2hlbWEgZnJvbSBkaXNrIGFuZCBjb21waWxlcyBpdC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFueSBkZXBlbmRlbmNpZXMgd2lsbCBiZSBjb21waWxlZCBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGVuc3VyZUNvbXBpbGVkKCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVMb2FkZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGFzc2lnbiB0aGlzIHRvIF92YWxpZGF0b3IgdW50aWwgd2UncmUgc3VyZSBldmVyeXRoaW5nIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICBjb25zdCBuZXdWYWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHtcbiAgICAgICAgICAgICAgICBicmVha09uRmlyc3RFcnJvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgbm9UeXBlbGVzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBub0V4dHJhS2V5d29yZHM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYW55dGhpbmdTY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBuZXdWYWxpZGF0b3Iuc2V0UmVtb3RlUmVmZXJlbmNlKCdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYScsIGFueXRoaW5nU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RlZFNjaGVtYXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlZW5PYmplY3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3Qgc2VlbklkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIEpzb25TY2hlbWEuX2NvbGxlY3REZXBlbmRlbnRTY2hlbWFzKGNvbGxlY3RlZFNjaGVtYXMsIHRoaXMuX2RlcGVuZGVudFNjaGVtYXMsIHNlZW5PYmplY3RzLCBzZWVuSWRzKTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGVhY2ggc2NoZW1hIGluIG9yZGVyLiAgV2Ugc3BlY2lmaWNhbGx5IGRvIG5vdCBzdXBwbHkgdGhlbSBhbGwgdG9nZXRoZXIsIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgY2lyY3VsYXIgcmVmZXJlbmNlcyB3aWxsIGZhaWwgdG8gdmFsaWRhdGUuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxlY3RlZFNjaGVtYSBvZiBjb2xsZWN0ZWRTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXdWYWxpZGF0b3IudmFsaWRhdGVTY2hlbWEoY29sbGVjdGVkU2NoZW1hLl9zY2hlbWFPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHZhbGlkYXRlIHNjaGVtYSBcIiR7Y29sbGVjdGVkU2NoZW1hLnNob3J0TmFtZX1cIjpgICsgb3MuRU9MXG4gICAgICAgICAgICAgICAgICAgICAgICArIEpzb25TY2hlbWEuX2Zvcm1hdEVycm9yRGV0YWlscyhuZXdWYWxpZGF0b3IuZ2V0TGFzdEVycm9ycygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gbmV3VmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIEpTT04gb2JqZWN0IGFnYWluc3QgdGhpcyBKU09OIHNjaGVtYS4gIElmIHRoZSB2YWxpZGF0aW9uIGZhaWxzLFxuICAgICAqIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0ganNvbk9iamVjdCAtIFRoZSBKU09OIGRhdGEgdG8gYmUgdmFsaWRhdGVkXG4gICAgICogQHBhcmFtIGZpbGVuYW1lRm9yRXJyb3JzIC0gVGhlIGZpbGVuYW1lIHRoYXQgdGhlIEpTT04gZGF0YSB3YXMgYXZhaWxhYmxlLCBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICAgKiAgICBpZiBub3QgYXBwbGljYWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3RoZXIgb3B0aW9ucyB0aGF0IGNvbnRyb2wgdGhlIHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU9iamVjdChqc29uT2JqZWN0LCBmaWxlbmFtZUZvckVycm9ycywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlT2JqZWN0V2l0aENhbGxiYWNrKGpzb25PYmplY3QsIChlcnJvckluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChvcHRpb25zICYmIG9wdGlvbnMuY3VzdG9tRXJyb3JIZWFkZXIpID8gb3B0aW9ucy5jdXN0b21FcnJvckhlYWRlclxuICAgICAgICAgICAgICAgIDogJ0pTT04gdmFsaWRhdGlvbiBmYWlsZWQ6JztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyBvcy5FT0wgK1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lRm9yRXJyb3JzICsgb3MuRU9MICsgZXJyb3JJbmZvLmRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBzcGVjaWZpZWQgSlNPTiBvYmplY3QgYWdhaW5zdCB0aGlzIEpTT04gc2NoZW1hLiAgSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsXG4gICAgICogYSBjYWxsYmFjayBpcyBjYWxsZWQgZm9yIGVhY2ggdmFsaWRhdGlvbiBlcnJvci5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU9iamVjdFdpdGhDYWxsYmFjayhqc29uT2JqZWN0LCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ29tcGlsZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0b3IudmFsaWRhdGUoanNvbk9iamVjdCwgdGhpcy5fc2NoZW1hT2JqZWN0KSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gSnNvblNjaGVtYS5fZm9ybWF0RXJyb3JEZXRhaWxzKHRoaXMuX3ZhbGlkYXRvci5nZXRMYXN0RXJyb3JzKCkpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvckRldGFpbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbnN1cmVMb2FkZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2NoZW1hT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFPYmplY3QgPSBKc29uRmlsZV8xLkpzb25GaWxlLmxvYWQodGhpcy5fZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlbWFPYmplY3QuaWQgfHwgJyc7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uU2NoZW1hID0gSnNvblNjaGVtYTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb25TY2hlbWEuanMubWFwIl19