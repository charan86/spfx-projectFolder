{"version":3,"sources":["PackageJsonLookup.js"],"names":["Object","defineProperty","exports","value","path","require","JsonFile_1","FileSystem_1","PackageJsonLookup","constructor","parameters","_loadExtraFields","loadExtraFields","clearCache","loadOwnPackageJson","dirnameOfCaller","packageJson","_loadOwnPackageJsonLookup","tryLoadPackageJsonFor","undefined","Error","version","errorPath","tryGetPackageJsonFilePathFor","_packageFolderCache","Map","_packageJsonCache","tryGetPackageFolderFor","fileOrFolderPath","resolvedFileOrFolderPath","resolve","has","get","_tryGetPackageFolderFor","packageJsonFolder","join","packageJsonFilePath","loadPackageJson","tryLoadNodePackageJsonFor","loadNodePackageJson","jsonFilename","FileSystem","exists","normalizedFilePath","getRealPath","loadedPackageJson","JsonFile","load","name","bin","dependencies","description","devDependencies","homepage","license","main","optionalDependencies","peerDependencies","private","scripts","typings","types","tsdocMetadata","freeze","set","parentFolder","dirname","parentResult"],"mappings":"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","file":"PackageJsonLookup.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst JsonFile_1 = require(\"./JsonFile\");\nconst FileSystem_1 = require(\"./FileSystem\");\n/**\n * This class provides methods for finding the nearest \"package.json\" for a folder\n * and retrieving the name of the package.  The results are cached.\n *\n * @public\n */\nclass PackageJsonLookup {\n    constructor(parameters) {\n        this._loadExtraFields = false;\n        if (parameters) {\n            if (parameters.loadExtraFields) {\n                this._loadExtraFields = parameters.loadExtraFields;\n            }\n        }\n        this.clearCache();\n    }\n    /**\n     * A helper for loading the caller's own package.json file.\n     *\n     * @remarks\n     *\n     * This function provides a concise and efficient way for an NPM package to report metadata about itself.\n     * For example, a tool might want to report its version.\n     *\n     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,\n     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's\n     * own package.json (and intermediary folders) will never change during the lifetime of the process.\n     *\n     * @example\n     * ```ts\n     * // Report the version of our NPM package\n     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;\n     * console.log(`Cool Tool - Version ${myPackageVersion}`);\n     * ```\n     *\n     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.\n     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during\n     * loading, an exception will be thrown instead.\n     */\n    static loadOwnPackageJson(dirnameOfCaller) {\n        const packageJson = PackageJsonLookup._loadOwnPackageJsonLookup\n            .tryLoadPackageJsonFor(dirnameOfCaller);\n        if (packageJson === undefined) {\n            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.`\n                + `  The __dirname was: ${dirnameOfCaller}`);\n        }\n        if (packageJson.version !== undefined) {\n            return packageJson;\n        }\n        const errorPath = PackageJsonLookup._loadOwnPackageJsonLookup.tryGetPackageJsonFilePathFor(dirnameOfCaller)\n            || 'package.json';\n        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the \"version\" field is missing in`\n            + ` ${errorPath}`);\n    }\n    /**\n     * Clears the internal file cache.\n     * @remarks\n     * Call this method if changes have been made to the package.json files on disk.\n     */\n    clearCache() {\n        this._packageFolderCache = new Map();\n        this._packageJsonCache = new Map();\n    }\n    /**\n     * Returns the absolute path of a folder containing a package.json file, by looking\n     * upwards from the specified fileOrFolderPath.  If no package.json can be found,\n     * undefined is returned.\n     *\n     * @remarks\n     * The fileOrFolderPath is not required to actually exist on disk.\n     * The fileOrFolderPath itself can be the return value, if it is a folder containing\n     * a package.json file.\n     * Both positive and negative lookup results are cached.\n     *\n     * @param fileOrFolderPath - a relative or absolute path to a source file or folder\n     * that may be part of a package\n     * @returns an absolute path to a folder containing a package.json file\n     */\n    tryGetPackageFolderFor(fileOrFolderPath) {\n        // Convert it to an absolute path\n        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);\n        // Optimistically hope that the starting string is already in the cache,\n        // in which case we can avoid disk access entirely.\n        //\n        // (Two lookups are required, because get() cannot distinguish the undefined value\n        // versus a missing key.)\n        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {\n            return this._packageFolderCache.get(resolvedFileOrFolderPath);\n        }\n        // Now call the recursive part of the algorithm\n        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);\n    }\n    /**\n     * If the specified file or folder is part of a package, this returns the absolute path\n     * to the associated package.json file.\n     *\n     * @remarks\n     * The package folder is determined using the same algorithm\n     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.\n     *\n     * @param fileOrFolderPath - a relative or absolute path to a source file or folder\n     * that may be part of a package\n     * @returns an absolute path to * package.json file\n     */\n    tryGetPackageJsonFilePathFor(fileOrFolderPath) {\n        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);\n        if (!packageJsonFolder) {\n            return undefined;\n        }\n        return path.join(packageJsonFolder, \"package.json\" /* PackageJson */);\n    }\n    /**\n     * If the specified file or folder is part of a package, this loads and returns the\n     * associated package.json file.\n     *\n     * @remarks\n     * The package folder is determined using the same algorithm\n     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.\n     *\n     * @param fileOrFolderPath - a relative or absolute path to a source file or folder\n     * that may be part of a package\n     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not\n     * belong to a package\n     */\n    tryLoadPackageJsonFor(fileOrFolderPath) {\n        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);\n        if (!packageJsonFilePath) {\n            return undefined;\n        }\n        return this.loadPackageJson(packageJsonFilePath);\n    }\n    /**\n     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report\n     * an error if the `version` field is missing from the package.json file.\n     */\n    tryLoadNodePackageJsonFor(fileOrFolderPath) {\n        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);\n        if (!packageJsonFilePath) {\n            return undefined;\n        }\n        return this.loadNodePackageJson(packageJsonFilePath);\n    }\n    /**\n     * Loads the specified package.json file, if it is not already present in the cache.\n     *\n     * @remarks\n     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,\n     * the returned IPackageJson object will contain a subset of essential fields.\n     * The returned object should be considered to be immutable; the caller must never\n     * modify it.\n     *\n     * @param jsonFilename - a relative or absolute path to a package.json file\n     */\n    loadPackageJson(jsonFilename) {\n        const packageJson = this.loadNodePackageJson(jsonFilename);\n        if (!packageJson.version) {\n            throw new Error(`Error reading \"${jsonFilename}\":\\n  `\n                + 'The required field \"version\" was not found');\n        }\n        return packageJson;\n    }\n    /**\n     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error\n     * if the `version` field is missing from the package.json file.\n     */\n    loadNodePackageJson(jsonFilename) {\n        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {\n            throw new Error(`Input file not found: ${jsonFilename}`);\n        }\n        // Since this will be a cache key, follow any symlinks and get an absolute path\n        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)\n        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);\n        let packageJson = this._packageJsonCache.get(normalizedFilePath);\n        if (!packageJson) {\n            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);\n            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,\n            // but NPM only requires \"name\" and \"version\"\n            if (!loadedPackageJson.name) {\n                throw new Error(`Error reading \"${jsonFilename}\":\\n  `\n                    + 'The required field \"name\" was not found');\n            }\n            if (this._loadExtraFields) {\n                packageJson = loadedPackageJson;\n            }\n            else {\n                packageJson = {};\n                // Unless \"loadExtraFields\" was requested, copy over the essential fields only\n                packageJson.bin = loadedPackageJson.bin;\n                packageJson.dependencies = loadedPackageJson.dependencies;\n                packageJson.description = loadedPackageJson.description;\n                packageJson.devDependencies = loadedPackageJson.devDependencies;\n                packageJson.homepage = loadedPackageJson.homepage;\n                packageJson.license = loadedPackageJson.license;\n                packageJson.main = loadedPackageJson.main;\n                packageJson.name = loadedPackageJson.name;\n                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;\n                packageJson.peerDependencies = loadedPackageJson.peerDependencies;\n                packageJson.private = loadedPackageJson.private;\n                packageJson.scripts = loadedPackageJson.scripts;\n                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;\n                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;\n                packageJson.version = loadedPackageJson.version;\n            }\n            Object.freeze(packageJson);\n            this._packageJsonCache.set(normalizedFilePath, packageJson);\n        }\n        return packageJson;\n    }\n    // Recursive part of the algorithm from tryGetPackageFolderFor()\n    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {\n        // Two lookups are required, because get() cannot distinguish the undefined value\n        // versus a missing key.\n        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {\n            return this._packageFolderCache.get(resolvedFileOrFolderPath);\n        }\n        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.\n        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, \"package.json\" /* PackageJson */))) {\n            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);\n            return resolvedFileOrFolderPath;\n        }\n        // Otherwise go up one level\n        const parentFolder = path.dirname(resolvedFileOrFolderPath);\n        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {\n            // We reached the root directory without finding a package.json file,\n            // so cache the negative result\n            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);\n            return undefined; // no match\n        }\n        // Recurse upwards, caching every step along the way\n        const parentResult = this._tryGetPackageFolderFor(parentFolder);\n        // Cache the parent's answer as well\n        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);\n        return parentResult;\n    }\n}\nPackageJsonLookup._loadOwnPackageJsonLookup = new PackageJsonLookup({ loadExtraFields: true });\nexports.PackageJsonLookup = PackageJsonLookup;\n//# sourceMappingURL=PackageJsonLookup.js.map"]}