2bdb269bcc34b122031133f34b24efd3
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const JsonFile_1 = require("./JsonFile");
const FileSystem_1 = require("./FileSystem");
/**
 * This class provides methods for finding the nearest "package.json" for a folder
 * and retrieving the name of the package.  The results are cached.
 *
 * @public
 */
class PackageJsonLookup {
    constructor(parameters) {
        this._loadExtraFields = false;
        if (parameters) {
            if (parameters.loadExtraFields) {
                this._loadExtraFields = parameters.loadExtraFields;
            }
        }
        this.clearCache();
    }
    /**
     * A helper for loading the caller's own package.json file.
     *
     * @remarks
     *
     * This function provides a concise and efficient way for an NPM package to report metadata about itself.
     * For example, a tool might want to report its version.
     *
     * The `loadOwnPackageJson()` probes upwards from the caller's folder, expecting to find a package.json file,
     * which is assumed to be the caller's package.  The result is cached, under the assumption that a tool's
     * own package.json (and intermediary folders) will never change during the lifetime of the process.
     *
     * @example
     * ```ts
     * // Report the version of our NPM package
     * const myPackageVersion: string = PackageJsonLookup.loadOwnPackageJson(__dirname).version;
     * console.log(`Cool Tool - Version ${myPackageVersion}`);
     * ```
     *
     * @param dirnameOfCaller - The NodeJS `__dirname` macro for the caller.
     * @returns This function always returns a valid `IPackageJson` object.  If any problems are encountered during
     * loading, an exception will be thrown instead.
     */
    static loadOwnPackageJson(dirnameOfCaller) {
        const packageJson = PackageJsonLookup._loadOwnPackageJsonLookup.tryLoadPackageJsonFor(dirnameOfCaller);
        if (packageJson === undefined) {
            throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed to find the caller's package.json.` + `  The __dirname was: ${dirnameOfCaller}`);
        }
        if (packageJson.version !== undefined) {
            return packageJson;
        }
        const errorPath = PackageJsonLookup._loadOwnPackageJsonLookup.tryGetPackageJsonFilePathFor(dirnameOfCaller) || 'package.json';
        throw new Error(`PackageJsonLookup.loadOwnPackageJson() failed because the "version" field is missing in` + ` ${errorPath}`);
    }
    /**
     * Clears the internal file cache.
     * @remarks
     * Call this method if changes have been made to the package.json files on disk.
     */
    clearCache() {
        this._packageFolderCache = new Map();
        this._packageJsonCache = new Map();
    }
    /**
     * Returns the absolute path of a folder containing a package.json file, by looking
     * upwards from the specified fileOrFolderPath.  If no package.json can be found,
     * undefined is returned.
     *
     * @remarks
     * The fileOrFolderPath is not required to actually exist on disk.
     * The fileOrFolderPath itself can be the return value, if it is a folder containing
     * a package.json file.
     * Both positive and negative lookup results are cached.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to a folder containing a package.json file
     */
    tryGetPackageFolderFor(fileOrFolderPath) {
        // Convert it to an absolute path
        const resolvedFileOrFolderPath = path.resolve(fileOrFolderPath);
        // Optimistically hope that the starting string is already in the cache,
        // in which case we can avoid disk access entirely.
        //
        // (Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.)
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Now call the recursive part of the algorithm
        return this._tryGetPackageFolderFor(resolvedFileOrFolderPath);
    }
    /**
     * If the specified file or folder is part of a package, this returns the absolute path
     * to the associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an absolute path to * package.json file
     */
    tryGetPackageJsonFilePathFor(fileOrFolderPath) {
        const packageJsonFolder = this.tryGetPackageFolderFor(fileOrFolderPath);
        if (!packageJsonFolder) {
            return undefined;
        }
        return path.join(packageJsonFolder, "package.json" /* PackageJson */);
    }
    /**
     * If the specified file or folder is part of a package, this loads and returns the
     * associated package.json file.
     *
     * @remarks
     * The package folder is determined using the same algorithm
     * as {@link PackageJsonLookup.tryGetPackageFolderFor}.
     *
     * @param fileOrFolderPath - a relative or absolute path to a source file or folder
     * that may be part of a package
     * @returns an IPackageJson object, or undefined if the fileOrFolderPath does not
     * belong to a package
     */
    tryLoadPackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadPackageJson(packageJsonFilePath);
    }
    /**
     * This function is similar to {@link PackageJsonLookup.tryLoadPackageJsonFor}, except that it does not report
     * an error if the `version` field is missing from the package.json file.
     */
    tryLoadNodePackageJsonFor(fileOrFolderPath) {
        const packageJsonFilePath = this.tryGetPackageJsonFilePathFor(fileOrFolderPath);
        if (!packageJsonFilePath) {
            return undefined;
        }
        return this.loadNodePackageJson(packageJsonFilePath);
    }
    /**
     * Loads the specified package.json file, if it is not already present in the cache.
     *
     * @remarks
     * Unless {@link IPackageJsonLookupParameters.loadExtraFields} was specified,
     * the returned IPackageJson object will contain a subset of essential fields.
     * The returned object should be considered to be immutable; the caller must never
     * modify it.
     *
     * @param jsonFilename - a relative or absolute path to a package.json file
     */
    loadPackageJson(jsonFilename) {
        const packageJson = this.loadNodePackageJson(jsonFilename);
        if (!packageJson.version) {
            throw new Error(`Error reading "${jsonFilename}":\n  ` + 'The required field "version" was not found');
        }
        return packageJson;
    }
    /**
     * This function is similar to {@link PackageJsonLookup.loadPackageJson}, except that it does not report an error
     * if the `version` field is missing from the package.json file.
     */
    loadNodePackageJson(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        // Since this will be a cache key, follow any symlinks and get an absolute path
        // to minimize duplication.  (Note that duplication can still occur due to e.g. character case.)
        const normalizedFilePath = FileSystem_1.FileSystem.getRealPath(jsonFilename);
        let packageJson = this._packageJsonCache.get(normalizedFilePath);
        if (!packageJson) {
            const loadedPackageJson = JsonFile_1.JsonFile.load(normalizedFilePath);
            // Make sure this is really a package.json file.  CommonJS has fairly strict requirements,
            // but NPM only requires "name" and "version"
            if (!loadedPackageJson.name) {
                throw new Error(`Error reading "${jsonFilename}":\n  ` + 'The required field "name" was not found');
            }
            if (this._loadExtraFields) {
                packageJson = loadedPackageJson;
            } else {
                packageJson = {};
                // Unless "loadExtraFields" was requested, copy over the essential fields only
                packageJson.bin = loadedPackageJson.bin;
                packageJson.dependencies = loadedPackageJson.dependencies;
                packageJson.description = loadedPackageJson.description;
                packageJson.devDependencies = loadedPackageJson.devDependencies;
                packageJson.homepage = loadedPackageJson.homepage;
                packageJson.license = loadedPackageJson.license;
                packageJson.main = loadedPackageJson.main;
                packageJson.name = loadedPackageJson.name;
                packageJson.optionalDependencies = loadedPackageJson.optionalDependencies;
                packageJson.peerDependencies = loadedPackageJson.peerDependencies;
                packageJson.private = loadedPackageJson.private;
                packageJson.scripts = loadedPackageJson.scripts;
                packageJson.typings = loadedPackageJson.typings || loadedPackageJson.types;
                packageJson.tsdocMetadata = loadedPackageJson.tsdocMetadata;
                packageJson.version = loadedPackageJson.version;
            }
            Object.freeze(packageJson);
            this._packageJsonCache.set(normalizedFilePath, packageJson);
        }
        return packageJson;
    }
    // Recursive part of the algorithm from tryGetPackageFolderFor()
    _tryGetPackageFolderFor(resolvedFileOrFolderPath) {
        // Two lookups are required, because get() cannot distinguish the undefined value
        // versus a missing key.
        if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {
            return this._packageFolderCache.get(resolvedFileOrFolderPath);
        }
        // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.
        if (FileSystem_1.FileSystem.exists(path.join(resolvedFileOrFolderPath, "package.json" /* PackageJson */))) {
            this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);
            return resolvedFileOrFolderPath;
        }
        // Otherwise go up one level
        const parentFolder = path.dirname(resolvedFileOrFolderPath);
        if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {
            // We reached the root directory without finding a package.json file,
            // so cache the negative result
            this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);
            return undefined; // no match
        }
        // Recurse upwards, caching every step along the way
        const parentResult = this._tryGetPackageFolderFor(parentFolder);
        // Cache the parent's answer as well
        this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);
        return parentResult;
    }
}
PackageJsonLookup._loadOwnPackageJsonLookup = new PackageJsonLookup({ loadExtraFields: true });
exports.PackageJsonLookup = PackageJsonLookup;
//# sourceMappingURL=PackageJsonLookup.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlBhY2thZ2VKc29uTG9va3VwLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGF0aCIsInJlcXVpcmUiLCJKc29uRmlsZV8xIiwiRmlsZVN5c3RlbV8xIiwiUGFja2FnZUpzb25Mb29rdXAiLCJjb25zdHJ1Y3RvciIsInBhcmFtZXRlcnMiLCJfbG9hZEV4dHJhRmllbGRzIiwibG9hZEV4dHJhRmllbGRzIiwiY2xlYXJDYWNoZSIsImxvYWRPd25QYWNrYWdlSnNvbiIsImRpcm5hbWVPZkNhbGxlciIsInBhY2thZ2VKc29uIiwiX2xvYWRPd25QYWNrYWdlSnNvbkxvb2t1cCIsInRyeUxvYWRQYWNrYWdlSnNvbkZvciIsInVuZGVmaW5lZCIsIkVycm9yIiwidmVyc2lvbiIsImVycm9yUGF0aCIsInRyeUdldFBhY2thZ2VKc29uRmlsZVBhdGhGb3IiLCJfcGFja2FnZUZvbGRlckNhY2hlIiwiTWFwIiwiX3BhY2thZ2VKc29uQ2FjaGUiLCJ0cnlHZXRQYWNrYWdlRm9sZGVyRm9yIiwiZmlsZU9yRm9sZGVyUGF0aCIsInJlc29sdmVkRmlsZU9yRm9sZGVyUGF0aCIsInJlc29sdmUiLCJoYXMiLCJnZXQiLCJfdHJ5R2V0UGFja2FnZUZvbGRlckZvciIsInBhY2thZ2VKc29uRm9sZGVyIiwiam9pbiIsInBhY2thZ2VKc29uRmlsZVBhdGgiLCJsb2FkUGFja2FnZUpzb24iLCJ0cnlMb2FkTm9kZVBhY2thZ2VKc29uRm9yIiwibG9hZE5vZGVQYWNrYWdlSnNvbiIsImpzb25GaWxlbmFtZSIsIkZpbGVTeXN0ZW0iLCJleGlzdHMiLCJub3JtYWxpemVkRmlsZVBhdGgiLCJnZXRSZWFsUGF0aCIsImxvYWRlZFBhY2thZ2VKc29uIiwiSnNvbkZpbGUiLCJsb2FkIiwibmFtZSIsImJpbiIsImRlcGVuZGVuY2llcyIsImRlc2NyaXB0aW9uIiwiZGV2RGVwZW5kZW5jaWVzIiwiaG9tZXBhZ2UiLCJsaWNlbnNlIiwibWFpbiIsIm9wdGlvbmFsRGVwZW5kZW5jaWVzIiwicGVlckRlcGVuZGVuY2llcyIsInByaXZhdGUiLCJzY3JpcHRzIiwidHlwaW5ncyIsInR5cGVzIiwidHNkb2NNZXRhZGF0YSIsImZyZWV6ZSIsInNldCIsInBhcmVudEZvbGRlciIsImRpcm5hbWUiLCJwYXJlbnRSZXN1bHQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFDQUEsT0FBT0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkMsRUFBRUMsT0FBTyxJQUFULEVBQTdDO0FBQ0EsTUFBTUMsT0FBT0MsUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFNQyxhQUFhRCxRQUFRLFlBQVIsQ0FBbkI7QUFDQSxNQUFNRSxlQUFlRixRQUFRLGNBQVIsQ0FBckI7QUFDQTs7Ozs7O0FBTUEsTUFBTUcsaUJBQU4sQ0FBd0I7QUFDcEJDLGdCQUFZQyxVQUFaLEVBQXdCO0FBQ3BCLGFBQUtDLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0EsWUFBSUQsVUFBSixFQUFnQjtBQUNaLGdCQUFJQSxXQUFXRSxlQUFmLEVBQWdDO0FBQzVCLHFCQUFLRCxnQkFBTCxHQUF3QkQsV0FBV0UsZUFBbkM7QUFDSDtBQUNKO0FBQ0QsYUFBS0MsVUFBTDtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLFdBQU9DLGtCQUFQLENBQTBCQyxlQUExQixFQUEyQztBQUN2QyxjQUFNQyxjQUFjUixrQkFBa0JTLHlCQUFsQixDQUNmQyxxQkFEZSxDQUNPSCxlQURQLENBQXBCO0FBRUEsWUFBSUMsZ0JBQWdCRyxTQUFwQixFQUErQjtBQUMzQixrQkFBTSxJQUFJQyxLQUFKLENBQVcsa0ZBQUQsR0FDVCx3QkFBdUJMLGVBQWdCLEVBRHhDLENBQU47QUFFSDtBQUNELFlBQUlDLFlBQVlLLE9BQVosS0FBd0JGLFNBQTVCLEVBQXVDO0FBQ25DLG1CQUFPSCxXQUFQO0FBQ0g7QUFDRCxjQUFNTSxZQUFZZCxrQkFBa0JTLHlCQUFsQixDQUE0Q00sNEJBQTVDLENBQXlF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O0FBQ0E7QUFDQSxZQUFJLEtBQUtMLG1CQUFMLENBQXlCTyxHQUF6QixDQUE2QkYsd0JBQTdCLENBQUosRUFBNEQ7QUFDeEQsbUJBQU8sS0FBS0wsbUJBQUwsQ0FBeUJRLEdBQXpCLENBQTZCSCx3QkFBN0IsQ0FBUDtBQUNIO0FBQ0Q7QUFDQSxZQUFJdEIsYUFBYWtDLFVBQWIsQ0FBd0JDLE1BQXhCLENBQStCdEMsS0FBSytCLElBQUwsQ0FBVU4sd0JBQVYsRUFBb0MsY0FBcEMsQ0FBbUQsaUJBQW5ELENBQS9CLENBQUosRUFBMkc7QUFDdkcsaUJBQUtMLG1CQUFMLENBQXlCd0MsR0FBekIsQ0FBNkJuQyx3QkFBN0IsRUFBdURBLHdCQUF2RDtBQUNBLG1CQUFPQSx3QkFBUDtBQUNIO0FBQ0Q7QUFDQSxjQUFNb0MsZUFBZTdELEtBQUs4RCxPQUFMLENBQWFyQyx3QkFBYixDQUFyQjtBQUNBLFlBQUksQ0FBQ29DLFlBQUQsSUFBaUJBLGlCQUFpQnBDLHdCQUF0QyxFQUFnRTtBQUM1RDtBQUNBO0FBQ0EsaUJBQUtMLG1CQUFMLENBQXlCd0MsR0FBekIsQ0FBNkJuQyx3QkFBN0IsRUFBdURWLFNBQXZEO0FBQ0EsbUJBQU9BLFNBQVAsQ0FKNEQsQ0FJMUM7QUFDckI7QUFDRDtBQUNBLGNBQU1nRCxlQUFlLEtBQUtsQyx1QkFBTCxDQUE2QmdDLFlBQTdCLENBQXJCO0FBQ0E7QUFDQSxhQUFLekMsbUJBQUwsQ0FBeUJ3QyxHQUF6QixDQUE2Qm5DLHdCQUE3QixFQUF1RHNDLFlBQXZEO0FBQ0EsZUFBT0EsWUFBUDtBQUNIO0FBbk9tQjtBQXFPeEIzRCxrQkFBa0JTLHlCQUFsQixHQUE4QyxJQUFJVCxpQkFBSixDQUFzQixFQUFFSSxpQkFBaUIsSUFBbkIsRUFBdEIsQ0FBOUM7QUFDQVYsUUFBUU0saUJBQVIsR0FBNEJBLGlCQUE1QjtBQUNBIiwiZmlsZSI6IlBhY2thZ2VKc29uTG9va3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IEpzb25GaWxlXzEgPSByZXF1aXJlKFwiLi9Kc29uRmlsZVwiKTtcbmNvbnN0IEZpbGVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0ZpbGVTeXN0ZW1cIik7XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZmluZGluZyB0aGUgbmVhcmVzdCBcInBhY2thZ2UuanNvblwiIGZvciBhIGZvbGRlclxuICogYW5kIHJldHJpZXZpbmcgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UuICBUaGUgcmVzdWx0cyBhcmUgY2FjaGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGFja2FnZUpzb25Mb29rdXAge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5fbG9hZEV4dHJhRmllbGRzID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5sb2FkRXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRXh0cmFGaWVsZHMgPSBwYXJhbWV0ZXJzLmxvYWRFeHRyYUZpZWxkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZm9yIGxvYWRpbmcgdGhlIGNhbGxlcidzIG93biBwYWNrYWdlLmpzb24gZmlsZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgY29uY2lzZSBhbmQgZWZmaWNpZW50IHdheSBmb3IgYW4gTlBNIHBhY2thZ2UgdG8gcmVwb3J0IG1ldGFkYXRhIGFib3V0IGl0c2VsZi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYSB0b29sIG1pZ2h0IHdhbnQgdG8gcmVwb3J0IGl0cyB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogVGhlIGBsb2FkT3duUGFja2FnZUpzb24oKWAgcHJvYmVzIHVwd2FyZHMgZnJvbSB0aGUgY2FsbGVyJ3MgZm9sZGVyLCBleHBlY3RpbmcgdG8gZmluZCBhIHBhY2thZ2UuanNvbiBmaWxlLFxuICAgICAqIHdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGNhbGxlcidzIHBhY2thZ2UuICBUaGUgcmVzdWx0IGlzIGNhY2hlZCwgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRvb2wnc1xuICAgICAqIG93biBwYWNrYWdlLmpzb24gKGFuZCBpbnRlcm1lZGlhcnkgZm9sZGVycykgd2lsbCBuZXZlciBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiAvLyBSZXBvcnQgdGhlIHZlcnNpb24gb2Ygb3VyIE5QTSBwYWNrYWdlXG4gICAgICogY29uc3QgbXlQYWNrYWdlVmVyc2lvbjogc3RyaW5nID0gUGFja2FnZUpzb25Mb29rdXAubG9hZE93blBhY2thZ2VKc29uKF9fZGlybmFtZSkudmVyc2lvbjtcbiAgICAgKiBjb25zb2xlLmxvZyhgQ29vbCBUb29sIC0gVmVyc2lvbiAke215UGFja2FnZVZlcnNpb259YCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlybmFtZU9mQ2FsbGVyIC0gVGhlIE5vZGVKUyBgX19kaXJuYW1lYCBtYWNybyBmb3IgdGhlIGNhbGxlci5cbiAgICAgKiBAcmV0dXJucyBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgYElQYWNrYWdlSnNvbmAgb2JqZWN0LiAgSWYgYW55IHByb2JsZW1zIGFyZSBlbmNvdW50ZXJlZCBkdXJpbmdcbiAgICAgKiBsb2FkaW5nLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9hZE93blBhY2thZ2VKc29uKGRpcm5hbWVPZkNhbGxlcikge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IFBhY2thZ2VKc29uTG9va3VwLl9sb2FkT3duUGFja2FnZUpzb25Mb29rdXBcbiAgICAgICAgICAgIC50cnlMb2FkUGFja2FnZUpzb25Gb3IoZGlybmFtZU9mQ2FsbGVyKTtcbiAgICAgICAgaWYgKHBhY2thZ2VKc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFja2FnZUpzb25Mb29rdXAubG9hZE93blBhY2thZ2VKc29uKCkgZmFpbGVkIHRvIGZpbmQgdGhlIGNhbGxlcidzIHBhY2thZ2UuanNvbi5gXG4gICAgICAgICAgICAgICAgKyBgICBUaGUgX19kaXJuYW1lIHdhczogJHtkaXJuYW1lT2ZDYWxsZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhY2thZ2VKc29uLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yUGF0aCA9IFBhY2thZ2VKc29uTG9va3VwLl9sb2FkT3duUGFja2FnZUpzb25Mb29rdXAudHJ5R2V0UGFja2FnZUpzb25GaWxlUGF0aEZvcihkaXJuYW1lT2ZDYWxsZXIpXG4gICAgICAgICAgICB8fCAncGFja2FnZS5qc29uJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYWNrYWdlSnNvbkxvb2t1cC5sb2FkT3duUGFja2FnZUpzb24oKSBmYWlsZWQgYmVjYXVzZSB0aGUgXCJ2ZXJzaW9uXCIgZmllbGQgaXMgbWlzc2luZyBpbmBcbiAgICAgICAgICAgICsgYCAke2Vycm9yUGF0aH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBmaWxlIGNhY2hlLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ2FsbCB0aGlzIG1ldGhvZCBpZiBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIHRvIHRoZSBwYWNrYWdlLmpzb24gZmlsZXMgb24gZGlzay5cbiAgICAgKi9cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLl9wYWNrYWdlRm9sZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VKc29uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIHBhdGggb2YgYSBmb2xkZXIgY29udGFpbmluZyBhIHBhY2thZ2UuanNvbiBmaWxlLCBieSBsb29raW5nXG4gICAgICogdXB3YXJkcyBmcm9tIHRoZSBzcGVjaWZpZWQgZmlsZU9yRm9sZGVyUGF0aC4gIElmIG5vIHBhY2thZ2UuanNvbiBjYW4gYmUgZm91bmQsXG4gICAgICogdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlsZU9yRm9sZGVyUGF0aCBpcyBub3QgcmVxdWlyZWQgdG8gYWN0dWFsbHkgZXhpc3Qgb24gZGlzay5cbiAgICAgKiBUaGUgZmlsZU9yRm9sZGVyUGF0aCBpdHNlbGYgY2FuIGJlIHRoZSByZXR1cm4gdmFsdWUsIGlmIGl0IGlzIGEgZm9sZGVyIGNvbnRhaW5pbmdcbiAgICAgKiBhIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgICAqIEJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGxvb2t1cCByZXN1bHRzIGFyZSBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZU9yRm9sZGVyUGF0aCAtIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgcGF0aCB0byBhIHNvdXJjZSBmaWxlIG9yIGZvbGRlclxuICAgICAqIHRoYXQgbWF5IGJlIHBhcnQgb2YgYSBwYWNrYWdlXG4gICAgICogQHJldHVybnMgYW4gYWJzb2x1dGUgcGF0aCB0byBhIGZvbGRlciBjb250YWluaW5nIGEgcGFja2FnZS5qc29uIGZpbGVcbiAgICAgKi9cbiAgICB0cnlHZXRQYWNrYWdlRm9sZGVyRm9yKGZpbGVPckZvbGRlclBhdGgpIHtcbiAgICAgICAgLy8gQ29udmVydCBpdCB0byBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRmlsZU9yRm9sZGVyUGF0aCA9IHBhdGgucmVzb2x2ZShmaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgLy8gT3B0aW1pc3RpY2FsbHkgaG9wZSB0aGF0IHRoZSBzdGFydGluZyBzdHJpbmcgaXMgYWxyZWFkeSBpbiB0aGUgY2FjaGUsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgY2FuIGF2b2lkIGRpc2sgYWNjZXNzIGVudGlyZWx5LlxuICAgICAgICAvL1xuICAgICAgICAvLyAoVHdvIGxvb2t1cHMgYXJlIHJlcXVpcmVkLCBiZWNhdXNlIGdldCgpIGNhbm5vdCBkaXN0aW5ndWlzaCB0aGUgdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgIC8vIHZlcnN1cyBhIG1pc3Npbmcga2V5LilcbiAgICAgICAgaWYgKHRoaXMuX3BhY2thZ2VGb2xkZXJDYWNoZS5oYXMocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VGb2xkZXJDYWNoZS5nZXQocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY2FsbCB0aGUgcmVjdXJzaXZlIHBhcnQgb2YgdGhlIGFsZ29yaXRobVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5R2V0UGFja2FnZUZvbGRlckZvcihyZXNvbHZlZEZpbGVPckZvbGRlclBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlY2lmaWVkIGZpbGUgb3IgZm9sZGVyIGlzIHBhcnQgb2YgYSBwYWNrYWdlLCB0aGlzIHJldHVybnMgdGhlIGFic29sdXRlIHBhdGhcbiAgICAgKiB0byB0aGUgYXNzb2NpYXRlZCBwYWNrYWdlLmpzb24gZmlsZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIHBhY2thZ2UgZm9sZGVyIGlzIGRldGVybWluZWQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtXG4gICAgICogYXMge0BsaW5rIFBhY2thZ2VKc29uTG9va3VwLnRyeUdldFBhY2thZ2VGb2xkZXJGb3J9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVPckZvbGRlclBhdGggLSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIHBhdGggdG8gYSBzb3VyY2UgZmlsZSBvciBmb2xkZXJcbiAgICAgKiB0aGF0IG1heSBiZSBwYXJ0IG9mIGEgcGFja2FnZVxuICAgICAqIEByZXR1cm5zIGFuIGFic29sdXRlIHBhdGggdG8gKiBwYWNrYWdlLmpzb24gZmlsZVxuICAgICAqL1xuICAgIHRyeUdldFBhY2thZ2VKc29uRmlsZVBhdGhGb3IoZmlsZU9yRm9sZGVyUGF0aCkge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbkZvbGRlciA9IHRoaXMudHJ5R2V0UGFja2FnZUZvbGRlckZvcihmaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgaWYgKCFwYWNrYWdlSnNvbkZvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHBhY2thZ2VKc29uRm9sZGVyLCBcInBhY2thZ2UuanNvblwiIC8qIFBhY2thZ2VKc29uICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHNwZWNpZmllZCBmaWxlIG9yIGZvbGRlciBpcyBwYXJ0IG9mIGEgcGFja2FnZSwgdGhpcyBsb2FkcyBhbmQgcmV0dXJucyB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgcGFja2FnZSBmb2xkZXIgaXMgZGV0ZXJtaW5lZCB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG1cbiAgICAgKiBhcyB7QGxpbmsgUGFja2FnZUpzb25Mb29rdXAudHJ5R2V0UGFja2FnZUZvbGRlckZvcn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZU9yRm9sZGVyUGF0aCAtIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgcGF0aCB0byBhIHNvdXJjZSBmaWxlIG9yIGZvbGRlclxuICAgICAqIHRoYXQgbWF5IGJlIHBhcnQgb2YgYSBwYWNrYWdlXG4gICAgICogQHJldHVybnMgYW4gSVBhY2thZ2VKc29uIG9iamVjdCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBmaWxlT3JGb2xkZXJQYXRoIGRvZXMgbm90XG4gICAgICogYmVsb25nIHRvIGEgcGFja2FnZVxuICAgICAqL1xuICAgIHRyeUxvYWRQYWNrYWdlSnNvbkZvcihmaWxlT3JGb2xkZXJQYXRoKSB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uRmlsZVBhdGggPSB0aGlzLnRyeUdldFBhY2thZ2VKc29uRmlsZVBhdGhGb3IoZmlsZU9yRm9sZGVyUGF0aCk7XG4gICAgICAgIGlmICghcGFja2FnZUpzb25GaWxlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkUGFja2FnZUpzb24ocGFja2FnZUpzb25GaWxlUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2ltaWxhciB0byB7QGxpbmsgUGFja2FnZUpzb25Mb29rdXAudHJ5TG9hZFBhY2thZ2VKc29uRm9yfSwgZXhjZXB0IHRoYXQgaXQgZG9lcyBub3QgcmVwb3J0XG4gICAgICogYW4gZXJyb3IgaWYgdGhlIGB2ZXJzaW9uYCBmaWVsZCBpcyBtaXNzaW5nIGZyb20gdGhlIHBhY2thZ2UuanNvbiBmaWxlLlxuICAgICAqL1xuICAgIHRyeUxvYWROb2RlUGFja2FnZUpzb25Gb3IoZmlsZU9yRm9sZGVyUGF0aCkge1xuICAgICAgICBjb25zdCBwYWNrYWdlSnNvbkZpbGVQYXRoID0gdGhpcy50cnlHZXRQYWNrYWdlSnNvbkZpbGVQYXRoRm9yKGZpbGVPckZvbGRlclBhdGgpO1xuICAgICAgICBpZiAoIXBhY2thZ2VKc29uRmlsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE5vZGVQYWNrYWdlSnNvbihwYWNrYWdlSnNvbkZpbGVQYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHNwZWNpZmllZCBwYWNrYWdlLmpzb24gZmlsZSwgaWYgaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFVubGVzcyB7QGxpbmsgSVBhY2thZ2VKc29uTG9va3VwUGFyYW1ldGVycy5sb2FkRXh0cmFGaWVsZHN9IHdhcyBzcGVjaWZpZWQsXG4gICAgICogdGhlIHJldHVybmVkIElQYWNrYWdlSnNvbiBvYmplY3Qgd2lsbCBjb250YWluIGEgc3Vic2V0IG9mIGVzc2VudGlhbCBmaWVsZHMuXG4gICAgICogVGhlIHJldHVybmVkIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBiZSBpbW11dGFibGU7IHRoZSBjYWxsZXIgbXVzdCBuZXZlclxuICAgICAqIG1vZGlmeSBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uRmlsZW5hbWUgLSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIHBhdGggdG8gYSBwYWNrYWdlLmpzb24gZmlsZVxuICAgICAqL1xuICAgIGxvYWRQYWNrYWdlSnNvbihqc29uRmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgcGFja2FnZUpzb24gPSB0aGlzLmxvYWROb2RlUGFja2FnZUpzb24oanNvbkZpbGVuYW1lKTtcbiAgICAgICAgaWYgKCFwYWNrYWdlSnNvbi52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHJlYWRpbmcgXCIke2pzb25GaWxlbmFtZX1cIjpcXG4gIGBcbiAgICAgICAgICAgICAgICArICdUaGUgcmVxdWlyZWQgZmllbGQgXCJ2ZXJzaW9uXCIgd2FzIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrYWdlSnNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIHtAbGluayBQYWNrYWdlSnNvbkxvb2t1cC5sb2FkUGFja2FnZUpzb259LCBleGNlcHQgdGhhdCBpdCBkb2VzIG5vdCByZXBvcnQgYW4gZXJyb3JcbiAgICAgKiBpZiB0aGUgYHZlcnNpb25gIGZpZWxkIGlzIG1pc3NpbmcgZnJvbSB0aGUgcGFja2FnZS5qc29uIGZpbGUuXG4gICAgICovXG4gICAgbG9hZE5vZGVQYWNrYWdlSnNvbihqc29uRmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKCFGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5leGlzdHMoanNvbkZpbGVuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBmaWxlIG5vdCBmb3VuZDogJHtqc29uRmlsZW5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyB3aWxsIGJlIGEgY2FjaGUga2V5LCBmb2xsb3cgYW55IHN5bWxpbmtzIGFuZCBnZXQgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAgICAvLyB0byBtaW5pbWl6ZSBkdXBsaWNhdGlvbi4gIChOb3RlIHRoYXQgZHVwbGljYXRpb24gY2FuIHN0aWxsIG9jY3VyIGR1ZSB0byBlLmcuIGNoYXJhY3RlciBjYXNlLilcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZpbGVQYXRoID0gRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0uZ2V0UmVhbFBhdGgoanNvbkZpbGVuYW1lKTtcbiAgICAgICAgbGV0IHBhY2thZ2VKc29uID0gdGhpcy5fcGFja2FnZUpzb25DYWNoZS5nZXQobm9ybWFsaXplZEZpbGVQYXRoKTtcbiAgICAgICAgaWYgKCFwYWNrYWdlSnNvbikge1xuICAgICAgICAgICAgY29uc3QgbG9hZGVkUGFja2FnZUpzb24gPSBKc29uRmlsZV8xLkpzb25GaWxlLmxvYWQobm9ybWFsaXplZEZpbGVQYXRoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlYWxseSBhIHBhY2thZ2UuanNvbiBmaWxlLiAgQ29tbW9uSlMgaGFzIGZhaXJseSBzdHJpY3QgcmVxdWlyZW1lbnRzLFxuICAgICAgICAgICAgLy8gYnV0IE5QTSBvbmx5IHJlcXVpcmVzIFwibmFtZVwiIGFuZCBcInZlcnNpb25cIlxuICAgICAgICAgICAgaWYgKCFsb2FkZWRQYWNrYWdlSnNvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIFwiJHtqc29uRmlsZW5hbWV9XCI6XFxuICBgXG4gICAgICAgICAgICAgICAgICAgICsgJ1RoZSByZXF1aXJlZCBmaWVsZCBcIm5hbWVcIiB3YXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZEV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24gPSBsb2FkZWRQYWNrYWdlSnNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhY2thZ2VKc29uID0ge307XG4gICAgICAgICAgICAgICAgLy8gVW5sZXNzIFwibG9hZEV4dHJhRmllbGRzXCIgd2FzIHJlcXVlc3RlZCwgY29weSBvdmVyIHRoZSBlc3NlbnRpYWwgZmllbGRzIG9ubHlcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi5iaW4gPSBsb2FkZWRQYWNrYWdlSnNvbi5iaW47XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24uZGVwZW5kZW5jaWVzID0gbG9hZGVkUGFja2FnZUpzb24uZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgICAgIHBhY2thZ2VKc29uLmRlc2NyaXB0aW9uID0gbG9hZGVkUGFja2FnZUpzb24uZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzID0gbG9hZGVkUGFja2FnZUpzb24uZGV2RGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgICAgIHBhY2thZ2VKc29uLmhvbWVwYWdlID0gbG9hZGVkUGFja2FnZUpzb24uaG9tZXBhZ2U7XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24ubGljZW5zZSA9IGxvYWRlZFBhY2thZ2VKc29uLmxpY2Vuc2U7XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24ubWFpbiA9IGxvYWRlZFBhY2thZ2VKc29uLm1haW47XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24ubmFtZSA9IGxvYWRlZFBhY2thZ2VKc29uLm5hbWU7XG4gICAgICAgICAgICAgICAgcGFja2FnZUpzb24ub3B0aW9uYWxEZXBlbmRlbmNpZXMgPSBsb2FkZWRQYWNrYWdlSnNvbi5vcHRpb25hbERlcGVuZGVuY2llcztcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi5wZWVyRGVwZW5kZW5jaWVzID0gbG9hZGVkUGFja2FnZUpzb24ucGVlckRlcGVuZGVuY2llcztcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi5wcml2YXRlID0gbG9hZGVkUGFja2FnZUpzb24ucHJpdmF0ZTtcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi5zY3JpcHRzID0gbG9hZGVkUGFja2FnZUpzb24uc2NyaXB0cztcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi50eXBpbmdzID0gbG9hZGVkUGFja2FnZUpzb24udHlwaW5ncyB8fCBsb2FkZWRQYWNrYWdlSnNvbi50eXBlcztcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi50c2RvY01ldGFkYXRhID0gbG9hZGVkUGFja2FnZUpzb24udHNkb2NNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi52ZXJzaW9uID0gbG9hZGVkUGFja2FnZUpzb24udmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUocGFja2FnZUpzb24pO1xuICAgICAgICAgICAgdGhpcy5fcGFja2FnZUpzb25DYWNoZS5zZXQobm9ybWFsaXplZEZpbGVQYXRoLCBwYWNrYWdlSnNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2thZ2VKc29uO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmUgcGFydCBvZiB0aGUgYWxnb3JpdGhtIGZyb20gdHJ5R2V0UGFja2FnZUZvbGRlckZvcigpXG4gICAgX3RyeUdldFBhY2thZ2VGb2xkZXJGb3IocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKSB7XG4gICAgICAgIC8vIFR3byBsb29rdXBzIGFyZSByZXF1aXJlZCwgYmVjYXVzZSBnZXQoKSBjYW5ub3QgZGlzdGluZ3Vpc2ggdGhlIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAvLyB2ZXJzdXMgYSBtaXNzaW5nIGtleS5cbiAgICAgICAgaWYgKHRoaXMuX3BhY2thZ2VGb2xkZXJDYWNoZS5oYXMocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VGb2xkZXJDYWNoZS5nZXQocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJcyByZXNvbHZlZEZpbGVPckZvbGRlclBhdGggaXRzZWxmIGEgZm9sZGVyIHdpdGggYSBwYWNrYWdlLmpzb24gZmlsZT8gIElmIHNvLCByZXR1cm4gaXQuXG4gICAgICAgIGlmIChGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5leGlzdHMocGF0aC5qb2luKHJlc29sdmVkRmlsZU9yRm9sZGVyUGF0aCwgXCJwYWNrYWdlLmpzb25cIiAvKiBQYWNrYWdlSnNvbiAqLykpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWNrYWdlRm9sZGVyQ2FjaGUuc2V0KHJlc29sdmVkRmlsZU9yRm9sZGVyUGF0aCwgcmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEZpbGVPckZvbGRlclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGdvIHVwIG9uZSBsZXZlbFxuICAgICAgICBjb25zdCBwYXJlbnRGb2xkZXIgPSBwYXRoLmRpcm5hbWUocmVzb2x2ZWRGaWxlT3JGb2xkZXJQYXRoKTtcbiAgICAgICAgaWYgKCFwYXJlbnRGb2xkZXIgfHwgcGFyZW50Rm9sZGVyID09PSByZXNvbHZlZEZpbGVPckZvbGRlclBhdGgpIHtcbiAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIHJvb3QgZGlyZWN0b3J5IHdpdGhvdXQgZmluZGluZyBhIHBhY2thZ2UuanNvbiBmaWxlLFxuICAgICAgICAgICAgLy8gc28gY2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5fcGFja2FnZUZvbGRlckNhY2hlLnNldChyZXNvbHZlZEZpbGVPckZvbGRlclBhdGgsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBubyBtYXRjaFxuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2UgdXB3YXJkcywgY2FjaGluZyBldmVyeSBzdGVwIGFsb25nIHRoZSB3YXlcbiAgICAgICAgY29uc3QgcGFyZW50UmVzdWx0ID0gdGhpcy5fdHJ5R2V0UGFja2FnZUZvbGRlckZvcihwYXJlbnRGb2xkZXIpO1xuICAgICAgICAvLyBDYWNoZSB0aGUgcGFyZW50J3MgYW5zd2VyIGFzIHdlbGxcbiAgICAgICAgdGhpcy5fcGFja2FnZUZvbGRlckNhY2hlLnNldChyZXNvbHZlZEZpbGVPckZvbGRlclBhdGgsIHBhcmVudFJlc3VsdCk7XG4gICAgICAgIHJldHVybiBwYXJlbnRSZXN1bHQ7XG4gICAgfVxufVxuUGFja2FnZUpzb25Mb29rdXAuX2xvYWRPd25QYWNrYWdlSnNvbkxvb2t1cCA9IG5ldyBQYWNrYWdlSnNvbkxvb2t1cCh7IGxvYWRFeHRyYUZpZWxkczogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFja2FnZUpzb25Mb29rdXAgPSBQYWNrYWdlSnNvbkxvb2t1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhY2thZ2VKc29uTG9va3VwLmpzLm1hcCJdfQ==