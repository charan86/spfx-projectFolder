165f8ca1d868fed5196f4c03c5af2fcb
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const child_process = require("child_process");
const timers_1 = require("timers");
const FileSystem_1 = require("./FileSystem");
const FileWriter_1 = require("./FileWriter");
/**
 * http://man7.org/linux/man-pages/man5/proc.5.html
 * (22) starttime  %llu
 * The time the process started after system boot. In kernels before Linux 2.6, this value was
 * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by
 * sysconf(_SC_CLK_TCK)).
 * The format for this field was %lu before Linux 2.6.
 */
const procStatStartTimePos = 22;
/**
 * Parses the process start time from the contents of a linux /proc/[pid]/stat file.
 * @param stat - The contents of a linux /proc/[pid]/stat file.
 * @returns The process start time in jiffies, or undefined if stat has an unexpected format.
 */
function getProcessStartTimeFromProcStat(stat) {
    // Parse the value at position procStatStartTimePos.
    // We cannot just split stat on spaces, because value 2 may contain spaces.
    // For example, when running the following Shell commands:
    // > cp "$(which bash)" ./'bash 2)('
    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'
    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0
    // > rm -rf ./'bash 2)('
    // The output shows a stat file such that value 2 contains spaces.
    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...
    // trimRight to remove the trailing line terminator.
    let values = stat.trimRight().split(' ');
    let i = values.length - 1;
    while (i >= 0 &&
    // charAt returns an empty string if the index is out of bounds.
    values[i].charAt(values[i].length - 1) !== ')') {
        i -= 1;
    }
    // i is the index of the last part of the second value (but i need not be 1).
    if (i < 1) {
        // Format of stat has changed.
        return undefined;
    }
    const value2 = values.slice(1, i + 1).join(' ');
    values = [values[0], value2].concat(values.slice(i + 1));
    if (values.length < procStatStartTimePos) {
        // Older version of linux, or non-standard configuration of linux.
        return undefined;
    }
    const startTimeJiffies = values[procStatStartTimePos - 1];
    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change
    // while the system is running, but we assume this does not happen.
    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing
    // accross reboots).
    return startTimeJiffies;
}
exports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;
/**
 * Helper function that is exported for unit tests only.
 * Returns undefined if the process doesn't exist with that pid.
 */
function getProcessStartTime(pid) {
    const pidString = pid.toString();
    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {
        throw new Error(`"pid" is negative or too large`);
    }
    let args;
    if (process.platform === 'darwin') {
        args = [`-p ${pidString}`, '-o lstart'];
    } else if (process.platform === 'linux') {
        args = ['-p', pidString, '-o', 'lstart'];
    } else {
        throw new Error(`Unsupported system: ${process.platform}`);
    }
    const psResult = child_process.spawnSync('ps', args, {
        encoding: 'utf8'
    });
    const psStdout = psResult.stdout;
    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.
    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process
    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if
    // zero bytes are written to stdout.
    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {
        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.
        let stat;
        try {
            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);
        } catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.
            // We assume the former.
            return undefined;
        }
        if (stat !== undefined) {
            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);
            if (startTimeJiffies === undefined) {
                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the ` + `contents of /proc/${pidString}/stat have an unexpected format`);
            }
            return startTimeJiffies;
        }
    }
    // there was an error executing ps (zero bytes were written to stdout).
    if (!psStdout) {
        throw new Error(`Unexpected output from "ps" command`);
    }
    const psSplit = psStdout.split('\n');
    // successfuly able to run "ps", but no process was found
    if (psSplit[1] === '') {
        return undefined;
    }
    if (psSplit[1]) {
        const trimmed = psSplit[1].trim();
        if (trimmed.length > 10) {
            return trimmed;
        }
    }
    throw new Error(`Unexpected output from the "ps" command`);
}
exports.getProcessStartTime = getProcessStartTime;
/**
 * A helper utility for working with file-based locks.
 * This class should only be used for locking resources across processes,
 * but should not be used for attempting to lock a resource in the same process.
 * @public
 */
class LockFile {
    constructor(_fileWriter, _filePath, _dirtyWhenAcquired) {
        this._fileWriter = _fileWriter;
        this._filePath = _filePath;
        this._dirtyWhenAcquired = _dirtyWhenAcquired;
    }
    /**
     * Returns the path to the lockfile, should it be created successfully.
     */
    static getLockFilePath(resourceDir, resourceName, pid = process.pid) {
        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {
            throw new Error(`The resource name "${resourceName}" is invalid.` + ` It must be an alphanumberic string with only "-" or "." It must start with an alphanumeric character.`);
        }
        if (process.platform === 'win32') {
            return path.join(path.resolve(resourceDir), `${resourceName}.lock`);
        } else if (process.platform === 'linux' || process.platform === 'darwin') {
            return path.join(path.resolve(resourceDir), `${resourceName}#${pid}.lock`);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create a lockfile with the given filePath.
     * If successful, returns a LockFile instance.
     * If unable to get a lock, returns undefined.
     * @param resourceName - the name of the resource we are locking on. Should be an alphabetic string.
     */
    static tryAcquire(resourceDir, resourceName) {
        FileSystem_1.FileSystem.ensureFolder(resourceDir);
        if (process.platform === 'win32') {
            return LockFile._tryAcquireWindows(resourceDir, resourceName);
        } else if (process.platform === 'linux' || process.platform === 'darwin') {
            return LockFile._tryAcquireMacOrLinux(resourceDir, resourceName);
        }
        throw new Error(`File locking not implemented for platform: "${process.platform}"`);
    }
    /**
     * Attempts to create the lockfile.
     * Will continue to loop at every 100ms until the lock becomes available or the maxWaitMs is surpassed.
     * @remarks This function is subject to starvation, whereby it does not ensure that the process that has been
     *          waiting the longest to acquire the lock will get it first. This means that a process could theoretically
     *          wait for the lock forever, while other processes skipped it in line and acquired the lock first.
     */
    static acquire(resourceDir, resourceName, maxWaitMs) {
        const interval = 100;
        const startTime = Date.now();
        const retryLoop = () => {
            const lock = LockFile.tryAcquire(resourceDir, resourceName);
            if (lock) {
                return Promise.resolve(lock);
            }
            if (maxWaitMs && Date.now() > startTime + maxWaitMs) {
                return Promise.reject(new Error(`Exceeded maximum wait time to acquire lock for resource "${resourceName}"`));
            }
            return LockFile._sleepForMs(interval).then(() => {
                return retryLoop();
            });
        };
        return retryLoop();
    }
    static _sleepForMs(timeout) {
        return new Promise((resolve, reject) => {
            timers_1.setTimeout(() => {
                resolve();
            }, timeout);
        });
    }
    /**
     * Attempts to acquire the lock on a Linux or OSX machine
     */
    static _tryAcquireMacOrLinux(resourceDir, resourceName) {
        let dirtyWhenAcquired = false;
        // get the current process' pid
        const pid = process.pid;
        const startTime = LockFile._getStartTime(pid);
        if (!startTime) {
            throw new Error(`Unable to calculate start time for current process.`);
        }
        const pidLockFilePath = LockFile.getLockFilePath(resourceDir, resourceName);
        let lockFileHandle;
        let lockFile;
        try {
            // open in write mode since if this file exists, it cannot be from the current process
            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.
            // We should ideally maintain a dictionary of normalized acquired filenames
            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);
            lockFileHandle.write(startTime);
            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();
            let smallestBirthTimeMs = currentBirthTimeMs;
            let smallestBirthTimePid = pid.toString();
            // now, scan the directory for all lockfiles
            const files = FileSystem_1.FileSystem.readFolder(resourceDir);
            // look for anything ending with # then numbers and ".lock"
            const lockFileRegExp = /^(.+)#([0-9]+)\.lock$/;
            let match;
            let otherPid;
            for (const fileInFolder of files) {
                if ((match = fileInFolder.match(lockFileRegExp)) && match[1] === resourceName && (otherPid = match[2]) !== pid.toString()) {
                    // we found at least one lockfile hanging around that isn't ours
                    const fileInFolderPath = path.join(resourceDir, fileInFolder);
                    dirtyWhenAcquired = true;
                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);
                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));
                    let otherPidOldStartTime;
                    let otherBirthtimeMs;
                    try {
                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);
                        // check the timestamp of the file
                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();
                    } catch (err) {}
                    // this means the file is probably deleted already

                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,
                    // if this file was created after us, ignore it
                    // if it was created within 1 second before us, then it could be good, so we
                    //  will conservatively fail
                    // otherwise it is an old lock file and will be deleted
                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {
                        if (otherBirthtimeMs > currentBirthTimeMs) {
                            // ignore this file, he will be unable to get the lock since this process
                            // will hold it
                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);
                            continue;
                        } else if (otherBirthtimeMs - currentBirthTimeMs < 0 // it was created before us AND
                        && otherBirthtimeMs - currentBirthTimeMs > -1000) {
                            // it was created less than a second before
                            // conservatively be unable to keep the lock
                            return undefined;
                        }
                    }
                    // console.log(`Other pid ${otherPid} lockfile has start time: "${otherPidOldStartTime}"`);
                    // console.log(`Other pid ${otherPid} actually has start time: "${otherPidCurrentStartTime}"`);
                    // this means the process is no longer executing, delete the file
                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {
                        // console.log(`Other pid ${otherPid} is no longer executing!`);
                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);
                        continue;
                    }
                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);
                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);
                    // this is a lockfile pointing at something valid
                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {
                        smallestBirthTimeMs = otherBirthtimeMs;
                        smallestBirthTimePid = otherPid;
                    }
                }
            }
            if (smallestBirthTimePid !== pid.toString()) {
                // we do not have the lock
                return undefined;
            }
            // we have the lock!
            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);
            lockFileHandle = undefined; // we have handed the descriptor off to the instance
        } finally {
            if (lockFileHandle) {
                // ensure our lock is closed
                lockFileHandle.close();
                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);
            }
        }
        return lockFile;
    }
    /**
     * Attempts to acquire the lock using Windows
     * This algorithm is much simpler since we can rely on the operating system
     */
    static _tryAcquireWindows(resourceDir, resourceName) {
        const lockFilePath = LockFile.getLockFilePath(resourceDir, resourceName);
        let dirtyWhenAcquired = false;
        let fileHandle;
        let lockFile;
        try {
            if (FileSystem_1.FileSystem.exists(lockFilePath)) {
                dirtyWhenAcquired = true;
                // If the lockfile is held by an process with an exclusive lock, then removing it will
                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.
                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that
                // the last process to hold it died.
                FileSystem_1.FileSystem.deleteFile(lockFilePath);
            }
            try {
                // Attempt to open an exclusive lockfile
                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });
            } catch (error) {
                // we tried to delete the lock, but something else is holding it,
                // (probably an active process), therefore we are unable to create a lock
                return undefined;
            }
            // Ensure we can hand off the file descriptor to the lockfile
            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);
            fileHandle = undefined;
        } finally {
            if (fileHandle) {
                fileHandle.close();
            }
        }
        return lockFile;
    }
    /**
     * Unlocks a file and removes it from disk.
     * This can only be called once.
     */
    release() {
        if (this.isReleased) {
            throw new Error(`The lock for file "${path.basename(this._filePath)}" has already been released.`);
        }
        this._fileWriter.close();
        FileSystem_1.FileSystem.deleteFile(this._filePath);
        this._fileWriter = undefined;
    }
    /**
     * Returns the initial state of the lock.
     * This can be used to detect if the previous process was terminated before releasing the resource.
     */
    get dirtyWhenAcquired() {
        return this._dirtyWhenAcquired;
    }
    /**
     * Returns the absolute path to the lockfile
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * Returns true if this lock is currently being held.
     */
    get isReleased() {
        return this._fileWriter === undefined;
    }
}
LockFile._getStartTime = getProcessStartTime;
exports.LockFile = LockFile;
//# sourceMappingURL=LockFile.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxvY2tGaWxlLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGF0aCIsInJlcXVpcmUiLCJjaGlsZF9wcm9jZXNzIiwidGltZXJzXzEiLCJGaWxlU3lzdGVtXzEiLCJGaWxlV3JpdGVyXzEiLCJwcm9jU3RhdFN0YXJ0VGltZVBvcyIsImdldFByb2Nlc3NTdGFydFRpbWVGcm9tUHJvY1N0YXQiLCJzdGF0IiwidmFsdWVzIiwidHJpbVJpZ2h0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwiY2hhckF0IiwidW5kZWZpbmVkIiwidmFsdWUyIiwic2xpY2UiLCJqb2luIiwiY29uY2F0Iiwic3RhcnRUaW1lSmlmZmllcyIsImdldFByb2Nlc3NTdGFydFRpbWUiLCJwaWQiLCJwaWRTdHJpbmciLCJ0b1N0cmluZyIsImluZGV4T2YiLCJFcnJvciIsImFyZ3MiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJwc1Jlc3VsdCIsInNwYXduU3luYyIsImVuY29kaW5nIiwicHNTdGRvdXQiLCJzdGRvdXQiLCJzdGF0dXMiLCJGaWxlU3lzdGVtIiwicmVhZEZpbGUiLCJlcnJvciIsImNvZGUiLCJwc1NwbGl0IiwidHJpbW1lZCIsInRyaW0iLCJMb2NrRmlsZSIsImNvbnN0cnVjdG9yIiwiX2ZpbGVXcml0ZXIiLCJfZmlsZVBhdGgiLCJfZGlydHlXaGVuQWNxdWlyZWQiLCJnZXRMb2NrRmlsZVBhdGgiLCJyZXNvdXJjZURpciIsInJlc291cmNlTmFtZSIsIm1hdGNoIiwicmVzb2x2ZSIsInRyeUFjcXVpcmUiLCJlbnN1cmVGb2xkZXIiLCJfdHJ5QWNxdWlyZVdpbmRvd3MiLCJfdHJ5QWNxdWlyZU1hY09yTGludXgiLCJhY3F1aXJlIiwibWF4V2FpdE1zIiwiaW50ZXJ2YWwiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwicmV0cnlMb29wIiwibG9jayIsIlByb21pc2UiLCJyZWplY3QiLCJfc2xlZXBGb3JNcyIsInRoZW4iLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImRpcnR5V2hlbkFjcXVpcmVkIiwiX2dldFN0YXJ0VGltZSIsInBpZExvY2tGaWxlUGF0aCIsImxvY2tGaWxlSGFuZGxlIiwibG9ja0ZpbGUiLCJGaWxlV3JpdGVyIiwib3BlbiIsIndyaXRlIiwiY3VycmVudEJpcnRoVGltZU1zIiwiZ2V0U3RhdGlzdGljcyIsImJpcnRodGltZSIsImdldFRpbWUiLCJzbWFsbGVzdEJpcnRoVGltZU1zIiwic21hbGxlc3RCaXJ0aFRpbWVQaWQiLCJmaWxlcyIsInJlYWRGb2xkZXIiLCJsb2NrRmlsZVJlZ0V4cCIsIm90aGVyUGlkIiwiZmlsZUluRm9sZGVyIiwiZmlsZUluRm9sZGVyUGF0aCIsIm90aGVyUGlkQ3VycmVudFN0YXJ0VGltZSIsInBhcnNlSW50Iiwib3RoZXJQaWRPbGRTdGFydFRpbWUiLCJvdGhlckJpcnRodGltZU1zIiwiZXJyIiwiZGVsZXRlRmlsZSIsImNsb3NlIiwibG9ja0ZpbGVQYXRoIiwiZmlsZUhhbmRsZSIsImV4aXN0cyIsImV4Y2x1c2l2ZSIsInJlbGVhc2UiLCJpc1JlbGVhc2VkIiwiYmFzZW5hbWUiLCJmaWxlUGF0aCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQSxNQUFNQyxPQUFPQyxRQUFRLE1BQVIsQ0FBYjtBQUNBLE1BQU1DLGdCQUFnQkQsUUFBUSxlQUFSLENBQXRCO0FBQ0EsTUFBTUUsV0FBV0YsUUFBUSxRQUFSLENBQWpCO0FBQ0EsTUFBTUcsZUFBZUgsUUFBUSxjQUFSLENBQXJCO0FBQ0EsTUFBTUksZUFBZUosUUFBUSxjQUFSLENBQXJCO0FBQ0E7Ozs7Ozs7O0FBUUEsTUFBTUssdUJBQXVCLEVBQTdCO0FBQ0E7Ozs7O0FBS0EsU0FBU0MsK0JBQVQsQ0FBeUNDLElBQXpDLEVBQStDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSUMsU0FBU0QsS0FBS0UsU0FBTCxHQUFpQkMsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBYjtBQUNBLFFBQUlDLElBQUlILE9BQU9JLE1BQVAsR0FBZ0IsQ0FBeEI7QUFDQSxXQUFPRCxLQUFLLENBQUw7QUFDSDtBQUNBSCxXQUFPRyxDQUFQLEVBQVVFLE1BQVYsQ0FBaUJMLE9BQU9HLENBQVAsRUFBVUMsTUFBVixHQUFtQixDQUFwQyxNQUEyQyxHQUYvQyxFQUVvRDtBQUNoREQsYUFBSyxDQUFMO0FBQ0g7QUFDRDtBQUNBLFFBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1A7QUFDQSxlQUFPRyxTQUFQO0FBQ0g7QUFDRCxVQUFNQyxTQUFTUCxPQUFPUSxLQUFQLENBQWEsQ0FBYixFQUFnQkwsSUFBSSxDQUFwQixFQUF1Qk0sSUFBdkIsQ0FBNEIsR0FBNUIsQ0FBZjtBQUNBVCxhQUFTLENBQUNBLE9BQU8sQ0FBUCxDQUFELEVBQVlPLE1BQVosRUFBb0JHLE1BQXBCLENBQTJCVixPQUFPUSxLQUFQLENBQWFMLElBQUksQ0FBakIsQ0FBM0IsQ0FBVDtBQUNBLFFBQUlILE9BQU9JLE1BQVAsR0FBZ0JQLG9CQUFwQixFQUEwQztBQUN0QztBQUNBLGVBQU9TLFNBQVA7QUFDSDtBQUNELFVBQU1LLG1CQUFtQlgsT0FBT0gsdUJBQXVCLENBQTlCLENBQXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPYyxnQkFBUDtBQUNIO0FBQ0R0QixRQUFRUywrQkFBUixHQUEwQ0EsK0JBQTFDO0FBQ0E7Ozs7QUFJQSxTQUFTYyxtQkFBVCxDQUE2QkMsR0FBN0IsRUFBa0M7QUFDOUIsVUFBTUMsWUFBWUQsSUFBSUUsUUFBSixFQUFsQjtBQUNBLFFBQUlGLE1BQU0sQ0FBTixJQUFXQyxVQUFVRSxPQUFWLENBQWtCLEdBQWxCLEtBQTBCLENBQXJDLElBQTBDRixVQUFVRSxPQUFWLENBQWtCLEdBQWxCLEtBQTBCLENBQXhFLEVBQTJFO0FBQ3ZFLGNBQU0sSUFBSUMsS0FBSixDQUFXLGdDQUFYLENBQU47QUFDSDtBQUNELFFBQUlDLElBQUo7QUFDQSxRQUFJQyxRQUFRQyxRQUFSLEtBQXFCLFFBQXpCLEVBQW1DO0FBQy9CRixlQUFPLENBQUUsTUFBS0osU0FBVSxFQUFqQixFQUFvQixXQUFwQixDQUFQO0FBQ0gsS0FGRCxNQUdLLElBQUlLLFFBQVFDLFFBQVIsS0FBcUIsT0FBekIsRUFBa0M7QUFDbkNGLGVBQU8sQ0FBQyxJQUFELEVBQU9KLFNBQVAsRUFBa0IsSUFBbEIsRUFBd0IsUUFBeEIsQ0FBUDtBQUNILEtBRkksTUFHQTtBQUNELGNBQU0sSUFBSUcsS0FBSixDQUFXLHVCQUFzQkUsUUFBUUMsUUFBUyxFQUFsRCxDQUFOO0FBQ0g7QUFDRCxVQUFNQyxXQUFXNUIsY0FBYzZCLFNBQWQsQ0FBd0IsSUFBeEIsRUFBOEJKLElBQTlCLEVBQW9DO0FBQ2pESyxrQkFBVTtBQUR1QyxLQUFwQyxDQUFqQjtBQUdBLFVBQU1DLFdBQVdILFNBQVNJLE1BQTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJSixTQUFTSyxNQUFULEtBQW9CLENBQXBCLElBQXlCLENBQUNGLFFBQTFCLElBQXNDTCxRQUFRQyxRQUFSLEtBQXFCLE9BQS9ELEVBQXdFO0FBQ3BFO0FBQ0EsWUFBSXJCLElBQUo7QUFDQSxZQUFJO0FBQ0FBLG1CQUFPSixhQUFhZ0MsVUFBYixDQUF3QkMsUUFBeEIsQ0FBa0MsU0FBUWQsU0FBVSxPQUFwRCxDQUFQO0FBQ0gsU0FGRCxDQUdBLE9BQU9lLEtBQVAsRUFBYztBQUNWLGdCQUFJQSxNQUFNQyxJQUFOLEtBQWUsUUFBbkIsRUFBNkI7QUFDekIsc0JBQU1ELEtBQU47QUFDSDtBQUNEO0FBQ0E7QUFDQSxtQkFBT3ZCLFNBQVA7QUFDSDtBQUNELFlBQUlQLFNBQVNPLFNBQWIsRUFBd0I7QUFDcEIsa0JBQU1LLG1CQUFtQmIsZ0NBQWdDQyxJQUFoQyxDQUF6QjtBQUNBLGdCQUFJWSxxQkFBcUJMLFNBQXpCLEVBQW9DO0FBQ2hDLHNCQUFNLElBQUlXLEtBQUosQ0FBVyxnREFBK0NILFNBQVUsMkJBQTFELEdBQ1QscUJBQW9CQSxTQUFVLGlDQUQvQixDQUFOO0FBRUg7QUFDRCxtQkFBT0gsZ0JBQVA7QUFDSDtBQUNKO0FBQ0Q7QUFDQSxRQUFJLENBQUNhLFFBQUwsRUFBZTtBQUNYLGNBQU0sSUFBSVAsS0FBSixDQUFXLHFDQUFYLENBQU47QUFDSDtBQUNELFVBQU1jLFVBQVVQLFNBQVN0QixLQUFULENBQWUsSUFBZixDQUFoQjtBQUNBO0FBQ0EsUUFBSTZCLFFBQVEsQ0FBUixNQUFlLEVBQW5CLEVBQXVCO0FBQ25CLGVBQU96QixTQUFQO0FBQ0g7QUFDRCxRQUFJeUIsUUFBUSxDQUFSLENBQUosRUFBZ0I7QUFDWixjQUFNQyxVQUFVRCxRQUFRLENBQVIsRUFBV0UsSUFBWCxFQUFoQjtBQUNBLFlBQUlELFFBQVE1QixNQUFSLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3JCLG1CQUFPNEIsT0FBUDtBQUNIO0FBQ0o7QUFDRCxVQUFNLElBQUlmLEtBQUosQ0FBVyx5Q0FBWCxDQUFOO0FBQ0g7QUFDRDVCLFFBQVF1QixtQkFBUixHQUE4QkEsbUJBQTlCO0FBQ0E7Ozs7OztBQU1BLE1BQU1zQixRQUFOLENBQWU7QUFDWEMsZ0JBQVlDLFdBQVosRUFBeUJDLFNBQXpCLEVBQW9DQyxrQkFBcEMsRUFBd0Q7QUFDcEQsYUFBS0YsV0FBTCxHQUFtQkEsV0FBbkI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLGFBQUtDLGtCQUFMLEdBQTBCQSxrQkFBMUI7QUFDSDtBQUNEOzs7QUFHQSxXQUFPQyxlQUFQLENBQXVCQyxXQUF2QixFQUFvQ0MsWUFBcEMsRUFBa0Q1QixNQUFNTSxRQUFRTixHQUFoRSxFQUFxRTtBQUNqRSxZQUFJLENBQUM0QixhQUFhQyxLQUFiLENBQW1CLHdDQUFuQixDQUFMLEVBQW1FO0FBQy9ELGtCQUFNLElBQUl6QixLQUFKLENBQVcsc0JBQXFCd0IsWUFBYSxlQUFuQyxHQUNULHdHQURELENBQU47QUFFSDtBQUNELFlBQUl0QixRQUFRQyxRQUFSLEtBQXFCLE9BQXpCLEVBQWtDO0FBQzlCLG1CQUFPN0IsS0FBS2tCLElBQUwsQ0FBVWxCLEtBQUtvRCxPQUFMLENBQWFILFdBQWIsQ0FBVixFQUFzQyxHQUFFQyxZQUFhLE9BQXJELENBQVA7QUFDSCxTQUZELE1BR0ssSUFBSXRCLFFBQVFDLFFBQVIsS0FBcUIsT0FBckIsSUFBZ0NELFFBQVFDLFFBQVIsS0FBcUIsUUFBekQsRUFBbUU7QUFDcEUsbUJBQU83QixLQUFLa0IsSUFBTCxDQUFVbEIsS0FBS29ELE9BQUwsQ0FBYUgsV0FBYixDQUFWLEVBQXNDLEdBQUVDLFlBQWEsSUFBRzVCLEdBQUksT0FBNUQsQ0FBUDtBQUNIO0FBQ0QsY0FBTSxJQUFJSSxLQUFKLENBQVcsK0NBQThDRSxRQUFRQyxRQUFTLEdBQTFFLENBQU47QUFDSDtBQUNEOzs7Ozs7QUFNQSxXQUFPd0IsVUFBUCxDQUFrQkosV0FBbEIsRUFBK0JDLFlBQS9CLEVBQTZDO0FBQ3pDOUMscUJBQWFnQyxVQUFiLENBQXdCa0IsWUFBeEIsQ0FBcUNMLFdBQXJDO0FBQ0EsWUFBSXJCLFFBQVFDLFFBQVIsS0FBcUIsT0FBekIsRUFBa0M7QUFDOUIsbUJBQU9jLFNBQVNZLGtCQUFULENBQTRCTixXQUE1QixFQUF5Q0MsWUFBekMsQ0FBUDtBQUNILFNBRkQsTUFHSyxJQUFJdEIsUUFBUUMsUUFBUixLQUFxQixPQUFyQixJQUFnQ0QsUUFBUUMsUUFBUixLQUFxQixRQUF6RCxFQUFtRTtBQUNwRSxtQkFBT2MsU0FBU2EscUJBQVQsQ0FBK0JQLFdBQS9CLEVBQTRDQyxZQUE1QyxDQUFQO0FBQ0g7QUFDRCxjQUFNLElBQUl4QixLQUFKLENBQVcsK0NBQThDRSxRQUFRQyxRQUFTLEdBQTFFLENBQU47QUFDSDtBQUNEOzs7Ozs7O0FBT0EsV0FBTzRCLE9BQVAsQ0FBZVIsV0FBZixFQUE0QkMsWUFBNUIsRUFBMENRLFNBQTFDLEVBQXFEO0FBQ2pELGNBQU1DLFdBQVcsR0FBakI7QUFDQSxjQUFNQyxZQUFZQyxLQUFLQyxHQUFMLEVBQWxCO0FBQ0EsY0FBTUMsWUFBWSxNQUFNO0FBQ3BCLGtCQUFNQyxPQUFPckIsU0FBU1UsVUFBVCxDQUFvQkosV0FBcEIsRUFBaUNDLFlBQWpDLENBQWI7QUFDQSxnQkFBSWMsSUFBSixFQUFVO0FBQ04sdUJBQU9DLFFBQVFiLE9BQVIsQ0FBZ0JZLElBQWhCLENBQVA7QUFDSDtBQUNELGdCQUFJTixhQUFjRyxLQUFLQyxHQUFMLEtBQWFGLFlBQVlGLFNBQTNDLEVBQXVEO0FBQ25ELHVCQUFPTyxRQUFRQyxNQUFSLENBQWUsSUFBSXhDLEtBQUosQ0FBVyw0REFBMkR3QixZQUFhLEdBQW5GLENBQWYsQ0FBUDtBQUNIO0FBQ0QsbUJBQU9QLFNBQVN3QixXQUFULENBQXFCUixRQUFyQixFQUErQlMsSUFBL0IsQ0FBb0MsTUFBTTtBQUM3Qyx1QkFBT0wsV0FBUDtBQUNILGFBRk0sQ0FBUDtBQUdILFNBWEQ7QUFZQSxlQUFPQSxXQUFQO0FBQ0g7QUFDRCxXQUFPSSxXQUFQLENBQW1CRSxPQUFuQixFQUE0QjtBQUN4QixlQUFPLElBQUlKLE9BQUosQ0FBWSxDQUFDYixPQUFELEVBQVVjLE1BQVYsS0FBcUI7QUFDcEMvRCxxQkFBU21FLFVBQVQsQ0FBb0IsTUFBTTtBQUN0QmxCO0FBQ0gsYUFGRCxFQUVHaUIsT0FGSDtBQUdILFNBSk0sQ0FBUDtBQUtIO0FBQ0Q7OztBQUdBLFdBQU9iLHFCQUFQLENBQTZCUCxXQUE3QixFQUEwQ0MsWUFBMUMsRUFBd0Q7QUFDcEQsWUFBSXFCLG9CQUFvQixLQUF4QjtBQUNBO0FBQ0EsY0FBTWpELE1BQU1NLFFBQVFOLEdBQXBCO0FBQ0EsY0FBTXNDLFlBQVlqQixTQUFTNkIsYUFBVCxDQUF1QmxELEdBQXZCLENBQWxCO0FBQ0EsWUFBSSxDQUFDc0MsU0FBTCxFQUFnQjtBQUNaLGtCQUFNLElBQUlsQyxLQUFKLENBQVcscURBQVgsQ0FBTjtBQUNIO0FBQ0QsY0FBTStDLGtCQUFrQjlCLFNBQVNLLGVBQVQsQ0FBeUJDLFdBQXpCLEVBQXNDQyxZQUF0QyxDQUF4QjtBQUNBLFlBQUl3QixjQUFKO0FBQ0EsWUFBSUMsUUFBSjtBQUNBLFlBQUk7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsNkJBQWlCckUsYUFBYXVFLFVBQWIsQ0FBd0JDLElBQXhCLENBQTZCSixlQUE3QixDQUFqQjtBQUNBQywyQkFBZUksS0FBZixDQUFxQmxCLFNBQXJCO0FBQ0Esa0JBQU1tQixxQkFBcUIzRSxhQUFhZ0MsVUFBYixDQUF3QjRDLGFBQXhCLENBQXNDUCxlQUF0QyxFQUF1RFEsU0FBdkQsQ0FBaUVDLE9BQWpFLEVBQTNCO0FBQ0EsZ0JBQUlDLHNCQUFzQkosa0JBQTFCO0FBQ0EsZ0JBQUlLLHVCQUF1QjlELElBQUlFLFFBQUosRUFBM0I7QUFDQTtBQUNBLGtCQUFNNkQsUUFBUWpGLGFBQWFnQyxVQUFiLENBQXdCa0QsVUFBeEIsQ0FBbUNyQyxXQUFuQyxDQUFkO0FBQ0E7QUFDQSxrQkFBTXNDLGlCQUFpQix1QkFBdkI7QUFDQSxnQkFBSXBDLEtBQUo7QUFDQSxnQkFBSXFDLFFBQUo7QUFDQSxpQkFBSyxNQUFNQyxZQUFYLElBQTJCSixLQUEzQixFQUFrQztBQUM5QixvQkFBSSxDQUFDbEMsUUFBUXNDLGFBQWF0QyxLQUFiLENBQW1Cb0MsY0FBbkIsQ0FBVCxLQUNJcEMsTUFBTSxDQUFOLE1BQWFELFlBRGpCLElBRUksQ0FBQ3NDLFdBQVdyQyxNQUFNLENBQU4sQ0FBWixNQUEwQjdCLElBQUlFLFFBQUosRUFGbEMsRUFFbUQ7QUFDL0M7QUFDQSwwQkFBTWtFLG1CQUFtQjFGLEtBQUtrQixJQUFMLENBQVUrQixXQUFWLEVBQXVCd0MsWUFBdkIsQ0FBekI7QUFDQWxCLHdDQUFvQixJQUFwQjtBQUNBO0FBQ0EsMEJBQU1vQiwyQkFBMkJoRCxTQUFTNkIsYUFBVCxDQUF1Qm9CLFNBQVNKLFFBQVQsRUFBbUIsRUFBbkIsQ0FBdkIsQ0FBakM7QUFDQSx3QkFBSUssb0JBQUo7QUFDQSx3QkFBSUMsZ0JBQUo7QUFDQSx3QkFBSTtBQUNBRCwrQ0FBdUJ6RixhQUFhZ0MsVUFBYixDQUF3QkMsUUFBeEIsQ0FBaUNxRCxnQkFBakMsQ0FBdkI7QUFDQTtBQUNBSSwyQ0FBbUIxRixhQUFhZ0MsVUFBYixDQUF3QjRDLGFBQXhCLENBQXNDVSxnQkFBdEMsRUFBd0RULFNBQXhELENBQWtFQyxPQUFsRSxFQUFuQjtBQUNILHFCQUpELENBS0EsT0FBT2EsR0FBUCxFQUFZLENBRVg7QUFERzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQUlGLHlCQUF5QixFQUF6QixJQUErQkMscUJBQXFCL0UsU0FBeEQsRUFBbUU7QUFDL0QsNEJBQUkrRSxtQkFBbUJmLGtCQUF2QixFQUEyQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNILHlCQUxELE1BTUssSUFBSWUsbUJBQW1CZixrQkFBbkIsR0FBd0MsQ0FBeEMsQ0FBMEM7QUFBMUMsMkJBQ0ZlLG1CQUFtQmYsa0JBQW5CLEdBQXdDLENBQUMsSUFEM0MsRUFDaUQ7QUFBRTtBQUNwRDtBQUNBLG1DQUFPaEUsU0FBUDtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3QkFBSSxDQUFDNEUsd0JBQUQsSUFBNkJFLHlCQUF5QkYsd0JBQTFELEVBQW9GO0FBQ2hGO0FBQ0F2RixxQ0FBYWdDLFVBQWIsQ0FBd0I0RCxVQUF4QixDQUFtQ04sZ0JBQW5DO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBLHdCQUFJSSxxQkFBcUIvRSxTQUFyQixJQUFrQytFLG1CQUFtQlgsbUJBQXpELEVBQThFO0FBQzFFQSw4Q0FBc0JXLGdCQUF0QjtBQUNBViwrQ0FBdUJJLFFBQXZCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZ0JBQUlKLHlCQUF5QjlELElBQUlFLFFBQUosRUFBN0IsRUFBNkM7QUFDekM7QUFDQSx1QkFBT1QsU0FBUDtBQUNIO0FBQ0Q7QUFDQTRELHVCQUFXLElBQUloQyxRQUFKLENBQWErQixjQUFiLEVBQTZCRCxlQUE3QixFQUE4Q0YsaUJBQTlDLENBQVg7QUFDQUcsNkJBQWlCM0QsU0FBakIsQ0EzRUEsQ0EyRTRCO0FBQy9CLFNBNUVELFNBNkVRO0FBQ0osZ0JBQUkyRCxjQUFKLEVBQW9CO0FBQ2hCO0FBQ0FBLCtCQUFldUIsS0FBZjtBQUNBN0YsNkJBQWFnQyxVQUFiLENBQXdCNEQsVUFBeEIsQ0FBbUN2QixlQUFuQztBQUNIO0FBQ0o7QUFDRCxlQUFPRSxRQUFQO0FBQ0g7QUFDRDs7OztBQUlBLFdBQU9wQixrQkFBUCxDQUEwQk4sV0FBMUIsRUFBdUNDLFlBQXZDLEVBQXFEO0FBQ2pELGNBQU1nRCxlQUFldkQsU0FBU0ssZUFBVCxDQUF5QkMsV0FBekIsRUFBc0NDLFlBQXRDLENBQXJCO0FBQ0EsWUFBSXFCLG9CQUFvQixLQUF4QjtBQUNBLFlBQUk0QixVQUFKO0FBQ0EsWUFBSXhCLFFBQUo7QUFDQSxZQUFJO0FBQ0EsZ0JBQUl2RSxhQUFhZ0MsVUFBYixDQUF3QmdFLE1BQXhCLENBQStCRixZQUEvQixDQUFKLEVBQWtEO0FBQzlDM0Isb0NBQW9CLElBQXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQW5FLDZCQUFhZ0MsVUFBYixDQUF3QjRELFVBQXhCLENBQW1DRSxZQUFuQztBQUNIO0FBQ0QsZ0JBQUk7QUFDQTtBQUNBQyw2QkFBYTlGLGFBQWF1RSxVQUFiLENBQXdCQyxJQUF4QixDQUE2QnFCLFlBQTdCLEVBQTJDLEVBQUVHLFdBQVcsSUFBYixFQUEzQyxDQUFiO0FBQ0gsYUFIRCxDQUlBLE9BQU8vRCxLQUFQLEVBQWM7QUFDVjtBQUNBO0FBQ0EsdUJBQU92QixTQUFQO0FBQ0g7QUFDRDtBQUNBNEQsdUJBQVcsSUFBSWhDLFFBQUosQ0FBYXdELFVBQWIsRUFBeUJELFlBQXpCLEVBQXVDM0IsaUJBQXZDLENBQVg7QUFDQTRCLHlCQUFhcEYsU0FBYjtBQUNILFNBckJELFNBc0JRO0FBQ0osZ0JBQUlvRixVQUFKLEVBQWdCO0FBQ1pBLDJCQUFXRixLQUFYO0FBQ0g7QUFDSjtBQUNELGVBQU90QixRQUFQO0FBQ0g7QUFDRDs7OztBQUlBMkIsY0FBVTtBQUNOLFlBQUksS0FBS0MsVUFBVCxFQUFxQjtBQUNqQixrQkFBTSxJQUFJN0UsS0FBSixDQUFXLHNCQUFxQjFCLEtBQUt3RyxRQUFMLENBQWMsS0FBSzFELFNBQW5CLENBQThCLDhCQUE5RCxDQUFOO0FBQ0g7QUFDRCxhQUFLRCxXQUFMLENBQWlCb0QsS0FBakI7QUFDQTdGLHFCQUFhZ0MsVUFBYixDQUF3QjRELFVBQXhCLENBQW1DLEtBQUtsRCxTQUF4QztBQUNBLGFBQUtELFdBQUwsR0FBbUI5QixTQUFuQjtBQUNIO0FBQ0Q7Ozs7QUFJQSxRQUFJd0QsaUJBQUosR0FBd0I7QUFDcEIsZUFBTyxLQUFLeEIsa0JBQVo7QUFDSDtBQUNEOzs7QUFHQSxRQUFJMEQsUUFBSixHQUFlO0FBQ1gsZUFBTyxLQUFLM0QsU0FBWjtBQUNIO0FBQ0Q7OztBQUdBLFFBQUl5RCxVQUFKLEdBQWlCO0FBQ2IsZUFBTyxLQUFLMUQsV0FBTCxLQUFxQjlCLFNBQTVCO0FBQ0g7QUE3T1U7QUErT2Y0QixTQUFTNkIsYUFBVCxHQUF5Qm5ELG1CQUF6QjtBQUNBdkIsUUFBUTZDLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0EiLCJmaWxlIjoiTG9ja0ZpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgdGltZXJzXzEgPSByZXF1aXJlKFwidGltZXJzXCIpO1xuY29uc3QgRmlsZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vRmlsZVN5c3RlbVwiKTtcbmNvbnN0IEZpbGVXcml0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbGVXcml0ZXJcIik7XG4vKipcbiAqIGh0dHA6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuNS9wcm9jLjUuaHRtbFxuICogKDIyKSBzdGFydHRpbWUgICVsbHVcbiAqIFRoZSB0aW1lIHRoZSBwcm9jZXNzIHN0YXJ0ZWQgYWZ0ZXIgc3lzdGVtIGJvb3QuIEluIGtlcm5lbHMgYmVmb3JlIExpbnV4IDIuNiwgdGhpcyB2YWx1ZSB3YXNcbiAqIGV4cHJlc3NlZCBpbiBqaWZmaWVzLiBTaW5jZSBMaW51eCAyLjYsIHRoZSB2YWx1ZSBpcyBleHByZXNzZWQgaW4gY2xvY2sgdGlja3MgKGRpdmlkZSBieVxuICogc3lzY29uZihfU0NfQ0xLX1RDSykpLlxuICogVGhlIGZvcm1hdCBmb3IgdGhpcyBmaWVsZCB3YXMgJWx1IGJlZm9yZSBMaW51eCAyLjYuXG4gKi9cbmNvbnN0IHByb2NTdGF0U3RhcnRUaW1lUG9zID0gMjI7XG4vKipcbiAqIFBhcnNlcyB0aGUgcHJvY2VzcyBzdGFydCB0aW1lIGZyb20gdGhlIGNvbnRlbnRzIG9mIGEgbGludXggL3Byb2MvW3BpZF0vc3RhdCBmaWxlLlxuICogQHBhcmFtIHN0YXQgLSBUaGUgY29udGVudHMgb2YgYSBsaW51eCAvcHJvYy9bcGlkXS9zdGF0IGZpbGUuXG4gKiBAcmV0dXJucyBUaGUgcHJvY2VzcyBzdGFydCB0aW1lIGluIGppZmZpZXMsIG9yIHVuZGVmaW5lZCBpZiBzdGF0IGhhcyBhbiB1bmV4cGVjdGVkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvY2Vzc1N0YXJ0VGltZUZyb21Qcm9jU3RhdChzdGF0KSB7XG4gICAgLy8gUGFyc2UgdGhlIHZhbHVlIGF0IHBvc2l0aW9uIHByb2NTdGF0U3RhcnRUaW1lUG9zLlxuICAgIC8vIFdlIGNhbm5vdCBqdXN0IHNwbGl0IHN0YXQgb24gc3BhY2VzLCBiZWNhdXNlIHZhbHVlIDIgbWF5IGNvbnRhaW4gc3BhY2VzLlxuICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHJ1bm5pbmcgdGhlIGZvbGxvd2luZyBTaGVsbCBjb21tYW5kczpcbiAgICAvLyA+IGNwIFwiJCh3aGljaCBiYXNoKVwiIC4vJ2Jhc2ggMikoJ1xuICAgIC8vID4gLi8nYmFzaCAyKSgnIC1jICdPV05QSUQ9JEJBU0hQSUQ7Y2F0IC9wcm9jLyRPV05QSUQvc3RhdCdcbiAgICAvLyA1OTM4OSAoYmFzaCAyKSgpIFMgNTkzNTggNTkzODkgNTkzNTggMzQ4MTggNTkzODkgNDIwMjQ5NiAzMjkgMCAwIDAgMCAwIDAgMCAyMCAwIDEgMFxuICAgIC8vID4gcm0gLXJmIC4vJ2Jhc2ggMikoJ1xuICAgIC8vIFRoZSBvdXRwdXQgc2hvd3MgYSBzdGF0IGZpbGUgc3VjaCB0aGF0IHZhbHVlIDIgY29udGFpbnMgc3BhY2VzLlxuICAgIC8vIFRvIHN0aWxsIHVtYW1iaWd1b3VzbHkgcGFyc2Ugc3VjaCBvdXRwdXQgd2UgYXNzdW1lIG5vIHZhbHVlcyBhZnRlciB0aGUgc2Vjb25kIGVuZHMgd2l0aCBhIHJpZ2h0IHBhcmVudGhlc2lzLi4uXG4gICAgLy8gdHJpbVJpZ2h0IHRvIHJlbW92ZSB0aGUgdHJhaWxpbmcgbGluZSB0ZXJtaW5hdG9yLlxuICAgIGxldCB2YWx1ZXMgPSBzdGF0LnRyaW1SaWdodCgpLnNwbGl0KCcgJyk7XG4gICAgbGV0IGkgPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaSA+PSAwICYmXG4gICAgICAgIC8vIGNoYXJBdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgdmFsdWVzW2ldLmNoYXJBdCh2YWx1ZXNbaV0ubGVuZ3RoIC0gMSkgIT09ICcpJykge1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHBhcnQgb2YgdGhlIHNlY29uZCB2YWx1ZSAoYnV0IGkgbmVlZCBub3QgYmUgMSkuXG4gICAgaWYgKGkgPCAxKSB7XG4gICAgICAgIC8vIEZvcm1hdCBvZiBzdGF0IGhhcyBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZTIgPSB2YWx1ZXMuc2xpY2UoMSwgaSArIDEpLmpvaW4oJyAnKTtcbiAgICB2YWx1ZXMgPSBbdmFsdWVzWzBdLCB2YWx1ZTJdLmNvbmNhdCh2YWx1ZXMuc2xpY2UoaSArIDEpKTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8IHByb2NTdGF0U3RhcnRUaW1lUG9zKSB7XG4gICAgICAgIC8vIE9sZGVyIHZlcnNpb24gb2YgbGludXgsIG9yIG5vbi1zdGFuZGFyZCBjb25maWd1cmF0aW9uIG9mIGxpbnV4LlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWVKaWZmaWVzID0gdmFsdWVzW3Byb2NTdGF0U3RhcnRUaW1lUG9zIC0gMV07XG4gICAgLy8gSW4gdGhlb3J5LCB0aGUgcmVwcmVzZW50YXRpb25zIG9mIHN0YXJ0IHRpbWUgcmV0dXJuZWQgYnkgYGNhdCAvcHJvYy9bcGlkXS9zdGF0YCBhbmQgYHBzIC1vIGxzdGFydGAgY2FuIGNoYW5nZVxuICAgIC8vIHdoaWxlIHRoZSBzeXN0ZW0gaXMgcnVubmluZywgYnV0IHdlIGFzc3VtZSB0aGlzIGRvZXMgbm90IGhhcHBlbi5cbiAgICAvLyBTbyB0aGUgY2FsbGVyIGNhbiBzYWZlbHkgdXNlIHRoaXMgdmFsdWUgYXMgcGFydCBvZiBhIHVuaXF1ZSBwcm9jZXNzIGlkIChvbiB0aGUgbWFjaGluZSwgd2l0aG91dCBjb21wYXJpbmdcbiAgICAvLyBhY2Nyb3NzIHJlYm9vdHMpLlxuICAgIHJldHVybiBzdGFydFRpbWVKaWZmaWVzO1xufVxuZXhwb3J0cy5nZXRQcm9jZXNzU3RhcnRUaW1lRnJvbVByb2NTdGF0ID0gZ2V0UHJvY2Vzc1N0YXJ0VGltZUZyb21Qcm9jU3RhdDtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXhwb3J0ZWQgZm9yIHVuaXQgdGVzdHMgb25seS5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBwcm9jZXNzIGRvZXNuJ3QgZXhpc3Qgd2l0aCB0aGF0IHBpZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvY2Vzc1N0YXJ0VGltZShwaWQpIHtcbiAgICBjb25zdCBwaWRTdHJpbmcgPSBwaWQudG9TdHJpbmcoKTtcbiAgICBpZiAocGlkIDwgMCB8fCBwaWRTdHJpbmcuaW5kZXhPZignZScpID49IDAgfHwgcGlkU3RyaW5nLmluZGV4T2YoJ0UnKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaWRcIiBpcyBuZWdhdGl2ZSBvciB0b28gbGFyZ2VgKTtcbiAgICB9XG4gICAgbGV0IGFyZ3M7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIGFyZ3MgPSBbYC1wICR7cGlkU3RyaW5nfWAsICctbyBsc3RhcnQnXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgICAgICBhcmdzID0gWyctcCcsIHBpZFN0cmluZywgJy1vJywgJ2xzdGFydCddO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzeXN0ZW06ICR7cHJvY2Vzcy5wbGF0Zm9ybX1gKTtcbiAgICB9XG4gICAgY29uc3QgcHNSZXN1bHQgPSBjaGlsZF9wcm9jZXNzLnNwYXduU3luYygncHMnLCBhcmdzLCB7XG4gICAgICAgIGVuY29kaW5nOiAndXRmOCdcbiAgICB9KTtcbiAgICBjb25zdCBwc1N0ZG91dCA9IHBzUmVzdWx0LnN0ZG91dDtcbiAgICAvLyBJZiBubyBwcm9jZXNzIHdpdGggUElEIHBpZCBleGlzdHMgdGhlbiB0aGUgZXhpdCBjb2RlIGlzIG5vbi16ZXJvIG9uIGxpbnV4IGJ1dCBzdGRvdXQgaXMgbm90IGVtcHR5LlxuICAgIC8vIEJ1dCBpZiBubyBwcm9jZXNzIGV4aXN0cyB3ZSBkbyBub3Qgd2FudCB0byBmYWxsIGJhY2sgb24gL3Byb2MvKi9zdGF0IHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc1xuICAgIC8vIHN0YXJ0IHRpbWUsIHNvIHdlIHdlIGFkZGl0aW9uYWxseSB0ZXN0IGZvciAhcHNTdGRvdXQuIE5PVEU6ICFwc1N0ZG91dCBldmFsdWF0ZXMgdG8gdHJ1ZSBpZlxuICAgIC8vIHplcm8gYnl0ZXMgYXJlIHdyaXR0ZW4gdG8gc3Rkb3V0LlxuICAgIGlmIChwc1Jlc3VsdC5zdGF0dXMgIT09IDAgJiYgIXBzU3Rkb3V0ICYmIHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHJlYWQgL3Byb2MvW3BpZF0vc3RhdCBhbmQgZ2V0IHRoZSB2YWx1ZSBhdCBwb3NpdGlvbiBwcm9jU3RhdFN0YXJ0VGltZVBvcy5cbiAgICAgICAgbGV0IHN0YXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGF0ID0gRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0ucmVhZEZpbGUoYC9wcm9jLyR7cGlkU3RyaW5nfS9zdGF0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVpdGhlciBubyBwcm9jZXNzIHdpdGggUElEIHBpZCBleGlzdHMsIG9yIHRoaXMgdmVyc2lvbi9jb25maWd1cmF0aW9uIG9mIGxpbnV4IGlzIG5vbi1zdGFuZGFyZC5cbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgZm9ybWVyLlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWVKaWZmaWVzID0gZ2V0UHJvY2Vzc1N0YXJ0VGltZUZyb21Qcm9jU3RhdChzdGF0KTtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWVKaWZmaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSB0aGUgc3RhcnQgdGltZSBvZiBwcm9jZXNzICR7cGlkU3RyaW5nfSBmcm9tIHRoZSBPUyBiZWNhdXNlIHRoZSBgXG4gICAgICAgICAgICAgICAgICAgICsgYGNvbnRlbnRzIG9mIC9wcm9jLyR7cGlkU3RyaW5nfS9zdGF0IGhhdmUgYW4gdW5leHBlY3RlZCBmb3JtYXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydFRpbWVKaWZmaWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBleGVjdXRpbmcgcHMgKHplcm8gYnl0ZXMgd2VyZSB3cml0dGVuIHRvIHN0ZG91dCkuXG4gICAgaWYgKCFwc1N0ZG91dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IGZyb20gXCJwc1wiIGNvbW1hbmRgKTtcbiAgICB9XG4gICAgY29uc3QgcHNTcGxpdCA9IHBzU3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICAvLyBzdWNjZXNzZnVseSBhYmxlIHRvIHJ1biBcInBzXCIsIGJ1dCBubyBwcm9jZXNzIHdhcyBmb3VuZFxuICAgIGlmIChwc1NwbGl0WzFdID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocHNTcGxpdFsxXSkge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gcHNTcGxpdFsxXS50cmltKCk7XG4gICAgICAgIGlmICh0cmltbWVkLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJpbW1lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IGZyb20gdGhlIFwicHNcIiBjb21tYW5kYCk7XG59XG5leHBvcnRzLmdldFByb2Nlc3NTdGFydFRpbWUgPSBnZXRQcm9jZXNzU3RhcnRUaW1lO1xuLyoqXG4gKiBBIGhlbHBlciB1dGlsaXR5IGZvciB3b3JraW5nIHdpdGggZmlsZS1iYXNlZCBsb2Nrcy5cbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgbG9ja2luZyByZXNvdXJjZXMgYWNyb3NzIHByb2Nlc3NlcyxcbiAqIGJ1dCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGF0dGVtcHRpbmcgdG8gbG9jayBhIHJlc291cmNlIGluIHRoZSBzYW1lIHByb2Nlc3MuXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIExvY2tGaWxlIHtcbiAgICBjb25zdHJ1Y3RvcihfZmlsZVdyaXRlciwgX2ZpbGVQYXRoLCBfZGlydHlXaGVuQWNxdWlyZWQpIHtcbiAgICAgICAgdGhpcy5fZmlsZVdyaXRlciA9IF9maWxlV3JpdGVyO1xuICAgICAgICB0aGlzLl9maWxlUGF0aCA9IF9maWxlUGF0aDtcbiAgICAgICAgdGhpcy5fZGlydHlXaGVuQWNxdWlyZWQgPSBfZGlydHlXaGVuQWNxdWlyZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhdGggdG8gdGhlIGxvY2tmaWxlLCBzaG91bGQgaXQgYmUgY3JlYXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGdldExvY2tGaWxlUGF0aChyZXNvdXJjZURpciwgcmVzb3VyY2VOYW1lLCBwaWQgPSBwcm9jZXNzLnBpZCkge1xuICAgICAgICBpZiAoIXJlc291cmNlTmFtZS5tYXRjaCgvXlthLXpBLVowLTldW2EtekEtWjAtOS0uXStbYS16QS1aMC05XSQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVzb3VyY2UgbmFtZSBcIiR7cmVzb3VyY2VOYW1lfVwiIGlzIGludmFsaWQuYFxuICAgICAgICAgICAgICAgICsgYCBJdCBtdXN0IGJlIGFuIGFscGhhbnVtYmVyaWMgc3RyaW5nIHdpdGggb25seSBcIi1cIiBvciBcIi5cIiBJdCBtdXN0IHN0YXJ0IHdpdGggYW4gYWxwaGFudW1lcmljIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihwYXRoLnJlc29sdmUocmVzb3VyY2VEaXIpLCBgJHtyZXNvdXJjZU5hbWV9LmxvY2tgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKHBhdGgucmVzb2x2ZShyZXNvdXJjZURpciksIGAke3Jlc291cmNlTmFtZX0jJHtwaWR9LmxvY2tgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgbG9ja2luZyBub3QgaW1wbGVtZW50ZWQgZm9yIHBsYXRmb3JtOiBcIiR7cHJvY2Vzcy5wbGF0Zm9ybX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBjcmVhdGUgYSBsb2NrZmlsZSB3aXRoIHRoZSBnaXZlbiBmaWxlUGF0aC5cbiAgICAgKiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIGEgTG9ja0ZpbGUgaW5zdGFuY2UuXG4gICAgICogSWYgdW5hYmxlIHRvIGdldCBhIGxvY2ssIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqIEBwYXJhbSByZXNvdXJjZU5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcmVzb3VyY2Ugd2UgYXJlIGxvY2tpbmcgb24uIFNob3VsZCBiZSBhbiBhbHBoYWJldGljIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHJ5QWNxdWlyZShyZXNvdXJjZURpciwgcmVzb3VyY2VOYW1lKSB7XG4gICAgICAgIEZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmVuc3VyZUZvbGRlcihyZXNvdXJjZURpcik7XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9ja0ZpbGUuX3RyeUFjcXVpcmVXaW5kb3dzKHJlc291cmNlRGlyLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NrRmlsZS5fdHJ5QWNxdWlyZU1hY09yTGludXgocmVzb3VyY2VEaXIsIHJlc291cmNlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWxlIGxvY2tpbmcgbm90IGltcGxlbWVudGVkIGZvciBwbGF0Zm9ybTogXCIke3Byb2Nlc3MucGxhdGZvcm19XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gY3JlYXRlIHRoZSBsb2NrZmlsZS5cbiAgICAgKiBXaWxsIGNvbnRpbnVlIHRvIGxvb3AgYXQgZXZlcnkgMTAwbXMgdW50aWwgdGhlIGxvY2sgYmVjb21lcyBhdmFpbGFibGUgb3IgdGhlIG1heFdhaXRNcyBpcyBzdXJwYXNzZWQuXG4gICAgICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiBpcyBzdWJqZWN0IHRvIHN0YXJ2YXRpb24sIHdoZXJlYnkgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXQgdGhlIHByb2Nlc3MgdGhhdCBoYXMgYmVlblxuICAgICAqICAgICAgICAgIHdhaXRpbmcgdGhlIGxvbmdlc3QgdG8gYWNxdWlyZSB0aGUgbG9jayB3aWxsIGdldCBpdCBmaXJzdC4gVGhpcyBtZWFucyB0aGF0IGEgcHJvY2VzcyBjb3VsZCB0aGVvcmV0aWNhbGx5XG4gICAgICogICAgICAgICAgd2FpdCBmb3IgdGhlIGxvY2sgZm9yZXZlciwgd2hpbGUgb3RoZXIgcHJvY2Vzc2VzIHNraXBwZWQgaXQgaW4gbGluZSBhbmQgYWNxdWlyZWQgdGhlIGxvY2sgZmlyc3QuXG4gICAgICovXG4gICAgc3RhdGljIGFjcXVpcmUocmVzb3VyY2VEaXIsIHJlc291cmNlTmFtZSwgbWF4V2FpdE1zKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCByZXRyeUxvb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NrID0gTG9ja0ZpbGUudHJ5QWNxdWlyZShyZXNvdXJjZURpciwgcmVzb3VyY2VOYW1lKTtcbiAgICAgICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhXYWl0TXMgJiYgKERhdGUubm93KCkgPiBzdGFydFRpbWUgKyBtYXhXYWl0TXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgRXhjZWVkZWQgbWF4aW11bSB3YWl0IHRpbWUgdG8gYWNxdWlyZSBsb2NrIGZvciByZXNvdXJjZSBcIiR7cmVzb3VyY2VOYW1lfVwiYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIExvY2tGaWxlLl9zbGVlcEZvck1zKGludGVydmFsKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlMb29wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHJ5TG9vcCgpO1xuICAgIH1cbiAgICBzdGF0aWMgX3NsZWVwRm9yTXModGltZW91dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGltZXJzXzEuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBhY3F1aXJlIHRoZSBsb2NrIG9uIGEgTGludXggb3IgT1NYIG1hY2hpbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3RyeUFjcXVpcmVNYWNPckxpbnV4KHJlc291cmNlRGlyLCByZXNvdXJjZU5hbWUpIHtcbiAgICAgICAgbGV0IGRpcnR5V2hlbkFjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBwcm9jZXNzJyBwaWRcbiAgICAgICAgY29uc3QgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IExvY2tGaWxlLl9nZXRTdGFydFRpbWUocGlkKTtcbiAgICAgICAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNhbGN1bGF0ZSBzdGFydCB0aW1lIGZvciBjdXJyZW50IHByb2Nlc3MuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlkTG9ja0ZpbGVQYXRoID0gTG9ja0ZpbGUuZ2V0TG9ja0ZpbGVQYXRoKHJlc291cmNlRGlyLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICBsZXQgbG9ja0ZpbGVIYW5kbGU7XG4gICAgICAgIGxldCBsb2NrRmlsZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG9wZW4gaW4gd3JpdGUgbW9kZSBzaW5jZSBpZiB0aGlzIGZpbGUgZXhpc3RzLCBpdCBjYW5ub3QgYmUgZnJvbSB0aGUgY3VycmVudCBwcm9jZXNzXG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIHdpbGwgbWFsZnVuY3Rpb24gaWYgdGhlIHNhbWUgcHJvY2VzcyB0cmllcyB0byBhY3F1aXJlIHR3byBsb2NrcyBvbiB0aGUgc2FtZSBmaWxlLlxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGlkZWFsbHkgbWFpbnRhaW4gYSBkaWN0aW9uYXJ5IG9mIG5vcm1hbGl6ZWQgYWNxdWlyZWQgZmlsZW5hbWVzXG4gICAgICAgICAgICBsb2NrRmlsZUhhbmRsZSA9IEZpbGVXcml0ZXJfMS5GaWxlV3JpdGVyLm9wZW4ocGlkTG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIGxvY2tGaWxlSGFuZGxlLndyaXRlKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmlydGhUaW1lTXMgPSBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5nZXRTdGF0aXN0aWNzKHBpZExvY2tGaWxlUGF0aCkuYmlydGh0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGxldCBzbWFsbGVzdEJpcnRoVGltZU1zID0gY3VycmVudEJpcnRoVGltZU1zO1xuICAgICAgICAgICAgbGV0IHNtYWxsZXN0QmlydGhUaW1lUGlkID0gcGlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBub3csIHNjYW4gdGhlIGRpcmVjdG9yeSBmb3IgYWxsIGxvY2tmaWxlc1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5yZWFkRm9sZGVyKHJlc291cmNlRGlyKTtcbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGFueXRoaW5nIGVuZGluZyB3aXRoICMgdGhlbiBudW1iZXJzIGFuZCBcIi5sb2NrXCJcbiAgICAgICAgICAgIGNvbnN0IGxvY2tGaWxlUmVnRXhwID0gL14oLispIyhbMC05XSspXFwubG9jayQvO1xuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgbGV0IG90aGVyUGlkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlSW5Gb2xkZXIgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gZmlsZUluRm9sZGVyLm1hdGNoKGxvY2tGaWxlUmVnRXhwKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKG1hdGNoWzFdID09PSByZXNvdXJjZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICYmICgob3RoZXJQaWQgPSBtYXRjaFsyXSkgIT09IHBpZC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhdCBsZWFzdCBvbmUgbG9ja2ZpbGUgaGFuZ2luZyBhcm91bmQgdGhhdCBpc24ndCBvdXJzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVJbkZvbGRlclBhdGggPSBwYXRoLmpvaW4ocmVzb3VyY2VEaXIsIGZpbGVJbkZvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5V2hlbkFjcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYEZPVU5EIE9USEVSIExPQ0tGSUxFOiAke290aGVyUGlkfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlclBpZEN1cnJlbnRTdGFydFRpbWUgPSBMb2NrRmlsZS5fZ2V0U3RhcnRUaW1lKHBhcnNlSW50KG90aGVyUGlkLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXJQaWRPbGRTdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdGhlckJpcnRodGltZU1zO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJQaWRPbGRTdGFydFRpbWUgPSBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5yZWFkRmlsZShmaWxlSW5Gb2xkZXJQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSB0aW1lc3RhbXAgb2YgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQmlydGh0aW1lTXMgPSBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5nZXRTdGF0aXN0aWNzKGZpbGVJbkZvbGRlclBhdGgpLmJpcnRodGltZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGUgZmlsZSBpcyBwcm9iYWJseSBkZWxldGVkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb3RoZXJQaWRPbGRTdGFydFRpbWUgaXMgaW52YWxpZCwgdGhlbiB3ZSBzaG91bGQgbG9vayBhdCB0aGUgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGZpbGUgd2FzIGNyZWF0ZWQgYWZ0ZXIgdXMsIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCB3YXMgY3JlYXRlZCB3aXRoaW4gMSBzZWNvbmQgYmVmb3JlIHVzLCB0aGVuIGl0IGNvdWxkIGJlIGdvb2QsIHNvIHdlXG4gICAgICAgICAgICAgICAgICAgIC8vICB3aWxsIGNvbnNlcnZhdGl2ZWx5IGZhaWxcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGFuIG9sZCBsb2NrIGZpbGUgYW5kIHdpbGwgYmUgZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJQaWRPbGRTdGFydFRpbWUgPT09ICcnICYmIG90aGVyQmlydGh0aW1lTXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQmlydGh0aW1lTXMgPiBjdXJyZW50QmlydGhUaW1lTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBmaWxlLCBoZSB3aWxsIGJlIHVuYWJsZSB0byBnZXQgdGhlIGxvY2sgc2luY2UgdGhpcyBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBob2xkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYElnbm9yaW5nIGxvY2sgZm9yIHBpZCAke290aGVyUGlkfSBiZWNhdXNlIGl0cyBsb2NrZmlsZSBpcyBuZXdlciB0aGFuIG91cnMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlckJpcnRodGltZU1zIC0gY3VycmVudEJpcnRoVGltZU1zIDwgMCAvLyBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgdXMgQU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgb3RoZXJCaXJ0aHRpbWVNcyAtIGN1cnJlbnRCaXJ0aFRpbWVNcyA+IC0xMDAwKSB7IC8vIGl0IHdhcyBjcmVhdGVkIGxlc3MgdGhhbiBhIHNlY29uZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zZXJ2YXRpdmVseSBiZSB1bmFibGUgdG8ga2VlcCB0aGUgbG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYE90aGVyIHBpZCAke290aGVyUGlkfSBsb2NrZmlsZSBoYXMgc3RhcnQgdGltZTogXCIke290aGVyUGlkT2xkU3RhcnRUaW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBPdGhlciBwaWQgJHtvdGhlclBpZH0gYWN0dWFsbHkgaGFzIHN0YXJ0IHRpbWU6IFwiJHtvdGhlclBpZEN1cnJlbnRTdGFydFRpbWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGUgcHJvY2VzcyBpcyBubyBsb25nZXIgZXhlY3V0aW5nLCBkZWxldGUgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlclBpZEN1cnJlbnRTdGFydFRpbWUgfHwgb3RoZXJQaWRPbGRTdGFydFRpbWUgIT09IG90aGVyUGlkQ3VycmVudFN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYE90aGVyIHBpZCAke290aGVyUGlkfSBpcyBubyBsb25nZXIgZXhlY3V0aW5nIWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0uZGVsZXRlRmlsZShmaWxlSW5Gb2xkZXJQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBQaWQgJHtvdGhlclBpZH0gbG9ja2ZpbGUgaGFzIGJpcnRoIHRpbWU6ICR7b3RoZXJCaXJ0aHRpbWVNc31gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFBpZCAke3BpZH0gbG9ja2ZpbGUgaGFzIGJpcnRoIHRpbWU6ICR7Y3VycmVudEJpcnRoVGltZU1zfWApO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbG9ja2ZpbGUgcG9pbnRpbmcgYXQgc29tZXRoaW5nIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckJpcnRodGltZU1zICE9PSB1bmRlZmluZWQgJiYgb3RoZXJCaXJ0aHRpbWVNcyA8IHNtYWxsZXN0QmlydGhUaW1lTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0QmlydGhUaW1lTXMgPSBvdGhlckJpcnRodGltZU1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RCaXJ0aFRpbWVQaWQgPSBvdGhlclBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbWFsbGVzdEJpcnRoVGltZVBpZCAhPT0gcGlkLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgaGF2ZSB0aGUgbG9ja1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRoZSBsb2NrIVxuICAgICAgICAgICAgbG9ja0ZpbGUgPSBuZXcgTG9ja0ZpbGUobG9ja0ZpbGVIYW5kbGUsIHBpZExvY2tGaWxlUGF0aCwgZGlydHlXaGVuQWNxdWlyZWQpO1xuICAgICAgICAgICAgbG9ja0ZpbGVIYW5kbGUgPSB1bmRlZmluZWQ7IC8vIHdlIGhhdmUgaGFuZGVkIHRoZSBkZXNjcmlwdG9yIG9mZiB0byB0aGUgaW5zdGFuY2VcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChsb2NrRmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBvdXIgbG9jayBpcyBjbG9zZWRcbiAgICAgICAgICAgICAgICBsb2NrRmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIEZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmRlbGV0ZUZpbGUocGlkTG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9ja0ZpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGFjcXVpcmUgdGhlIGxvY2sgdXNpbmcgV2luZG93c1xuICAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG11Y2ggc2ltcGxlciBzaW5jZSB3ZSBjYW4gcmVseSBvbiB0aGUgb3BlcmF0aW5nIHN5c3RlbVxuICAgICAqL1xuICAgIHN0YXRpYyBfdHJ5QWNxdWlyZVdpbmRvd3MocmVzb3VyY2VEaXIsIHJlc291cmNlTmFtZSkge1xuICAgICAgICBjb25zdCBsb2NrRmlsZVBhdGggPSBMb2NrRmlsZS5nZXRMb2NrRmlsZVBhdGgocmVzb3VyY2VEaXIsIHJlc291cmNlTmFtZSk7XG4gICAgICAgIGxldCBkaXJ0eVdoZW5BY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZmlsZUhhbmRsZTtcbiAgICAgICAgbGV0IGxvY2tGaWxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmV4aXN0cyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZGlydHlXaGVuQWNxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsb2NrZmlsZSBpcyBoZWxkIGJ5IGFuIHByb2Nlc3Mgd2l0aCBhbiBleGNsdXNpdmUgbG9jaywgdGhlbiByZW1vdmluZyBpdCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gc2lsZW50bHkgZmFpbC4gT3BlblN5bmMoKSBiZWxvdyB3aWxsIHRoZW4gZmFpbCBhbmQgd2Ugd2lsbCBiZSB1bmFibGUgdG8gY3JlYXRlIGEgbG9jay5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBsb2NrZmlsZSBpcyBzaXR0aW5nIG9uIGRpc2ssIGJ1dCBub3RoaW5nIGlzIGhvbGRpbmcgaXQsIGltcGx5aW5nIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBwcm9jZXNzIHRvIGhvbGQgaXQgZGllZC5cbiAgICAgICAgICAgICAgICBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5kZWxldGVGaWxlKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gb3BlbiBhbiBleGNsdXNpdmUgbG9ja2ZpbGVcbiAgICAgICAgICAgICAgICBmaWxlSGFuZGxlID0gRmlsZVdyaXRlcl8xLkZpbGVXcml0ZXIub3Blbihsb2NrRmlsZVBhdGgsIHsgZXhjbHVzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgdHJpZWQgdG8gZGVsZXRlIHRoZSBsb2NrLCBidXQgc29tZXRoaW5nIGVsc2UgaXMgaG9sZGluZyBpdCxcbiAgICAgICAgICAgICAgICAvLyAocHJvYmFibHkgYW4gYWN0aXZlIHByb2Nlc3MpLCB0aGVyZWZvcmUgd2UgYXJlIHVuYWJsZSB0byBjcmVhdGUgYSBsb2NrXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBjYW4gaGFuZCBvZmYgdGhlIGZpbGUgZGVzY3JpcHRvciB0byB0aGUgbG9ja2ZpbGVcbiAgICAgICAgICAgIGxvY2tGaWxlID0gbmV3IExvY2tGaWxlKGZpbGVIYW5kbGUsIGxvY2tGaWxlUGF0aCwgZGlydHlXaGVuQWNxdWlyZWQpO1xuICAgICAgICAgICAgZmlsZUhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NrRmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5sb2NrcyBhIGZpbGUgYW5kIHJlbW92ZXMgaXQgZnJvbSBkaXNrLlxuICAgICAqIFRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAgICovXG4gICAgcmVsZWFzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWxlYXNlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbG9jayBmb3IgZmlsZSBcIiR7cGF0aC5iYXNlbmFtZSh0aGlzLl9maWxlUGF0aCl9XCIgaGFzIGFscmVhZHkgYmVlbiByZWxlYXNlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maWxlV3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIEZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmRlbGV0ZUZpbGUodGhpcy5fZmlsZVBhdGgpO1xuICAgICAgICB0aGlzLl9maWxlV3JpdGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBsb2NrLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBwcmV2aW91cyBwcm9jZXNzIHdhcyB0ZXJtaW5hdGVkIGJlZm9yZSByZWxlYXNpbmcgdGhlIHJlc291cmNlLlxuICAgICAqL1xuICAgIGdldCBkaXJ0eVdoZW5BY3F1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5V2hlbkFjcXVpcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBsb2NrZmlsZVxuICAgICAqL1xuICAgIGdldCBmaWxlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsb2NrIGlzIGN1cnJlbnRseSBiZWluZyBoZWxkLlxuICAgICAqL1xuICAgIGdldCBpc1JlbGVhc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsZVdyaXRlciA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbkxvY2tGaWxlLl9nZXRTdGFydFRpbWUgPSBnZXRQcm9jZXNzU3RhcnRUaW1lO1xuZXhwb3J0cy5Mb2NrRmlsZSA9IExvY2tGaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9ja0ZpbGUuanMubWFwIl19