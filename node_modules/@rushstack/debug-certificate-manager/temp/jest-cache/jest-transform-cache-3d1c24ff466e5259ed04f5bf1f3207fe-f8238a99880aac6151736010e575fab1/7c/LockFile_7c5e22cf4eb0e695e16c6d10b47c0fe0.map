{"version":3,"sources":["LockFile.js"],"names":["Object","defineProperty","exports","value","path","require","child_process","timers_1","FileSystem_1","FileWriter_1","procStatStartTimePos","getProcessStartTimeFromProcStat","stat","values","trimRight","split","i","length","charAt","undefined","value2","slice","join","concat","startTimeJiffies","getProcessStartTime","pid","pidString","toString","indexOf","Error","args","process","platform","psResult","spawnSync","encoding","psStdout","stdout","status","FileSystem","readFile","error","code","psSplit","trimmed","trim","LockFile","constructor","_fileWriter","_filePath","_dirtyWhenAcquired","getLockFilePath","resourceDir","resourceName","match","resolve","tryAcquire","ensureFolder","_tryAcquireWindows","_tryAcquireMacOrLinux","acquire","maxWaitMs","interval","startTime","Date","now","retryLoop","lock","Promise","reject","_sleepForMs","then","timeout","setTimeout","dirtyWhenAcquired","_getStartTime","pidLockFilePath","lockFileHandle","lockFile","FileWriter","open","write","currentBirthTimeMs","getStatistics","birthtime","getTime","smallestBirthTimeMs","smallestBirthTimePid","files","readFolder","lockFileRegExp","otherPid","fileInFolder","fileInFolderPath","otherPidCurrentStartTime","parseInt","otherPidOldStartTime","otherBirthtimeMs","err","deleteFile","close","lockFilePath","fileHandle","exists","exclusive","release","isReleased","basename","filePath"],"mappings":"AAAA;AACA;AACA;;AACAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;AACA,MAAMC,OAAOC,QAAQ,MAAR,CAAb;AACA,MAAMC,gBAAgBD,QAAQ,eAAR,CAAtB;AACA,MAAME,WAAWF,QAAQ,QAAR,CAAjB;AACA,MAAMG,eAAeH,QAAQ,cAAR,CAArB;AACA,MAAMI,eAAeJ,QAAQ,cAAR,CAArB;AACA;;;;;;;;AAQA,MAAMK,uBAAuB,EAA7B;AACA;;;;;AAKA,SAASC,+BAAT,CAAyCC,IAAzC,EAA+C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIC,SAASD,KAAKE,SAAL,GAAiBC,KAAjB,CAAuB,GAAvB,CAAb;AACA,QAAIC,IAAIH,OAAOI,MAAP,GAAgB,CAAxB;AACA,WAAOD,KAAK,CAAL;AACH;AACAH,WAAOG,CAAP,EAAUE,MAAV,CAAiBL,OAAOG,CAAP,EAAUC,MAAV,GAAmB,CAApC,MAA2C,GAF/C,EAEoD;AAChDD,aAAK,CAAL;AACH;AACD;AACA,QAAIA,IAAI,CAAR,EAAW;AACP;AACA,eAAOG,SAAP;AACH;AACD,UAAMC,SAASP,OAAOQ,KAAP,CAAa,CAAb,EAAgBL,IAAI,CAApB,EAAuBM,IAAvB,CAA4B,GAA5B,CAAf;AACAT,aAAS,CAACA,OAAO,CAAP,CAAD,EAAYO,MAAZ,EAAoBG,MAApB,CAA2BV,OAAOQ,KAAP,CAAaL,IAAI,CAAjB,CAA3B,CAAT;AACA,QAAIH,OAAOI,MAAP,GAAgBP,oBAApB,EAA0C;AACtC;AACA,eAAOS,SAAP;AACH;AACD,UAAMK,mBAAmBX,OAAOH,uBAAuB,CAA9B,CAAzB;AACA;AACA;AACA;AACA;AACA,WAAOc,gBAAP;AACH;AACDtB,QAAQS,+BAAR,GAA0CA,+BAA1C;AACA;;;;AAIA,SAASc,mBAAT,CAA6BC,GAA7B,EAAkC;AAC9B,UAAMC,YAAYD,IAAIE,QAAJ,EAAlB;AACA,QAAIF,MAAM,CAAN,IAAWC,UAAUE,OAAV,CAAkB,GAAlB,KAA0B,CAArC,IAA0CF,UAAUE,OAAV,CAAkB,GAAlB,KAA0B,CAAxE,EAA2E;AACvE,cAAM,IAAIC,KAAJ,CAAW,gCAAX,CAAN;AACH;AACD,QAAIC,IAAJ;AACA,QAAIC,QAAQC,QAAR,KAAqB,QAAzB,EAAmC;AAC/BF,eAAO,CAAE,MAAKJ,SAAU,EAAjB,EAAoB,WAApB,CAAP;AACH,KAFD,MAGK,IAAIK,QAAQC,QAAR,KAAqB,OAAzB,EAAkC;AACnCF,eAAO,CAAC,IAAD,EAAOJ,SAAP,EAAkB,IAAlB,EAAwB,QAAxB,CAAP;AACH,KAFI,MAGA;AACD,cAAM,IAAIG,KAAJ,CAAW,uBAAsBE,QAAQC,QAAS,EAAlD,CAAN;AACH;AACD,UAAMC,WAAW5B,cAAc6B,SAAd,CAAwB,IAAxB,EAA8BJ,IAA9B,EAAoC;AACjDK,kBAAU;AADuC,KAApC,CAAjB;AAGA,UAAMC,WAAWH,SAASI,MAA1B;AACA;AACA;AACA;AACA;AACA,QAAIJ,SAASK,MAAT,KAAoB,CAApB,IAAyB,CAACF,QAA1B,IAAsCL,QAAQC,QAAR,KAAqB,OAA/D,EAAwE;AACpE;AACA,YAAIrB,IAAJ;AACA,YAAI;AACAA,mBAAOJ,aAAagC,UAAb,CAAwBC,QAAxB,CAAkC,SAAQd,SAAU,OAApD,CAAP;AACH,SAFD,CAGA,OAAOe,KAAP,EAAc;AACV,gBAAIA,MAAMC,IAAN,KAAe,QAAnB,EAA6B;AACzB,sBAAMD,KAAN;AACH;AACD;AACA;AACA,mBAAOvB,SAAP;AACH;AACD,YAAIP,SAASO,SAAb,EAAwB;AACpB,kBAAMK,mBAAmBb,gCAAgCC,IAAhC,CAAzB;AACA,gBAAIY,qBAAqBL,SAAzB,EAAoC;AAChC,sBAAM,IAAIW,KAAJ,CAAW,gDAA+CH,SAAU,2BAA1D,GACT,qBAAoBA,SAAU,iCAD/B,CAAN;AAEH;AACD,mBAAOH,gBAAP;AACH;AACJ;AACD;AACA,QAAI,CAACa,QAAL,EAAe;AACX,cAAM,IAAIP,KAAJ,CAAW,qCAAX,CAAN;AACH;AACD,UAAMc,UAAUP,SAAStB,KAAT,CAAe,IAAf,CAAhB;AACA;AACA,QAAI6B,QAAQ,CAAR,MAAe,EAAnB,EAAuB;AACnB,eAAOzB,SAAP;AACH;AACD,QAAIyB,QAAQ,CAAR,CAAJ,EAAgB;AACZ,cAAMC,UAAUD,QAAQ,CAAR,EAAWE,IAAX,EAAhB;AACA,YAAID,QAAQ5B,MAAR,GAAiB,EAArB,EAAyB;AACrB,mBAAO4B,OAAP;AACH;AACJ;AACD,UAAM,IAAIf,KAAJ,CAAW,yCAAX,CAAN;AACH;AACD5B,QAAQuB,mBAAR,GAA8BA,mBAA9B;AACA;;;;;;AAMA,MAAMsB,QAAN,CAAe;AACXC,gBAAYC,WAAZ,EAAyBC,SAAzB,EAAoCC,kBAApC,EAAwD;AACpD,aAAKF,WAAL,GAAmBA,WAAnB;AACA,aAAKC,SAAL,GAAiBA,SAAjB;AACA,aAAKC,kBAAL,GAA0BA,kBAA1B;AACH;AACD;;;AAGA,WAAOC,eAAP,CAAuBC,WAAvB,EAAoCC,YAApC,EAAkD5B,MAAMM,QAAQN,GAAhE,EAAqE;AACjE,YAAI,CAAC4B,aAAaC,KAAb,CAAmB,wCAAnB,CAAL,EAAmE;AAC/D,kBAAM,IAAIzB,KAAJ,CAAW,sBAAqBwB,YAAa,eAAnC,GACT,wGADD,CAAN;AAEH;AACD,YAAItB,QAAQC,QAAR,KAAqB,OAAzB,EAAkC;AAC9B,mBAAO7B,KAAKkB,IAAL,CAAUlB,KAAKoD,OAAL,CAAaH,WAAb,CAAV,EAAsC,GAAEC,YAAa,OAArD,CAAP;AACH,SAFD,MAGK,IAAItB,QAAQC,QAAR,KAAqB,OAArB,IAAgCD,QAAQC,QAAR,KAAqB,QAAzD,EAAmE;AACpE,mBAAO7B,KAAKkB,IAAL,CAAUlB,KAAKoD,OAAL,CAAaH,WAAb,CAAV,EAAsC,GAAEC,YAAa,IAAG5B,GAAI,OAA5D,CAAP;AACH;AACD,cAAM,IAAII,KAAJ,CAAW,+CAA8CE,QAAQC,QAAS,GAA1E,CAAN;AACH;AACD;;;;;;AAMA,WAAOwB,UAAP,CAAkBJ,WAAlB,EAA+BC,YAA/B,EAA6C;AACzC9C,qBAAagC,UAAb,CAAwBkB,YAAxB,CAAqCL,WAArC;AACA,YAAIrB,QAAQC,QAAR,KAAqB,OAAzB,EAAkC;AAC9B,mBAAOc,SAASY,kBAAT,CAA4BN,WAA5B,EAAyCC,YAAzC,CAAP;AACH,SAFD,MAGK,IAAItB,QAAQC,QAAR,KAAqB,OAArB,IAAgCD,QAAQC,QAAR,KAAqB,QAAzD,EAAmE;AACpE,mBAAOc,SAASa,qBAAT,CAA+BP,WAA/B,EAA4CC,YAA5C,CAAP;AACH;AACD,cAAM,IAAIxB,KAAJ,CAAW,+CAA8CE,QAAQC,QAAS,GAA1E,CAAN;AACH;AACD;;;;;;;AAOA,WAAO4B,OAAP,CAAeR,WAAf,EAA4BC,YAA5B,EAA0CQ,SAA1C,EAAqD;AACjD,cAAMC,WAAW,GAAjB;AACA,cAAMC,YAAYC,KAAKC,GAAL,EAAlB;AACA,cAAMC,YAAY,MAAM;AACpB,kBAAMC,OAAOrB,SAASU,UAAT,CAAoBJ,WAApB,EAAiCC,YAAjC,CAAb;AACA,gBAAIc,IAAJ,EAAU;AACN,uBAAOC,QAAQb,OAAR,CAAgBY,IAAhB,CAAP;AACH;AACD,gBAAIN,aAAcG,KAAKC,GAAL,KAAaF,YAAYF,SAA3C,EAAuD;AACnD,uBAAOO,QAAQC,MAAR,CAAe,IAAIxC,KAAJ,CAAW,4DAA2DwB,YAAa,GAAnF,CAAf,CAAP;AACH;AACD,mBAAOP,SAASwB,WAAT,CAAqBR,QAArB,EAA+BS,IAA/B,CAAoC,MAAM;AAC7C,uBAAOL,WAAP;AACH,aAFM,CAAP;AAGH,SAXD;AAYA,eAAOA,WAAP;AACH;AACD,WAAOI,WAAP,CAAmBE,OAAnB,EAA4B;AACxB,eAAO,IAAIJ,OAAJ,CAAY,CAACb,OAAD,EAAUc,MAAV,KAAqB;AACpC/D,qBAASmE,UAAT,CAAoB,MAAM;AACtBlB;AACH,aAFD,EAEGiB,OAFH;AAGH,SAJM,CAAP;AAKH;AACD;;;AAGA,WAAOb,qBAAP,CAA6BP,WAA7B,EAA0CC,YAA1C,EAAwD;AACpD,YAAIqB,oBAAoB,KAAxB;AACA;AACA,cAAMjD,MAAMM,QAAQN,GAApB;AACA,cAAMsC,YAAYjB,SAAS6B,aAAT,CAAuBlD,GAAvB,CAAlB;AACA,YAAI,CAACsC,SAAL,EAAgB;AACZ,kBAAM,IAAIlC,KAAJ,CAAW,qDAAX,CAAN;AACH;AACD,cAAM+C,kBAAkB9B,SAASK,eAAT,CAAyBC,WAAzB,EAAsCC,YAAtC,CAAxB;AACA,YAAIwB,cAAJ;AACA,YAAIC,QAAJ;AACA,YAAI;AACA;AACA;AACA;AACAD,6BAAiBrE,aAAauE,UAAb,CAAwBC,IAAxB,CAA6BJ,eAA7B,CAAjB;AACAC,2BAAeI,KAAf,CAAqBlB,SAArB;AACA,kBAAMmB,qBAAqB3E,aAAagC,UAAb,CAAwB4C,aAAxB,CAAsCP,eAAtC,EAAuDQ,SAAvD,CAAiEC,OAAjE,EAA3B;AACA,gBAAIC,sBAAsBJ,kBAA1B;AACA,gBAAIK,uBAAuB9D,IAAIE,QAAJ,EAA3B;AACA;AACA,kBAAM6D,QAAQjF,aAAagC,UAAb,CAAwBkD,UAAxB,CAAmCrC,WAAnC,CAAd;AACA;AACA,kBAAMsC,iBAAiB,uBAAvB;AACA,gBAAIpC,KAAJ;AACA,gBAAIqC,QAAJ;AACA,iBAAK,MAAMC,YAAX,IAA2BJ,KAA3B,EAAkC;AAC9B,oBAAI,CAAClC,QAAQsC,aAAatC,KAAb,CAAmBoC,cAAnB,CAAT,KACIpC,MAAM,CAAN,MAAaD,YADjB,IAEI,CAACsC,WAAWrC,MAAM,CAAN,CAAZ,MAA0B7B,IAAIE,QAAJ,EAFlC,EAEmD;AAC/C;AACA,0BAAMkE,mBAAmB1F,KAAKkB,IAAL,CAAU+B,WAAV,EAAuBwC,YAAvB,CAAzB;AACAlB,wCAAoB,IAApB;AACA;AACA,0BAAMoB,2BAA2BhD,SAAS6B,aAAT,CAAuBoB,SAASJ,QAAT,EAAmB,EAAnB,CAAvB,CAAjC;AACA,wBAAIK,oBAAJ;AACA,wBAAIC,gBAAJ;AACA,wBAAI;AACAD,+CAAuBzF,aAAagC,UAAb,CAAwBC,QAAxB,CAAiCqD,gBAAjC,CAAvB;AACA;AACAI,2CAAmB1F,aAAagC,UAAb,CAAwB4C,aAAxB,CAAsCU,gBAAtC,EAAwDT,SAAxD,CAAkEC,OAAlE,EAAnB;AACH,qBAJD,CAKA,OAAOa,GAAP,EAAY,CAEX;AADG;;AAEJ;AACA;AACA;AACA;AACA;AACA,wBAAIF,yBAAyB,EAAzB,IAA+BC,qBAAqB/E,SAAxD,EAAmE;AAC/D,4BAAI+E,mBAAmBf,kBAAvB,EAA2C;AACvC;AACA;AACA;AACA;AACH,yBALD,MAMK,IAAIe,mBAAmBf,kBAAnB,GAAwC,CAAxC,CAA0C;AAA1C,2BACFe,mBAAmBf,kBAAnB,GAAwC,CAAC,IAD3C,EACiD;AAAE;AACpD;AACA,mCAAOhE,SAAP;AACH;AACJ;AACD;AACA;AACA;AACA,wBAAI,CAAC4E,wBAAD,IAA6BE,yBAAyBF,wBAA1D,EAAoF;AAChF;AACAvF,qCAAagC,UAAb,CAAwB4D,UAAxB,CAAmCN,gBAAnC;AACA;AACH;AACD;AACA;AACA;AACA,wBAAII,qBAAqB/E,SAArB,IAAkC+E,mBAAmBX,mBAAzD,EAA8E;AAC1EA,8CAAsBW,gBAAtB;AACAV,+CAAuBI,QAAvB;AACH;AACJ;AACJ;AACD,gBAAIJ,yBAAyB9D,IAAIE,QAAJ,EAA7B,EAA6C;AACzC;AACA,uBAAOT,SAAP;AACH;AACD;AACA4D,uBAAW,IAAIhC,QAAJ,CAAa+B,cAAb,EAA6BD,eAA7B,EAA8CF,iBAA9C,CAAX;AACAG,6BAAiB3D,SAAjB,CA3EA,CA2E4B;AAC/B,SA5ED,SA6EQ;AACJ,gBAAI2D,cAAJ,EAAoB;AAChB;AACAA,+BAAeuB,KAAf;AACA7F,6BAAagC,UAAb,CAAwB4D,UAAxB,CAAmCvB,eAAnC;AACH;AACJ;AACD,eAAOE,QAAP;AACH;AACD;;;;AAIA,WAAOpB,kBAAP,CAA0BN,WAA1B,EAAuCC,YAAvC,EAAqD;AACjD,cAAMgD,eAAevD,SAASK,eAAT,CAAyBC,WAAzB,EAAsCC,YAAtC,CAArB;AACA,YAAIqB,oBAAoB,KAAxB;AACA,YAAI4B,UAAJ;AACA,YAAIxB,QAAJ;AACA,YAAI;AACA,gBAAIvE,aAAagC,UAAb,CAAwBgE,MAAxB,CAA+BF,YAA/B,CAAJ,EAAkD;AAC9C3B,oCAAoB,IAApB;AACA;AACA;AACA;AACA;AACAnE,6BAAagC,UAAb,CAAwB4D,UAAxB,CAAmCE,YAAnC;AACH;AACD,gBAAI;AACA;AACAC,6BAAa9F,aAAauE,UAAb,CAAwBC,IAAxB,CAA6BqB,YAA7B,EAA2C,EAAEG,WAAW,IAAb,EAA3C,CAAb;AACH,aAHD,CAIA,OAAO/D,KAAP,EAAc;AACV;AACA;AACA,uBAAOvB,SAAP;AACH;AACD;AACA4D,uBAAW,IAAIhC,QAAJ,CAAawD,UAAb,EAAyBD,YAAzB,EAAuC3B,iBAAvC,CAAX;AACA4B,yBAAapF,SAAb;AACH,SArBD,SAsBQ;AACJ,gBAAIoF,UAAJ,EAAgB;AACZA,2BAAWF,KAAX;AACH;AACJ;AACD,eAAOtB,QAAP;AACH;AACD;;;;AAIA2B,cAAU;AACN,YAAI,KAAKC,UAAT,EAAqB;AACjB,kBAAM,IAAI7E,KAAJ,CAAW,sBAAqB1B,KAAKwG,QAAL,CAAc,KAAK1D,SAAnB,CAA8B,8BAA9D,CAAN;AACH;AACD,aAAKD,WAAL,CAAiBoD,KAAjB;AACA7F,qBAAagC,UAAb,CAAwB4D,UAAxB,CAAmC,KAAKlD,SAAxC;AACA,aAAKD,WAAL,GAAmB9B,SAAnB;AACH;AACD;;;;AAIA,QAAIwD,iBAAJ,GAAwB;AACpB,eAAO,KAAKxB,kBAAZ;AACH;AACD;;;AAGA,QAAI0D,QAAJ,GAAe;AACX,eAAO,KAAK3D,SAAZ;AACH;AACD;;;AAGA,QAAIyD,UAAJ,GAAiB;AACb,eAAO,KAAK1D,WAAL,KAAqB9B,SAA5B;AACH;AA7OU;AA+Of4B,SAAS6B,aAAT,GAAyBnD,mBAAzB;AACAvB,QAAQ6C,QAAR,GAAmBA,QAAnB;AACA","file":"LockFile.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst child_process = require(\"child_process\");\nconst timers_1 = require(\"timers\");\nconst FileSystem_1 = require(\"./FileSystem\");\nconst FileWriter_1 = require(\"./FileWriter\");\n/**\n * http://man7.org/linux/man-pages/man5/proc.5.html\n * (22) starttime  %llu\n * The time the process started after system boot. In kernels before Linux 2.6, this value was\n * expressed in jiffies. Since Linux 2.6, the value is expressed in clock ticks (divide by\n * sysconf(_SC_CLK_TCK)).\n * The format for this field was %lu before Linux 2.6.\n */\nconst procStatStartTimePos = 22;\n/**\n * Parses the process start time from the contents of a linux /proc/[pid]/stat file.\n * @param stat - The contents of a linux /proc/[pid]/stat file.\n * @returns The process start time in jiffies, or undefined if stat has an unexpected format.\n */\nfunction getProcessStartTimeFromProcStat(stat) {\n    // Parse the value at position procStatStartTimePos.\n    // We cannot just split stat on spaces, because value 2 may contain spaces.\n    // For example, when running the following Shell commands:\n    // > cp \"$(which bash)\" ./'bash 2)('\n    // > ./'bash 2)(' -c 'OWNPID=$BASHPID;cat /proc/$OWNPID/stat'\n    // 59389 (bash 2)() S 59358 59389 59358 34818 59389 4202496 329 0 0 0 0 0 0 0 20 0 1 0\n    // > rm -rf ./'bash 2)('\n    // The output shows a stat file such that value 2 contains spaces.\n    // To still umambiguously parse such output we assume no values after the second ends with a right parenthesis...\n    // trimRight to remove the trailing line terminator.\n    let values = stat.trimRight().split(' ');\n    let i = values.length - 1;\n    while (i >= 0 &&\n        // charAt returns an empty string if the index is out of bounds.\n        values[i].charAt(values[i].length - 1) !== ')') {\n        i -= 1;\n    }\n    // i is the index of the last part of the second value (but i need not be 1).\n    if (i < 1) {\n        // Format of stat has changed.\n        return undefined;\n    }\n    const value2 = values.slice(1, i + 1).join(' ');\n    values = [values[0], value2].concat(values.slice(i + 1));\n    if (values.length < procStatStartTimePos) {\n        // Older version of linux, or non-standard configuration of linux.\n        return undefined;\n    }\n    const startTimeJiffies = values[procStatStartTimePos - 1];\n    // In theory, the representations of start time returned by `cat /proc/[pid]/stat` and `ps -o lstart` can change\n    // while the system is running, but we assume this does not happen.\n    // So the caller can safely use this value as part of a unique process id (on the machine, without comparing\n    // accross reboots).\n    return startTimeJiffies;\n}\nexports.getProcessStartTimeFromProcStat = getProcessStartTimeFromProcStat;\n/**\n * Helper function that is exported for unit tests only.\n * Returns undefined if the process doesn't exist with that pid.\n */\nfunction getProcessStartTime(pid) {\n    const pidString = pid.toString();\n    if (pid < 0 || pidString.indexOf('e') >= 0 || pidString.indexOf('E') >= 0) {\n        throw new Error(`\"pid\" is negative or too large`);\n    }\n    let args;\n    if (process.platform === 'darwin') {\n        args = [`-p ${pidString}`, '-o lstart'];\n    }\n    else if (process.platform === 'linux') {\n        args = ['-p', pidString, '-o', 'lstart'];\n    }\n    else {\n        throw new Error(`Unsupported system: ${process.platform}`);\n    }\n    const psResult = child_process.spawnSync('ps', args, {\n        encoding: 'utf8'\n    });\n    const psStdout = psResult.stdout;\n    // If no process with PID pid exists then the exit code is non-zero on linux but stdout is not empty.\n    // But if no process exists we do not want to fall back on /proc/*/stat to determine the process\n    // start time, so we we additionally test for !psStdout. NOTE: !psStdout evaluates to true if\n    // zero bytes are written to stdout.\n    if (psResult.status !== 0 && !psStdout && process.platform === 'linux') {\n        // Try to read /proc/[pid]/stat and get the value at position procStatStartTimePos.\n        let stat;\n        try {\n            stat = FileSystem_1.FileSystem.readFile(`/proc/${pidString}/stat`);\n        }\n        catch (error) {\n            if (error.code !== 'ENOENT') {\n                throw error;\n            }\n            // Either no process with PID pid exists, or this version/configuration of linux is non-standard.\n            // We assume the former.\n            return undefined;\n        }\n        if (stat !== undefined) {\n            const startTimeJiffies = getProcessStartTimeFromProcStat(stat);\n            if (startTimeJiffies === undefined) {\n                throw new Error(`Could not retrieve the start time of process ${pidString} from the OS because the `\n                    + `contents of /proc/${pidString}/stat have an unexpected format`);\n            }\n            return startTimeJiffies;\n        }\n    }\n    // there was an error executing ps (zero bytes were written to stdout).\n    if (!psStdout) {\n        throw new Error(`Unexpected output from \"ps\" command`);\n    }\n    const psSplit = psStdout.split('\\n');\n    // successfuly able to run \"ps\", but no process was found\n    if (psSplit[1] === '') {\n        return undefined;\n    }\n    if (psSplit[1]) {\n        const trimmed = psSplit[1].trim();\n        if (trimmed.length > 10) {\n            return trimmed;\n        }\n    }\n    throw new Error(`Unexpected output from the \"ps\" command`);\n}\nexports.getProcessStartTime = getProcessStartTime;\n/**\n * A helper utility for working with file-based locks.\n * This class should only be used for locking resources across processes,\n * but should not be used for attempting to lock a resource in the same process.\n * @public\n */\nclass LockFile {\n    constructor(_fileWriter, _filePath, _dirtyWhenAcquired) {\n        this._fileWriter = _fileWriter;\n        this._filePath = _filePath;\n        this._dirtyWhenAcquired = _dirtyWhenAcquired;\n    }\n    /**\n     * Returns the path to the lockfile, should it be created successfully.\n     */\n    static getLockFilePath(resourceDir, resourceName, pid = process.pid) {\n        if (!resourceName.match(/^[a-zA-Z0-9][a-zA-Z0-9-.]+[a-zA-Z0-9]$/)) {\n            throw new Error(`The resource name \"${resourceName}\" is invalid.`\n                + ` It must be an alphanumberic string with only \"-\" or \".\" It must start with an alphanumeric character.`);\n        }\n        if (process.platform === 'win32') {\n            return path.join(path.resolve(resourceDir), `${resourceName}.lock`);\n        }\n        else if (process.platform === 'linux' || process.platform === 'darwin') {\n            return path.join(path.resolve(resourceDir), `${resourceName}#${pid}.lock`);\n        }\n        throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\n    }\n    /**\n     * Attempts to create a lockfile with the given filePath.\n     * If successful, returns a LockFile instance.\n     * If unable to get a lock, returns undefined.\n     * @param resourceName - the name of the resource we are locking on. Should be an alphabetic string.\n     */\n    static tryAcquire(resourceDir, resourceName) {\n        FileSystem_1.FileSystem.ensureFolder(resourceDir);\n        if (process.platform === 'win32') {\n            return LockFile._tryAcquireWindows(resourceDir, resourceName);\n        }\n        else if (process.platform === 'linux' || process.platform === 'darwin') {\n            return LockFile._tryAcquireMacOrLinux(resourceDir, resourceName);\n        }\n        throw new Error(`File locking not implemented for platform: \"${process.platform}\"`);\n    }\n    /**\n     * Attempts to create the lockfile.\n     * Will continue to loop at every 100ms until the lock becomes available or the maxWaitMs is surpassed.\n     * @remarks This function is subject to starvation, whereby it does not ensure that the process that has been\n     *          waiting the longest to acquire the lock will get it first. This means that a process could theoretically\n     *          wait for the lock forever, while other processes skipped it in line and acquired the lock first.\n     */\n    static acquire(resourceDir, resourceName, maxWaitMs) {\n        const interval = 100;\n        const startTime = Date.now();\n        const retryLoop = () => {\n            const lock = LockFile.tryAcquire(resourceDir, resourceName);\n            if (lock) {\n                return Promise.resolve(lock);\n            }\n            if (maxWaitMs && (Date.now() > startTime + maxWaitMs)) {\n                return Promise.reject(new Error(`Exceeded maximum wait time to acquire lock for resource \"${resourceName}\"`));\n            }\n            return LockFile._sleepForMs(interval).then(() => {\n                return retryLoop();\n            });\n        };\n        return retryLoop();\n    }\n    static _sleepForMs(timeout) {\n        return new Promise((resolve, reject) => {\n            timers_1.setTimeout(() => {\n                resolve();\n            }, timeout);\n        });\n    }\n    /**\n     * Attempts to acquire the lock on a Linux or OSX machine\n     */\n    static _tryAcquireMacOrLinux(resourceDir, resourceName) {\n        let dirtyWhenAcquired = false;\n        // get the current process' pid\n        const pid = process.pid;\n        const startTime = LockFile._getStartTime(pid);\n        if (!startTime) {\n            throw new Error(`Unable to calculate start time for current process.`);\n        }\n        const pidLockFilePath = LockFile.getLockFilePath(resourceDir, resourceName);\n        let lockFileHandle;\n        let lockFile;\n        try {\n            // open in write mode since if this file exists, it cannot be from the current process\n            // TODO: This will malfunction if the same process tries to acquire two locks on the same file.\n            // We should ideally maintain a dictionary of normalized acquired filenames\n            lockFileHandle = FileWriter_1.FileWriter.open(pidLockFilePath);\n            lockFileHandle.write(startTime);\n            const currentBirthTimeMs = FileSystem_1.FileSystem.getStatistics(pidLockFilePath).birthtime.getTime();\n            let smallestBirthTimeMs = currentBirthTimeMs;\n            let smallestBirthTimePid = pid.toString();\n            // now, scan the directory for all lockfiles\n            const files = FileSystem_1.FileSystem.readFolder(resourceDir);\n            // look for anything ending with # then numbers and \".lock\"\n            const lockFileRegExp = /^(.+)#([0-9]+)\\.lock$/;\n            let match;\n            let otherPid;\n            for (const fileInFolder of files) {\n                if ((match = fileInFolder.match(lockFileRegExp))\n                    && (match[1] === resourceName)\n                    && ((otherPid = match[2]) !== pid.toString())) {\n                    // we found at least one lockfile hanging around that isn't ours\n                    const fileInFolderPath = path.join(resourceDir, fileInFolder);\n                    dirtyWhenAcquired = true;\n                    // console.log(`FOUND OTHER LOCKFILE: ${otherPid}`);\n                    const otherPidCurrentStartTime = LockFile._getStartTime(parseInt(otherPid, 10));\n                    let otherPidOldStartTime;\n                    let otherBirthtimeMs;\n                    try {\n                        otherPidOldStartTime = FileSystem_1.FileSystem.readFile(fileInFolderPath);\n                        // check the timestamp of the file\n                        otherBirthtimeMs = FileSystem_1.FileSystem.getStatistics(fileInFolderPath).birthtime.getTime();\n                    }\n                    catch (err) {\n                        // this means the file is probably deleted already\n                    }\n                    // if the otherPidOldStartTime is invalid, then we should look at the timestamp,\n                    // if this file was created after us, ignore it\n                    // if it was created within 1 second before us, then it could be good, so we\n                    //  will conservatively fail\n                    // otherwise it is an old lock file and will be deleted\n                    if (otherPidOldStartTime === '' && otherBirthtimeMs !== undefined) {\n                        if (otherBirthtimeMs > currentBirthTimeMs) {\n                            // ignore this file, he will be unable to get the lock since this process\n                            // will hold it\n                            // console.log(`Ignoring lock for pid ${otherPid} because its lockfile is newer than ours.`);\n                            continue;\n                        }\n                        else if (otherBirthtimeMs - currentBirthTimeMs < 0 // it was created before us AND\n                            && otherBirthtimeMs - currentBirthTimeMs > -1000) { // it was created less than a second before\n                            // conservatively be unable to keep the lock\n                            return undefined;\n                        }\n                    }\n                    // console.log(`Other pid ${otherPid} lockfile has start time: \"${otherPidOldStartTime}\"`);\n                    // console.log(`Other pid ${otherPid} actually has start time: \"${otherPidCurrentStartTime}\"`);\n                    // this means the process is no longer executing, delete the file\n                    if (!otherPidCurrentStartTime || otherPidOldStartTime !== otherPidCurrentStartTime) {\n                        // console.log(`Other pid ${otherPid} is no longer executing!`);\n                        FileSystem_1.FileSystem.deleteFile(fileInFolderPath);\n                        continue;\n                    }\n                    // console.log(`Pid ${otherPid} lockfile has birth time: ${otherBirthtimeMs}`);\n                    // console.log(`Pid ${pid} lockfile has birth time: ${currentBirthTimeMs}`);\n                    // this is a lockfile pointing at something valid\n                    if (otherBirthtimeMs !== undefined && otherBirthtimeMs < smallestBirthTimeMs) {\n                        smallestBirthTimeMs = otherBirthtimeMs;\n                        smallestBirthTimePid = otherPid;\n                    }\n                }\n            }\n            if (smallestBirthTimePid !== pid.toString()) {\n                // we do not have the lock\n                return undefined;\n            }\n            // we have the lock!\n            lockFile = new LockFile(lockFileHandle, pidLockFilePath, dirtyWhenAcquired);\n            lockFileHandle = undefined; // we have handed the descriptor off to the instance\n        }\n        finally {\n            if (lockFileHandle) {\n                // ensure our lock is closed\n                lockFileHandle.close();\n                FileSystem_1.FileSystem.deleteFile(pidLockFilePath);\n            }\n        }\n        return lockFile;\n    }\n    /**\n     * Attempts to acquire the lock using Windows\n     * This algorithm is much simpler since we can rely on the operating system\n     */\n    static _tryAcquireWindows(resourceDir, resourceName) {\n        const lockFilePath = LockFile.getLockFilePath(resourceDir, resourceName);\n        let dirtyWhenAcquired = false;\n        let fileHandle;\n        let lockFile;\n        try {\n            if (FileSystem_1.FileSystem.exists(lockFilePath)) {\n                dirtyWhenAcquired = true;\n                // If the lockfile is held by an process with an exclusive lock, then removing it will\n                // silently fail. OpenSync() below will then fail and we will be unable to create a lock.\n                // Otherwise, the lockfile is sitting on disk, but nothing is holding it, implying that\n                // the last process to hold it died.\n                FileSystem_1.FileSystem.deleteFile(lockFilePath);\n            }\n            try {\n                // Attempt to open an exclusive lockfile\n                fileHandle = FileWriter_1.FileWriter.open(lockFilePath, { exclusive: true });\n            }\n            catch (error) {\n                // we tried to delete the lock, but something else is holding it,\n                // (probably an active process), therefore we are unable to create a lock\n                return undefined;\n            }\n            // Ensure we can hand off the file descriptor to the lockfile\n            lockFile = new LockFile(fileHandle, lockFilePath, dirtyWhenAcquired);\n            fileHandle = undefined;\n        }\n        finally {\n            if (fileHandle) {\n                fileHandle.close();\n            }\n        }\n        return lockFile;\n    }\n    /**\n     * Unlocks a file and removes it from disk.\n     * This can only be called once.\n     */\n    release() {\n        if (this.isReleased) {\n            throw new Error(`The lock for file \"${path.basename(this._filePath)}\" has already been released.`);\n        }\n        this._fileWriter.close();\n        FileSystem_1.FileSystem.deleteFile(this._filePath);\n        this._fileWriter = undefined;\n    }\n    /**\n     * Returns the initial state of the lock.\n     * This can be used to detect if the previous process was terminated before releasing the resource.\n     */\n    get dirtyWhenAcquired() {\n        return this._dirtyWhenAcquired;\n    }\n    /**\n     * Returns the absolute path to the lockfile\n     */\n    get filePath() {\n        return this._filePath;\n    }\n    /**\n     * Returns true if this lock is currently being held.\n     */\n    get isReleased() {\n        return this._fileWriter === undefined;\n    }\n}\nLockFile._getStartTime = getProcessStartTime;\nexports.LockFile = LockFile;\n//# sourceMappingURL=LockFile.js.map"]}