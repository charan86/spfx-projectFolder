{"version":3,"sources":["Executable.js"],"names":["Object","defineProperty","exports","value","child_process","require","os","path","FileSystem_1","Executable","spawnSync","filename","args","options","context","_getExecutableContext","resolvedPath","_tryResolve","Error","spawnOptions","cwd","currentWorkingDirectory","env","environment","input","stdio","timeout","timeoutMs","maxBuffer","encoding","shell","process","fileExtension","extname","platform","toUpperCase","_validateArgsForWindowsShell","shellPath","COMSPEC","_canExecute","tryResolve","basename","shellArgs","push","_getEscapedForWindowsShell","hasPathSeparators","indexOf","resolve","_tryResolveFileExtension","pathsToSearch","_getSearchFolders","pathToSearch","join","result","undefined","shellExtension","windowsExecutableExtensions","resolvedNameWithExtension","filePath","FileSystem","exists","getPosixModeBits","error","pathList","PATH","folders","seenPaths","Set","splitPath","split","delimiter","trimmedPath","trim","has","add","pathExtVariable","PATHEXT","splitValue","trimmed","toLowerCase","test","text","escapableCharRegExp","replace","specialCharRegExp","arg","match","JSON","stringify"],"mappings":"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","file":"Executable.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst child_process = require(\"child_process\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst FileSystem_1 = require(\"./FileSystem\");\n/**\n * The Executable class provides a safe, portable, recommended solution for tools that need\n * to launch child processes.\n *\n * @remarks\n * The NodeJS child_process API provides a solution for launching child processes, however\n * its design encourages reliance on the operating system shell for certain features.\n * Invoking the OS shell is not safe, not portable, and generally not recommended:\n *\n * - Different shells have different behavior and command-line syntax, and which shell you\n *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be\n *   available on all platforms.\n *\n * - If a command parameter contains symbol characters, a shell may interpret them, which\n *   can introduce a security vulnerability\n *\n * - Each shell has different rules for escaping these symbols.  On Windows, the default\n *   shell is incapable of escaping certain character sequences.\n *\n * The Executable API provides a pure JavaScript implementation of primitive shell-like\n * functionality for searching the default PATH, appending default file extensions on Windows,\n * and executing a file that may contain a POSIX shebang.  This primitive functionality\n * is sufficient (and recommended) for most tooling scenarios.\n *\n * If you need additional shell features such as wildcard globbing, environment variable\n * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`\n * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is\n * guaranteed to work consistently across all platforms.\n *\n * @public\n */\nclass Executable {\n    /**\n     * Synchronously create a child process and optionally capture its output.\n     *\n     * @remarks\n     * This function is similar to child_process.spawnSync().  The main differences are:\n     *\n     * - It does not invoke the OS shell unless the executable file is a shell script.\n     * - Command-line arguments containing special characters are more accurately passed\n     *   through to the child process.\n     * - If the filename is missing a path, then the shell's default PATH will be searched.\n     * - If the filename is missing a file extension, then Windows default file extensions\n     *   will be searched.\n     *\n     * @param filename - The name of the executable file.  This string must not contain any\n     * command-line arguments.  If the name contains any path delimiters, then the shell's\n     * default PATH will not be searched.\n     * @param args - The command-line arguments to be passed to the process.\n     * @param options - Additional options\n     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API\n     *\n     * @privateRemarks\n     *\n     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>\n     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing\n     * design.  In most cases, developers want string with the default encoding.  If/when someone\n     * wants binary output or a non-default text encoding, we will introduce a separate API function\n     * with a name like \"spawnWithBufferSync\".\n     */\n    static spawnSync(filename, args, options) {\n        if (!options) {\n            options = {};\n        }\n        const context = Executable._getExecutableContext(options);\n        const resolvedPath = Executable._tryResolve(filename, options, context);\n        if (!resolvedPath) {\n            throw new Error(`The executable file was not found: \"${filename}\"`);\n        }\n        const spawnOptions = {\n            cwd: context.currentWorkingDirectory,\n            env: context.environment,\n            input: options.input,\n            stdio: options.stdio,\n            timeout: options.timeoutMs,\n            maxBuffer: options.maxBuffer,\n            // Contrary to what the NodeJS typings imply, we must explicitly specify \"utf8\" here\n            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.\n            encoding: 'utf8',\n            // NOTE: This is always false, because Rushell is recommended instead of relying on the OS shell.\n            shell: false\n        };\n        // PROBLEM: Given an \"args\" array of strings that may contain special characters (e.g. spaces,\n        // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array\n        // without anything getting corrupted along the way.\n        //\n        // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:\n        // - The Win32 CreateProcess() API expects the args to be encoded as a single text string\n        // - The decoding of this string is up to the application (not the OS), and there are 3 different\n        //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and\n        //   the Win32 CommandLineToArgvW()\n        // - The encodings are counterintuitive and have lots of special cases\n        // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used\n        //\n        // See these articles for a full analysis:\n        // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/\n        // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/\n        const environment = options && options.environment\n            || process.env;\n        const fileExtension = path.extname(resolvedPath);\n        if (os.platform() === 'win32') {\n            // Do we need a custom handler for this file type?\n            switch (fileExtension.toUpperCase()) {\n                case '.EXE':\n                case '.COM':\n                    // okay to execute directly\n                    break;\n                case '.BAT':\n                case '.CMD': {\n                    Executable._validateArgsForWindowsShell(args);\n                    // These file types must be invoked via the Windows shell\n                    let shellPath = environment.COMSPEC;\n                    if (!shellPath || !Executable._canExecute(shellPath, context)) {\n                        shellPath = Executable.tryResolve('cmd.exe');\n                    }\n                    if (!shellPath) {\n                        throw new Error(`Unable to execute \"${path.basename(resolvedPath)}\" `\n                            + `because CMD.exe was not found in the PATH`);\n                    }\n                    const shellArgs = [];\n                    // /D: Disable execution of AutoRun commands when starting the new shell context\n                    shellArgs.push('/d');\n                    // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line\n                    shellArgs.push('/s');\n                    // /C: Execute the following command and then exit immediately\n                    shellArgs.push('/c');\n                    // If the path contains special charactrers (e.g. spaces), escape them so that\n                    // they don't get interpreted by the shell\n                    shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));\n                    shellArgs.push(...args);\n                    return child_process.spawnSync(shellPath, shellArgs, spawnOptions);\n                }\n                default:\n                    throw new Error(`Cannot execute \"${path.basename(resolvedPath)}\" because the file type is not supported`);\n            }\n        }\n        return child_process.spawnSync(resolvedPath, args, spawnOptions);\n    }\n    /**\n     * Given a filename, this determines the absolute path of the executable file that would\n     * be executed by a shell:\n     *\n     * - If the filename is missing a path, then the shell's default PATH will be searched.\n     * - If the filename is missing a file extension, then Windows default file extensions\n     *   will be searched.\n     *\n     * @remarks\n     *\n     * @param filename - The name of the executable file.  This string must not contain any\n     * command-line arguments.  If the name contains any path delimiters, then the shell's\n     * default PATH will not be searched.\n     * @param options - optional other parameters\n     * @returns the absolute path of the executable, or undefined if it was not found\n     */\n    static tryResolve(filename, options) {\n        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));\n    }\n    static _tryResolve(filename, options, context) {\n        // NOTE: Since \"filename\" cannot contain command-line arguments, the \"/\" here\n        // must be interpreted as a path delimiter\n        const hasPathSeparators = filename.indexOf('/') >= 0\n            || (os.platform() === 'win32' && filename.indexOf('\\\\') >= 0);\n        // Are there any path separators?\n        if (hasPathSeparators) {\n            // If so, then don't search the PATH.  Just resolve relative to the current working directory\n            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);\n            return Executable._tryResolveFileExtension(resolvedPath, context);\n        }\n        else {\n            // Otherwise if it's a bare name, then try everything in the shell PATH\n            const pathsToSearch = Executable._getSearchFolders(context);\n            for (const pathToSearch of pathsToSearch) {\n                const resolvedPath = path.join(pathToSearch, filename);\n                const result = Executable._tryResolveFileExtension(resolvedPath, context);\n                if (result) {\n                    return result;\n                }\n            }\n            // No match was found\n            return undefined;\n        }\n    }\n    static _tryResolveFileExtension(resolvedPath, context) {\n        if (Executable._canExecute(resolvedPath, context)) {\n            return resolvedPath;\n        }\n        // Try the default file extensions\n        for (const shellExtension of context.windowsExecutableExtensions) {\n            const resolvedNameWithExtension = resolvedPath + shellExtension;\n            if (Executable._canExecute(resolvedNameWithExtension, context)) {\n                return resolvedNameWithExtension;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * This is used when searching the shell PATH for an executable, to determine\n     * whether a match should be skipped or not.  If it returns true, this does not\n     * guarantee that the file can be successfully executed.\n     */\n    static _canExecute(filePath, context) {\n        if (!FileSystem_1.FileSystem.exists(filePath)) {\n            return false;\n        }\n        if (os.platform() === 'win32') {\n            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.\n            // That environment variable determines which extensions can be appended if the\n            // extension is missing, but it does not affect whether a file may be executed or not.\n            // Windows does have a (seldom used) ACL that can be used to deny execution permissions\n            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.\n            // However, Windows *does* require that the file has some kind of file extension\n            if (path.extname(filePath) === '') {\n                return false;\n            }\n        }\n        else {\n            // For Unix, check whether any of the POSIX execute bits are set\n            try {\n                // eslint-disable-next-line no-bitwise\n                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {\n                    return false; // not executable\n                }\n            }\n            catch (error) {\n                // If we have trouble accessing the file, ignore the error and consider it \"not executable\"\n                // since that's what a shell would do\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns the list of folders where we will search for an executable,\n     * based on the PATH environment variable.\n     */\n    static _getSearchFolders(context) {\n        const pathList = context.environment.PATH || '';\n        const folders = [];\n        // Avoid processing duplicates\n        const seenPaths = new Set();\n        // NOTE: Cmd.exe on Windows always searches the current working directory first.\n        // PowerShell and Unix shells do NOT do that, because it's a security concern.\n        // We follow their behavior.\n        for (const splitPath of pathList.split(path.delimiter)) {\n            const trimmedPath = splitPath.trim();\n            if (trimmedPath !== '') {\n                if (!seenPaths.has(trimmedPath)) {\n                    // Fun fact: If you put relative paths in your PATH environment variable,\n                    // all shells will dynamically match them against the current working directory.\n                    // This is a terrible design, and in practice nobody does that, but it is supported...\n                    // so we allow it here.\n                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);\n                    if (!seenPaths.has(resolvedPath)) {\n                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {\n                            folders.push(resolvedPath);\n                        }\n                        seenPaths.add(resolvedPath);\n                    }\n                    seenPaths.add(trimmedPath);\n                }\n            }\n        }\n        return folders;\n    }\n    static _getExecutableContext(options) {\n        if (!options) {\n            options = {};\n        }\n        const environment = options.environment || process.env;\n        let currentWorkingDirectory;\n        if (options.currentWorkingDirectory) {\n            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);\n        }\n        else {\n            currentWorkingDirectory = process.cwd();\n        }\n        const windowsExecutableExtensions = [];\n        if (os.platform() === 'win32') {\n            const pathExtVariable = environment.PATHEXT || '';\n            for (const splitValue of pathExtVariable.split(';')) {\n                const trimmed = splitValue.trim().toLowerCase();\n                // Ignore malformed extensions\n                if (/^\\.[a-z0-9\\.]*[a-z0-9]$/i.test(trimmed)) {\n                    // Don't add the same extension twice\n                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {\n                        windowsExecutableExtensions.push(trimmed);\n                    }\n                }\n            }\n        }\n        return {\n            environment,\n            currentWorkingDirectory,\n            windowsExecutableExtensions\n        };\n    }\n    /**\n     * Given an input string containing special symbol characters, this inserts the \"^\" escape\n     * character to ensure the symbols are interpreted literally by the Windows shell.\n     */\n    static _getEscapedForWindowsShell(text) {\n        const escapableCharRegExp = /[%\\^&|<> ]/g;\n        return text.replace(escapableCharRegExp, (value) => '^' + value);\n    }\n    /**\n     * Checks for characters that are unsafe to pass to a Windows batch file\n     * due to the way that cmd.exe implements escaping.\n     */\n    static _validateArgsForWindowsShell(args) {\n        const specialCharRegExp = /[%\\^&|<>\\r\\n]/g;\n        for (const arg of args) {\n            const match = arg.match(specialCharRegExp);\n            if (match) {\n                // NOTE: It is possible to escape some of these characters by prefixing them\n                // with a caret (^), which allows these characters to be successfully passed\n                // through to the batch file %1 variables.  But they will be expanded again\n                // whenever they are used.  For example, NPM's binary wrapper batch files\n                // use \"%*\" to pass their arguments to Node.exe, which causes them to be expanded\n                // again.  Unfortunately the Cmd.exe batch language provides native escaping\n                // function (that could be used to insert the carets again).\n                //\n                // We could work around that by adding double carets, but in general there\n                // is no way to predict how many times the variable will get expanded.\n                // Thus, there is no generally reliable way to pass these characters.\n                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a`\n                    + ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);\n            }\n        }\n    }\n}\nexports.Executable = Executable;\n//# sourceMappingURL=Executable.js.map"]}