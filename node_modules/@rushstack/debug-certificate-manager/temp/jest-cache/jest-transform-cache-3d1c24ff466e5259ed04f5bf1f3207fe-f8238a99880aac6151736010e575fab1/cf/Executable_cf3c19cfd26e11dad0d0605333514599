47a769e3b687309a6abd8f4df076f476
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const FileSystem_1 = require("./FileSystem");
/**
 * The Executable class provides a safe, portable, recommended solution for tools that need
 * to launch child processes.
 *
 * @remarks
 * The NodeJS child_process API provides a solution for launching child processes, however
 * its design encourages reliance on the operating system shell for certain features.
 * Invoking the OS shell is not safe, not portable, and generally not recommended:
 *
 * - Different shells have different behavior and command-line syntax, and which shell you
 *   will get with NodeJS is unpredictable.  There is no universal shell guaranteed to be
 *   available on all platforms.
 *
 * - If a command parameter contains symbol characters, a shell may interpret them, which
 *   can introduce a security vulnerability
 *
 * - Each shell has different rules for escaping these symbols.  On Windows, the default
 *   shell is incapable of escaping certain character sequences.
 *
 * The Executable API provides a pure JavaScript implementation of primitive shell-like
 * functionality for searching the default PATH, appending default file extensions on Windows,
 * and executing a file that may contain a POSIX shebang.  This primitive functionality
 * is sufficient (and recommended) for most tooling scenarios.
 *
 * If you need additional shell features such as wildcard globbing, environment variable
 * expansion, piping, or built-in commands, then we recommend to use the `@microsoft/rushell`
 * library instead.  Rushell is a pure JavaScript shell with a standard syntax that is
 * guaranteed to work consistently across all platforms.
 *
 * @public
 */
class Executable {
    /**
     * Synchronously create a child process and optionally capture its output.
     *
     * @remarks
     * This function is similar to child_process.spawnSync().  The main differences are:
     *
     * - It does not invoke the OS shell unless the executable file is a shell script.
     * - Command-line arguments containing special characters are more accurately passed
     *   through to the child process.
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param args - The command-line arguments to be passed to the process.
     * @param options - Additional options
     * @returns the same data type as returned by the NodeJS child_process.spawnSync() API
     *
     * @privateRemarks
     *
     * NOTE: The NodeJS spawnSync() returns SpawnSyncReturns<string> or SpawnSyncReturns<Buffer>
     * polymorphically based on the options.encoding parameter value.  This is a fairly confusing
     * design.  In most cases, developers want string with the default encoding.  If/when someone
     * wants binary output or a non-default text encoding, we will introduce a separate API function
     * with a name like "spawnWithBufferSync".
     */
    static spawnSync(filename, args, options) {
        if (!options) {
            options = {};
        }
        const context = Executable._getExecutableContext(options);
        const resolvedPath = Executable._tryResolve(filename, options, context);
        if (!resolvedPath) {
            throw new Error(`The executable file was not found: "${filename}"`);
        }
        const spawnOptions = {
            cwd: context.currentWorkingDirectory,
            env: context.environment,
            input: options.input,
            stdio: options.stdio,
            timeout: options.timeoutMs,
            maxBuffer: options.maxBuffer,
            // Contrary to what the NodeJS typings imply, we must explicitly specify "utf8" here
            // if we want the result to be SpawnSyncReturns<string> instead of SpawnSyncReturns<Buffer>.
            encoding: 'utf8',
            // NOTE: This is always false, because Rushell is recommended instead of relying on the OS shell.
            shell: false
        };
        // PROBLEM: Given an "args" array of strings that may contain special characters (e.g. spaces,
        // backslashes, quotes), ensure that these strings pass through to the child process's ARGV array
        // without anything getting corrupted along the way.
        //
        // On Unix you just pass the array to spawnSync().  But on Windows, this is a very complex problem:
        // - The Win32 CreateProcess() API expects the args to be encoded as a single text string
        // - The decoding of this string is up to the application (not the OS), and there are 3 different
        //   algorithms in common usage:  the cmd.exe shell, the Microsoft CRT library init code, and
        //   the Win32 CommandLineToArgvW()
        // - The encodings are counterintuitive and have lots of special cases
        // - NodeJS spawnSync() tries do the encoding without knowing which decoder will be used
        //
        // See these articles for a full analysis:
        // http://www.windowsinspired.com/understanding-the-command-line-string-and-arguments-received-by-a-windows-program/
        // http://www.windowsinspired.com/how-a-windows-programs-splits-its-command-line-into-individual-arguments/
        const environment = options && options.environment || process.env;
        const fileExtension = path.extname(resolvedPath);
        if (os.platform() === 'win32') {
            // Do we need a custom handler for this file type?
            switch (fileExtension.toUpperCase()) {
                case '.EXE':
                case '.COM':
                    // okay to execute directly
                    break;
                case '.BAT':
                case '.CMD':
                    {
                        Executable._validateArgsForWindowsShell(args);
                        // These file types must be invoked via the Windows shell
                        let shellPath = environment.COMSPEC;
                        if (!shellPath || !Executable._canExecute(shellPath, context)) {
                            shellPath = Executable.tryResolve('cmd.exe');
                        }
                        if (!shellPath) {
                            throw new Error(`Unable to execute "${path.basename(resolvedPath)}" ` + `because CMD.exe was not found in the PATH`);
                        }
                        const shellArgs = [];
                        // /D: Disable execution of AutoRun commands when starting the new shell context
                        shellArgs.push('/d');
                        // /S: Disable Cmd.exe's parsing of double-quote characters inside the command-line
                        shellArgs.push('/s');
                        // /C: Execute the following command and then exit immediately
                        shellArgs.push('/c');
                        // If the path contains special charactrers (e.g. spaces), escape them so that
                        // they don't get interpreted by the shell
                        shellArgs.push(Executable._getEscapedForWindowsShell(resolvedPath));
                        shellArgs.push(...args);
                        return child_process.spawnSync(shellPath, shellArgs, spawnOptions);
                    }
                default:
                    throw new Error(`Cannot execute "${path.basename(resolvedPath)}" because the file type is not supported`);
            }
        }
        return child_process.spawnSync(resolvedPath, args, spawnOptions);
    }
    /**
     * Given a filename, this determines the absolute path of the executable file that would
     * be executed by a shell:
     *
     * - If the filename is missing a path, then the shell's default PATH will be searched.
     * - If the filename is missing a file extension, then Windows default file extensions
     *   will be searched.
     *
     * @remarks
     *
     * @param filename - The name of the executable file.  This string must not contain any
     * command-line arguments.  If the name contains any path delimiters, then the shell's
     * default PATH will not be searched.
     * @param options - optional other parameters
     * @returns the absolute path of the executable, or undefined if it was not found
     */
    static tryResolve(filename, options) {
        return Executable._tryResolve(filename, options || {}, Executable._getExecutableContext(options));
    }
    static _tryResolve(filename, options, context) {
        // NOTE: Since "filename" cannot contain command-line arguments, the "/" here
        // must be interpreted as a path delimiter
        const hasPathSeparators = filename.indexOf('/') >= 0 || os.platform() === 'win32' && filename.indexOf('\\') >= 0;
        // Are there any path separators?
        if (hasPathSeparators) {
            // If so, then don't search the PATH.  Just resolve relative to the current working directory
            const resolvedPath = path.resolve(context.currentWorkingDirectory, filename);
            return Executable._tryResolveFileExtension(resolvedPath, context);
        } else {
            // Otherwise if it's a bare name, then try everything in the shell PATH
            const pathsToSearch = Executable._getSearchFolders(context);
            for (const pathToSearch of pathsToSearch) {
                const resolvedPath = path.join(pathToSearch, filename);
                const result = Executable._tryResolveFileExtension(resolvedPath, context);
                if (result) {
                    return result;
                }
            }
            // No match was found
            return undefined;
        }
    }
    static _tryResolveFileExtension(resolvedPath, context) {
        if (Executable._canExecute(resolvedPath, context)) {
            return resolvedPath;
        }
        // Try the default file extensions
        for (const shellExtension of context.windowsExecutableExtensions) {
            const resolvedNameWithExtension = resolvedPath + shellExtension;
            if (Executable._canExecute(resolvedNameWithExtension, context)) {
                return resolvedNameWithExtension;
            }
        }
        return undefined;
    }
    /**
     * This is used when searching the shell PATH for an executable, to determine
     * whether a match should be skipped or not.  If it returns true, this does not
     * guarantee that the file can be successfully executed.
     */
    static _canExecute(filePath, context) {
        if (!FileSystem_1.FileSystem.exists(filePath)) {
            return false;
        }
        if (os.platform() === 'win32') {
            // NOTE: For Windows, we don't validate that the file extension appears in PATHEXT.
            // That environment variable determines which extensions can be appended if the
            // extension is missing, but it does not affect whether a file may be executed or not.
            // Windows does have a (seldom used) ACL that can be used to deny execution permissions
            // for a file, but NodeJS doesn't expose that API, so we don't bother checking it.
            // However, Windows *does* require that the file has some kind of file extension
            if (path.extname(filePath) === '') {
                return false;
            }
        } else {
            // For Unix, check whether any of the POSIX execute bits are set
            try {
                // eslint-disable-next-line no-bitwise
                if ((FileSystem_1.FileSystem.getPosixModeBits(filePath) & 73 /* AllExecute */) === 0) {
                    return false; // not executable
                }
            } catch (error) {
                // If we have trouble accessing the file, ignore the error and consider it "not executable"
                // since that's what a shell would do
            }
        }
        return true;
    }
    /**
     * Returns the list of folders where we will search for an executable,
     * based on the PATH environment variable.
     */
    static _getSearchFolders(context) {
        const pathList = context.environment.PATH || '';
        const folders = [];
        // Avoid processing duplicates
        const seenPaths = new Set();
        // NOTE: Cmd.exe on Windows always searches the current working directory first.
        // PowerShell and Unix shells do NOT do that, because it's a security concern.
        // We follow their behavior.
        for (const splitPath of pathList.split(path.delimiter)) {
            const trimmedPath = splitPath.trim();
            if (trimmedPath !== '') {
                if (!seenPaths.has(trimmedPath)) {
                    // Fun fact: If you put relative paths in your PATH environment variable,
                    // all shells will dynamically match them against the current working directory.
                    // This is a terrible design, and in practice nobody does that, but it is supported...
                    // so we allow it here.
                    const resolvedPath = path.resolve(context.currentWorkingDirectory, trimmedPath);
                    if (!seenPaths.has(resolvedPath)) {
                        if (FileSystem_1.FileSystem.exists(resolvedPath)) {
                            folders.push(resolvedPath);
                        }
                        seenPaths.add(resolvedPath);
                    }
                    seenPaths.add(trimmedPath);
                }
            }
        }
        return folders;
    }
    static _getExecutableContext(options) {
        if (!options) {
            options = {};
        }
        const environment = options.environment || process.env;
        let currentWorkingDirectory;
        if (options.currentWorkingDirectory) {
            currentWorkingDirectory = path.resolve(options.currentWorkingDirectory);
        } else {
            currentWorkingDirectory = process.cwd();
        }
        const windowsExecutableExtensions = [];
        if (os.platform() === 'win32') {
            const pathExtVariable = environment.PATHEXT || '';
            for (const splitValue of pathExtVariable.split(';')) {
                const trimmed = splitValue.trim().toLowerCase();
                // Ignore malformed extensions
                if (/^\.[a-z0-9\.]*[a-z0-9]$/i.test(trimmed)) {
                    // Don't add the same extension twice
                    if (windowsExecutableExtensions.indexOf(trimmed) < 0) {
                        windowsExecutableExtensions.push(trimmed);
                    }
                }
            }
        }
        return {
            environment,
            currentWorkingDirectory,
            windowsExecutableExtensions
        };
    }
    /**
     * Given an input string containing special symbol characters, this inserts the "^" escape
     * character to ensure the symbols are interpreted literally by the Windows shell.
     */
    static _getEscapedForWindowsShell(text) {
        const escapableCharRegExp = /[%\^&|<> ]/g;
        return text.replace(escapableCharRegExp, value => '^' + value);
    }
    /**
     * Checks for characters that are unsafe to pass to a Windows batch file
     * due to the way that cmd.exe implements escaping.
     */
    static _validateArgsForWindowsShell(args) {
        const specialCharRegExp = /[%\^&|<>\r\n]/g;
        for (const arg of args) {
            const match = arg.match(specialCharRegExp);
            if (match) {
                // NOTE: It is possible to escape some of these characters by prefixing them
                // with a caret (^), which allows these characters to be successfully passed
                // through to the batch file %1 variables.  But they will be expanded again
                // whenever they are used.  For example, NPM's binary wrapper batch files
                // use "%*" to pass their arguments to Node.exe, which causes them to be expanded
                // again.  Unfortunately the Cmd.exe batch language provides native escaping
                // function (that could be used to insert the carets again).
                //
                // We could work around that by adding double carets, but in general there
                // is no way to predict how many times the variable will get expanded.
                // Thus, there is no generally reliable way to pass these characters.
                throw new Error(`The command line argument ${JSON.stringify(arg)} contains a` + ` special character ${JSON.stringify(match[0])} that cannot be escaped for the Windows shell`);
            }
        }
    }
}
exports.Executable = Executable;
//# sourceMappingURL=Executable.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkV4ZWN1dGFibGUuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGlsZF9wcm9jZXNzIiwicmVxdWlyZSIsIm9zIiwicGF0aCIsIkZpbGVTeXN0ZW1fMSIsIkV4ZWN1dGFibGUiLCJzcGF3blN5bmMiLCJmaWxlbmFtZSIsImFyZ3MiLCJvcHRpb25zIiwiY29udGV4dCIsIl9nZXRFeGVjdXRhYmxlQ29udGV4dCIsInJlc29sdmVkUGF0aCIsIl90cnlSZXNvbHZlIiwiRXJyb3IiLCJzcGF3bk9wdGlvbnMiLCJjd2QiLCJjdXJyZW50V29ya2luZ0RpcmVjdG9yeSIsImVudiIsImVudmlyb25tZW50IiwiaW5wdXQiLCJzdGRpbyIsInRpbWVvdXQiLCJ0aW1lb3V0TXMiLCJtYXhCdWZmZXIiLCJlbmNvZGluZyIsInNoZWxsIiwicHJvY2VzcyIsImZpbGVFeHRlbnNpb24iLCJleHRuYW1lIiwicGxhdGZvcm0iLCJ0b1VwcGVyQ2FzZSIsIl92YWxpZGF0ZUFyZ3NGb3JXaW5kb3dzU2hlbGwiLCJzaGVsbFBhdGgiLCJDT01TUEVDIiwiX2NhbkV4ZWN1dGUiLCJ0cnlSZXNvbHZlIiwiYmFzZW5hbWUiLCJzaGVsbEFyZ3MiLCJwdXNoIiwiX2dldEVzY2FwZWRGb3JXaW5kb3dzU2hlbGwiLCJoYXNQYXRoU2VwYXJhdG9ycyIsImluZGV4T2YiLCJyZXNvbHZlIiwiX3RyeVJlc29sdmVGaWxlRXh0ZW5zaW9uIiwicGF0aHNUb1NlYXJjaCIsIl9nZXRTZWFyY2hGb2xkZXJzIiwicGF0aFRvU2VhcmNoIiwiam9pbiIsInJlc3VsdCIsInVuZGVmaW5lZCIsInNoZWxsRXh0ZW5zaW9uIiwid2luZG93c0V4ZWN1dGFibGVFeHRlbnNpb25zIiwicmVzb2x2ZWROYW1lV2l0aEV4dGVuc2lvbiIsImZpbGVQYXRoIiwiRmlsZVN5c3RlbSIsImV4aXN0cyIsImdldFBvc2l4TW9kZUJpdHMiLCJlcnJvciIsInBhdGhMaXN0IiwiUEFUSCIsImZvbGRlcnMiLCJzZWVuUGF0aHMiLCJTZXQiLCJzcGxpdFBhdGgiLCJzcGxpdCIsImRlbGltaXRlciIsInRyaW1tZWRQYXRoIiwidHJpbSIsImhhcyIsImFkZCIsInBhdGhFeHRWYXJpYWJsZSIsIlBBVEhFWFQiLCJzcGxpdFZhbHVlIiwidHJpbW1lZCIsInRvTG93ZXJDYXNlIiwidGVzdCIsInRleHQiLCJlc2NhcGFibGVDaGFyUmVnRXhwIiwicmVwbGFjZSIsInNwZWNpYWxDaGFyUmVnRXhwIiwiYXJnIiwibWF0Y2giLCJKU09OIiwic3RyaW5naWZ5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBQ0FBLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDLEVBQUVDLE9BQU8sSUFBVCxFQUE3QztBQUNBLE1BQU1DLGdCQUFnQkMsUUFBUSxlQUFSLENBQXRCO0FBQ0EsTUFBTUMsS0FBS0QsUUFBUSxJQUFSLENBQVg7QUFDQSxNQUFNRSxPQUFPRixRQUFRLE1BQVIsQ0FBYjtBQUNBLE1BQU1HLGVBQWVILFFBQVEsY0FBUixDQUFyQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBLE1BQU1JLFVBQU4sQ0FBaUI7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQSxXQUFPQyxTQUFQLENBQWlCQyxRQUFqQixFQUEyQkMsSUFBM0IsRUFBaUNDLE9BQWpDLEVBQTBDO0FBQ3RDLFlBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1ZBLHNCQUFVLEVBQVY7QUFDSDtBQUNELGNBQU1DLFVBQVVMLFdBQVdNLHFCQUFYLENBQWlDRixPQUFqQyxDQUFoQjtBQUNBLGNBQU1HLGVBQWVQLFdBQVdRLFdBQVgsQ0FBdUJOLFFBQXZCLEVBQWlDRSxPQUFqQyxFQUEwQ0MsT0FBMUMsQ0FBckI7QUFDQSxZQUFJLENBQUNFLFlBQUwsRUFBbUI7QUFDZixrQkFBTSxJQUFJRSxLQUFKLENBQVcsdUNBQXNDUCxRQUFTLEdBQTFELENBQU47QUFDSDtB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QU87QUFDSHZELHVCQURHO0FBRUhGLG1DQUZHO0FBR0htQztBQUhHLFNBQVA7QUFLSDtBQUNEOzs7O0FBSUEsV0FBT1osMEJBQVAsQ0FBa0NxQyxJQUFsQyxFQUF3QztBQUNwQyxjQUFNQyxzQkFBc0IsYUFBNUI7QUFDQSxlQUFPRCxLQUFLRSxPQUFMLENBQWFELG1CQUFiLEVBQW1DL0UsS0FBRCxJQUFXLE1BQU1BLEtBQW5ELENBQVA7QUFDSDtBQUNEOzs7O0FBSUEsV0FBT2lDLDRCQUFQLENBQW9DeEIsSUFBcEMsRUFBMEM7QUFDdEMsY0FBTXdFLG9CQUFvQixnQkFBMUI7QUFDQSxhQUFLLE1BQU1DLEdBQVgsSUFBa0J6RSxJQUFsQixFQUF3QjtBQUNwQixrQkFBTTBFLFFBQVFELElBQUlDLEtBQUosQ0FBVUYsaUJBQVYsQ0FBZDtBQUNBLGdCQUFJRSxLQUFKLEVBQVc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQU0sSUFBSXBFLEtBQUosQ0FBVyw2QkFBNEJxRSxLQUFLQyxTQUFMLENBQWVILEdBQWYsQ0FBb0IsYUFBakQsR0FDVCxzQkFBcUJFLEtBQUtDLFNBQUwsQ0FBZUYsTUFBTSxDQUFOLENBQWYsQ0FBeUIsK0NBRC9DLENBQU47QUFFSDtBQUNKO0FBQ0o7QUF4U1k7QUEwU2pCcEYsUUFBUU8sVUFBUixHQUFxQkEsVUFBckI7QUFDQSIsImZpbGUiOiJFeGVjdXRhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gU2VlIExJQ0VOU0UgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgRmlsZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vRmlsZVN5c3RlbVwiKTtcbi8qKlxuICogVGhlIEV4ZWN1dGFibGUgY2xhc3MgcHJvdmlkZXMgYSBzYWZlLCBwb3J0YWJsZSwgcmVjb21tZW5kZWQgc29sdXRpb24gZm9yIHRvb2xzIHRoYXQgbmVlZFxuICogdG8gbGF1bmNoIGNoaWxkIHByb2Nlc3Nlcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIE5vZGVKUyBjaGlsZF9wcm9jZXNzIEFQSSBwcm92aWRlcyBhIHNvbHV0aW9uIGZvciBsYXVuY2hpbmcgY2hpbGQgcHJvY2Vzc2VzLCBob3dldmVyXG4gKiBpdHMgZGVzaWduIGVuY291cmFnZXMgcmVsaWFuY2Ugb24gdGhlIG9wZXJhdGluZyBzeXN0ZW0gc2hlbGwgZm9yIGNlcnRhaW4gZmVhdHVyZXMuXG4gKiBJbnZva2luZyB0aGUgT1Mgc2hlbGwgaXMgbm90IHNhZmUsIG5vdCBwb3J0YWJsZSwgYW5kIGdlbmVyYWxseSBub3QgcmVjb21tZW5kZWQ6XG4gKlxuICogLSBEaWZmZXJlbnQgc2hlbGxzIGhhdmUgZGlmZmVyZW50IGJlaGF2aW9yIGFuZCBjb21tYW5kLWxpbmUgc3ludGF4LCBhbmQgd2hpY2ggc2hlbGwgeW91XG4gKiAgIHdpbGwgZ2V0IHdpdGggTm9kZUpTIGlzIHVucHJlZGljdGFibGUuICBUaGVyZSBpcyBubyB1bml2ZXJzYWwgc2hlbGwgZ3VhcmFudGVlZCB0byBiZVxuICogICBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtcy5cbiAqXG4gKiAtIElmIGEgY29tbWFuZCBwYXJhbWV0ZXIgY29udGFpbnMgc3ltYm9sIGNoYXJhY3RlcnMsIGEgc2hlbGwgbWF5IGludGVycHJldCB0aGVtLCB3aGljaFxuICogICBjYW4gaW50cm9kdWNlIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eVxuICpcbiAqIC0gRWFjaCBzaGVsbCBoYXMgZGlmZmVyZW50IHJ1bGVzIGZvciBlc2NhcGluZyB0aGVzZSBzeW1ib2xzLiAgT24gV2luZG93cywgdGhlIGRlZmF1bHRcbiAqICAgc2hlbGwgaXMgaW5jYXBhYmxlIG9mIGVzY2FwaW5nIGNlcnRhaW4gY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAqXG4gKiBUaGUgRXhlY3V0YWJsZSBBUEkgcHJvdmlkZXMgYSBwdXJlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgcHJpbWl0aXZlIHNoZWxsLWxpa2VcbiAqIGZ1bmN0aW9uYWxpdHkgZm9yIHNlYXJjaGluZyB0aGUgZGVmYXVsdCBQQVRILCBhcHBlbmRpbmcgZGVmYXVsdCBmaWxlIGV4dGVuc2lvbnMgb24gV2luZG93cyxcbiAqIGFuZCBleGVjdXRpbmcgYSBmaWxlIHRoYXQgbWF5IGNvbnRhaW4gYSBQT1NJWCBzaGViYW5nLiAgVGhpcyBwcmltaXRpdmUgZnVuY3Rpb25hbGl0eVxuICogaXMgc3VmZmljaWVudCAoYW5kIHJlY29tbWVuZGVkKSBmb3IgbW9zdCB0b29saW5nIHNjZW5hcmlvcy5cbiAqXG4gKiBJZiB5b3UgbmVlZCBhZGRpdGlvbmFsIHNoZWxsIGZlYXR1cmVzIHN1Y2ggYXMgd2lsZGNhcmQgZ2xvYmJpbmcsIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiBleHBhbnNpb24sIHBpcGluZywgb3IgYnVpbHQtaW4gY29tbWFuZHMsIHRoZW4gd2UgcmVjb21tZW5kIHRvIHVzZSB0aGUgYEBtaWNyb3NvZnQvcnVzaGVsbGBcbiAqIGxpYnJhcnkgaW5zdGVhZC4gIFJ1c2hlbGwgaXMgYSBwdXJlIEphdmFTY3JpcHQgc2hlbGwgd2l0aCBhIHN0YW5kYXJkIHN5bnRheCB0aGF0IGlzXG4gKiBndWFyYW50ZWVkIHRvIHdvcmsgY29uc2lzdGVudGx5IGFjcm9zcyBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXhlY3V0YWJsZSB7XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSBjcmVhdGUgYSBjaGlsZCBwcm9jZXNzIGFuZCBvcHRpb25hbGx5IGNhcHR1cmUgaXRzIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGNoaWxkX3Byb2Nlc3Muc3Bhd25TeW5jKCkuICBUaGUgbWFpbiBkaWZmZXJlbmNlcyBhcmU6XG4gICAgICpcbiAgICAgKiAtIEl0IGRvZXMgbm90IGludm9rZSB0aGUgT1Mgc2hlbGwgdW5sZXNzIHRoZSBleGVjdXRhYmxlIGZpbGUgaXMgYSBzaGVsbCBzY3JpcHQuXG4gICAgICogLSBDb21tYW5kLWxpbmUgYXJndW1lbnRzIGNvbnRhaW5pbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBtb3JlIGFjY3VyYXRlbHkgcGFzc2VkXG4gICAgICogICB0aHJvdWdoIHRvIHRoZSBjaGlsZCBwcm9jZXNzLlxuICAgICAqIC0gSWYgdGhlIGZpbGVuYW1lIGlzIG1pc3NpbmcgYSBwYXRoLCB0aGVuIHRoZSBzaGVsbCdzIGRlZmF1bHQgUEFUSCB3aWxsIGJlIHNlYXJjaGVkLlxuICAgICAqIC0gSWYgdGhlIGZpbGVuYW1lIGlzIG1pc3NpbmcgYSBmaWxlIGV4dGVuc2lvbiwgdGhlbiBXaW5kb3dzIGRlZmF1bHQgZmlsZSBleHRlbnNpb25zXG4gICAgICogICB3aWxsIGJlIHNlYXJjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV4ZWN1dGFibGUgZmlsZS4gIFRoaXMgc3RyaW5nIG11c3Qgbm90IGNvbnRhaW4gYW55XG4gICAgICogY29tbWFuZC1saW5lIGFyZ3VtZW50cy4gIElmIHRoZSBuYW1lIGNvbnRhaW5zIGFueSBwYXRoIGRlbGltaXRlcnMsIHRoZW4gdGhlIHNoZWxsJ3NcbiAgICAgKiBkZWZhdWx0IFBBVEggd2lsbCBub3QgYmUgc2VhcmNoZWQuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgY29tbWFuZC1saW5lIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgcmV0dXJuZWQgYnkgdGhlIE5vZGVKUyBjaGlsZF9wcm9jZXNzLnNwYXduU3luYygpIEFQSVxuICAgICAqXG4gICAgICogQHByaXZhdGVSZW1hcmtzXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgTm9kZUpTIHNwYXduU3luYygpIHJldHVybnMgU3Bhd25TeW5jUmV0dXJuczxzdHJpbmc+IG9yIFNwYXduU3luY1JldHVybnM8QnVmZmVyPlxuICAgICAqIHBvbHltb3JwaGljYWxseSBiYXNlZCBvbiB0aGUgb3B0aW9ucy5lbmNvZGluZyBwYXJhbWV0ZXIgdmFsdWUuICBUaGlzIGlzIGEgZmFpcmx5IGNvbmZ1c2luZ1xuICAgICAqIGRlc2lnbi4gIEluIG1vc3QgY2FzZXMsIGRldmVsb3BlcnMgd2FudCBzdHJpbmcgd2l0aCB0aGUgZGVmYXVsdCBlbmNvZGluZy4gIElmL3doZW4gc29tZW9uZVxuICAgICAqIHdhbnRzIGJpbmFyeSBvdXRwdXQgb3IgYSBub24tZGVmYXVsdCB0ZXh0IGVuY29kaW5nLCB3ZSB3aWxsIGludHJvZHVjZSBhIHNlcGFyYXRlIEFQSSBmdW5jdGlvblxuICAgICAqIHdpdGggYSBuYW1lIGxpa2UgXCJzcGF3bldpdGhCdWZmZXJTeW5jXCIuXG4gICAgICovXG4gICAgc3RhdGljIHNwYXduU3luYyhmaWxlbmFtZSwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gRXhlY3V0YWJsZS5fZ2V0RXhlY3V0YWJsZUNvbnRleHQob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IEV4ZWN1dGFibGUuX3RyeVJlc29sdmUoZmlsZW5hbWUsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZXhlY3V0YWJsZSBmaWxlIHdhcyBub3QgZm91bmQ6IFwiJHtmaWxlbmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYXduT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGN3ZDogY29udGV4dC5jdXJyZW50V29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICAgIGVudjogY29udGV4dC5lbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGlucHV0OiBvcHRpb25zLmlucHV0LFxuICAgICAgICAgICAgc3RkaW86IG9wdGlvbnMuc3RkaW8sXG4gICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXRNcyxcbiAgICAgICAgICAgIG1heEJ1ZmZlcjogb3B0aW9ucy5tYXhCdWZmZXIsXG4gICAgICAgICAgICAvLyBDb250cmFyeSB0byB3aGF0IHRoZSBOb2RlSlMgdHlwaW5ncyBpbXBseSwgd2UgbXVzdCBleHBsaWNpdGx5IHNwZWNpZnkgXCJ1dGY4XCIgaGVyZVxuICAgICAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgcmVzdWx0IHRvIGJlIFNwYXduU3luY1JldHVybnM8c3RyaW5nPiBpbnN0ZWFkIG9mIFNwYXduU3luY1JldHVybnM8QnVmZmVyPi5cbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGFsd2F5cyBmYWxzZSwgYmVjYXVzZSBSdXNoZWxsIGlzIHJlY29tbWVuZGVkIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgT1Mgc2hlbGwuXG4gICAgICAgICAgICBzaGVsbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUFJPQkxFTTogR2l2ZW4gYW4gXCJhcmdzXCIgYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IG1heSBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycyAoZS5nLiBzcGFjZXMsXG4gICAgICAgIC8vIGJhY2tzbGFzaGVzLCBxdW90ZXMpLCBlbnN1cmUgdGhhdCB0aGVzZSBzdHJpbmdzIHBhc3MgdGhyb3VnaCB0byB0aGUgY2hpbGQgcHJvY2VzcydzIEFSR1YgYXJyYXlcbiAgICAgICAgLy8gd2l0aG91dCBhbnl0aGluZyBnZXR0aW5nIGNvcnJ1cHRlZCBhbG9uZyB0aGUgd2F5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBPbiBVbml4IHlvdSBqdXN0IHBhc3MgdGhlIGFycmF5IHRvIHNwYXduU3luYygpLiAgQnV0IG9uIFdpbmRvd3MsIHRoaXMgaXMgYSB2ZXJ5IGNvbXBsZXggcHJvYmxlbTpcbiAgICAgICAgLy8gLSBUaGUgV2luMzIgQ3JlYXRlUHJvY2VzcygpIEFQSSBleHBlY3RzIHRoZSBhcmdzIHRvIGJlIGVuY29kZWQgYXMgYSBzaW5nbGUgdGV4dCBzdHJpbmdcbiAgICAgICAgLy8gLSBUaGUgZGVjb2Rpbmcgb2YgdGhpcyBzdHJpbmcgaXMgdXAgdG8gdGhlIGFwcGxpY2F0aW9uIChub3QgdGhlIE9TKSwgYW5kIHRoZXJlIGFyZSAzIGRpZmZlcmVudFxuICAgICAgICAvLyAgIGFsZ29yaXRobXMgaW4gY29tbW9uIHVzYWdlOiAgdGhlIGNtZC5leGUgc2hlbGwsIHRoZSBNaWNyb3NvZnQgQ1JUIGxpYnJhcnkgaW5pdCBjb2RlLCBhbmRcbiAgICAgICAgLy8gICB0aGUgV2luMzIgQ29tbWFuZExpbmVUb0FyZ3ZXKClcbiAgICAgICAgLy8gLSBUaGUgZW5jb2RpbmdzIGFyZSBjb3VudGVyaW50dWl0aXZlIGFuZCBoYXZlIGxvdHMgb2Ygc3BlY2lhbCBjYXNlc1xuICAgICAgICAvLyAtIE5vZGVKUyBzcGF3blN5bmMoKSB0cmllcyBkbyB0aGUgZW5jb2Rpbmcgd2l0aG91dCBrbm93aW5nIHdoaWNoIGRlY29kZXIgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZSB0aGVzZSBhcnRpY2xlcyBmb3IgYSBmdWxsIGFuYWx5c2lzOlxuICAgICAgICAvLyBodHRwOi8vd3d3LndpbmRvd3NpbnNwaXJlZC5jb20vdW5kZXJzdGFuZGluZy10aGUtY29tbWFuZC1saW5lLXN0cmluZy1hbmQtYXJndW1lbnRzLXJlY2VpdmVkLWJ5LWEtd2luZG93cy1wcm9ncmFtL1xuICAgICAgICAvLyBodHRwOi8vd3d3LndpbmRvd3NpbnNwaXJlZC5jb20vaG93LWEtd2luZG93cy1wcm9ncmFtcy1zcGxpdHMtaXRzLWNvbW1hbmQtbGluZS1pbnRvLWluZGl2aWR1YWwtYXJndW1lbnRzL1xuICAgICAgICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbnZpcm9ubWVudFxuICAgICAgICAgICAgfHwgcHJvY2Vzcy5lbnY7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIC8vIERvIHdlIG5lZWQgYSBjdXN0b20gaGFuZGxlciBmb3IgdGhpcyBmaWxlIHR5cGU/XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbGVFeHRlbnNpb24udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJy5FWEUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy5DT00nOlxuICAgICAgICAgICAgICAgICAgICAvLyBva2F5IHRvIGV4ZWN1dGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLkJBVCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLkNNRCc6IHtcbiAgICAgICAgICAgICAgICAgICAgRXhlY3V0YWJsZS5fdmFsaWRhdGVBcmdzRm9yV2luZG93c1NoZWxsKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBmaWxlIHR5cGVzIG11c3QgYmUgaW52b2tlZCB2aWEgdGhlIFdpbmRvd3Mgc2hlbGxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNoZWxsUGF0aCA9IGVudmlyb25tZW50LkNPTVNQRUM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hlbGxQYXRoIHx8ICFFeGVjdXRhYmxlLl9jYW5FeGVjdXRlKHNoZWxsUGF0aCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsUGF0aCA9IEV4ZWN1dGFibGUudHJ5UmVzb2x2ZSgnY21kLmV4ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hlbGxQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBleGVjdXRlIFwiJHtwYXRoLmJhc2VuYW1lKHJlc29sdmVkUGF0aCl9XCIgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYGJlY2F1c2UgQ01ELmV4ZSB3YXMgbm90IGZvdW5kIGluIHRoZSBQQVRIYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hlbGxBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIC9EOiBEaXNhYmxlIGV4ZWN1dGlvbiBvZiBBdXRvUnVuIGNvbW1hbmRzIHdoZW4gc3RhcnRpbmcgdGhlIG5ldyBzaGVsbCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIHNoZWxsQXJncy5wdXNoKCcvZCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyAvUzogRGlzYWJsZSBDbWQuZXhlJ3MgcGFyc2luZyBvZiBkb3VibGUtcXVvdGUgY2hhcmFjdGVycyBpbnNpZGUgdGhlIGNvbW1hbmQtbGluZVxuICAgICAgICAgICAgICAgICAgICBzaGVsbEFyZ3MucHVzaCgnL3MnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gL0M6IEV4ZWN1dGUgdGhlIGZvbGxvd2luZyBjb21tYW5kIGFuZCB0aGVuIGV4aXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgc2hlbGxBcmdzLnB1c2goJy9jJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXRoIGNvbnRhaW5zIHNwZWNpYWwgY2hhcmFjdHJlcnMgKGUuZy4gc3BhY2VzKSwgZXNjYXBlIHRoZW0gc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5IGRvbid0IGdldCBpbnRlcnByZXRlZCBieSB0aGUgc2hlbGxcbiAgICAgICAgICAgICAgICAgICAgc2hlbGxBcmdzLnB1c2goRXhlY3V0YWJsZS5fZ2V0RXNjYXBlZEZvcldpbmRvd3NTaGVsbChyZXNvbHZlZFBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgc2hlbGxBcmdzLnB1c2goLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZF9wcm9jZXNzLnNwYXduU3luYyhzaGVsbFBhdGgsIHNoZWxsQXJncywgc3Bhd25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZXhlY3V0ZSBcIiR7cGF0aC5iYXNlbmFtZShyZXNvbHZlZFBhdGgpfVwiIGJlY2F1c2UgdGhlIGZpbGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkX3Byb2Nlc3Muc3Bhd25TeW5jKHJlc29sdmVkUGF0aCwgYXJncywgc3Bhd25PcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmaWxlbmFtZSwgdGhpcyBkZXRlcm1pbmVzIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBleGVjdXRhYmxlIGZpbGUgdGhhdCB3b3VsZFxuICAgICAqIGJlIGV4ZWN1dGVkIGJ5IGEgc2hlbGw6XG4gICAgICpcbiAgICAgKiAtIElmIHRoZSBmaWxlbmFtZSBpcyBtaXNzaW5nIGEgcGF0aCwgdGhlbiB0aGUgc2hlbGwncyBkZWZhdWx0IFBBVEggd2lsbCBiZSBzZWFyY2hlZC5cbiAgICAgKiAtIElmIHRoZSBmaWxlbmFtZSBpcyBtaXNzaW5nIGEgZmlsZSBleHRlbnNpb24sIHRoZW4gV2luZG93cyBkZWZhdWx0IGZpbGUgZXh0ZW5zaW9uc1xuICAgICAqICAgd2lsbCBiZSBzZWFyY2hlZC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXhlY3V0YWJsZSBmaWxlLiAgVGhpcyBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnlcbiAgICAgKiBjb21tYW5kLWxpbmUgYXJndW1lbnRzLiAgSWYgdGhlIG5hbWUgY29udGFpbnMgYW55IHBhdGggZGVsaW1pdGVycywgdGhlbiB0aGUgc2hlbGwnc1xuICAgICAqIGRlZmF1bHQgUEFUSCB3aWxsIG5vdCBiZSBzZWFyY2hlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbmFsIG90aGVyIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgZXhlY3V0YWJsZSwgb3IgdW5kZWZpbmVkIGlmIGl0IHdhcyBub3QgZm91bmRcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJ5UmVzb2x2ZShmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gRXhlY3V0YWJsZS5fdHJ5UmVzb2x2ZShmaWxlbmFtZSwgb3B0aW9ucyB8fCB7fSwgRXhlY3V0YWJsZS5fZ2V0RXhlY3V0YWJsZUNvbnRleHQob3B0aW9ucykpO1xuICAgIH1cbiAgICBzdGF0aWMgX3RyeVJlc29sdmUoZmlsZW5hbWUsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTk9URTogU2luY2UgXCJmaWxlbmFtZVwiIGNhbm5vdCBjb250YWluIGNvbW1hbmQtbGluZSBhcmd1bWVudHMsIHRoZSBcIi9cIiBoZXJlXG4gICAgICAgIC8vIG11c3QgYmUgaW50ZXJwcmV0ZWQgYXMgYSBwYXRoIGRlbGltaXRlclxuICAgICAgICBjb25zdCBoYXNQYXRoU2VwYXJhdG9ycyA9IGZpbGVuYW1lLmluZGV4T2YoJy8nKSA+PSAwXG4gICAgICAgICAgICB8fCAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyAmJiBmaWxlbmFtZS5pbmRleE9mKCdcXFxcJykgPj0gMCk7XG4gICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgcGF0aCBzZXBhcmF0b3JzP1xuICAgICAgICBpZiAoaGFzUGF0aFNlcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIC8vIElmIHNvLCB0aGVuIGRvbid0IHNlYXJjaCB0aGUgUEFUSC4gIEp1c3QgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcGF0aC5yZXNvbHZlKGNvbnRleHQuY3VycmVudFdvcmtpbmdEaXJlY3RvcnksIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBFeGVjdXRhYmxlLl90cnlSZXNvbHZlRmlsZUV4dGVuc2lvbihyZXNvbHZlZFBhdGgsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIGl0J3MgYSBiYXJlIG5hbWUsIHRoZW4gdHJ5IGV2ZXJ5dGhpbmcgaW4gdGhlIHNoZWxsIFBBVEhcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzVG9TZWFyY2ggPSBFeGVjdXRhYmxlLl9nZXRTZWFyY2hGb2xkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoVG9TZWFyY2ggb2YgcGF0aHNUb1NlYXJjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHBhdGguam9pbihwYXRoVG9TZWFyY2gsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBFeGVjdXRhYmxlLl90cnlSZXNvbHZlRmlsZUV4dGVuc2lvbihyZXNvbHZlZFBhdGgsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCB3YXMgZm91bmRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF90cnlSZXNvbHZlRmlsZUV4dGVuc2lvbihyZXNvbHZlZFBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKEV4ZWN1dGFibGUuX2NhbkV4ZWN1dGUocmVzb2x2ZWRQYXRoLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdGhlIGRlZmF1bHQgZmlsZSBleHRlbnNpb25zXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGxFeHRlbnNpb24gb2YgY29udGV4dC53aW5kb3dzRXhlY3V0YWJsZUV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkTmFtZVdpdGhFeHRlbnNpb24gPSByZXNvbHZlZFBhdGggKyBzaGVsbEV4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmIChFeGVjdXRhYmxlLl9jYW5FeGVjdXRlKHJlc29sdmVkTmFtZVdpdGhFeHRlbnNpb24sIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkTmFtZVdpdGhFeHRlbnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB1c2VkIHdoZW4gc2VhcmNoaW5nIHRoZSBzaGVsbCBQQVRIIGZvciBhbiBleGVjdXRhYmxlLCB0byBkZXRlcm1pbmVcbiAgICAgKiB3aGV0aGVyIGEgbWF0Y2ggc2hvdWxkIGJlIHNraXBwZWQgb3Igbm90LiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0aGlzIGRvZXMgbm90XG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhlIGZpbGUgY2FuIGJlIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NhbkV4ZWN1dGUoZmlsZVBhdGgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5leGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IEZvciBXaW5kb3dzLCB3ZSBkb24ndCB2YWxpZGF0ZSB0aGF0IHRoZSBmaWxlIGV4dGVuc2lvbiBhcHBlYXJzIGluIFBBVEhFWFQuXG4gICAgICAgICAgICAvLyBUaGF0IGVudmlyb25tZW50IHZhcmlhYmxlIGRldGVybWluZXMgd2hpY2ggZXh0ZW5zaW9ucyBjYW4gYmUgYXBwZW5kZWQgaWYgdGhlXG4gICAgICAgICAgICAvLyBleHRlbnNpb24gaXMgbWlzc2luZywgYnV0IGl0IGRvZXMgbm90IGFmZmVjdCB3aGV0aGVyIGEgZmlsZSBtYXkgYmUgZXhlY3V0ZWQgb3Igbm90LlxuICAgICAgICAgICAgLy8gV2luZG93cyBkb2VzIGhhdmUgYSAoc2VsZG9tIHVzZWQpIEFDTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlbnkgZXhlY3V0aW9uIHBlcm1pc3Npb25zXG4gICAgICAgICAgICAvLyBmb3IgYSBmaWxlLCBidXQgTm9kZUpTIGRvZXNuJ3QgZXhwb3NlIHRoYXQgQVBJLCBzbyB3ZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgaXQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBXaW5kb3dzICpkb2VzKiByZXF1aXJlIHRoYXQgdGhlIGZpbGUgaGFzIHNvbWUga2luZCBvZiBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKHBhdGguZXh0bmFtZShmaWxlUGF0aCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIFVuaXgsIGNoZWNrIHdoZXRoZXIgYW55IG9mIHRoZSBQT1NJWCBleGVjdXRlIGJpdHMgYXJlIHNldFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgICAgIGlmICgoRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0uZ2V0UG9zaXhNb2RlQml0cyhmaWxlUGF0aCkgJiA3MyAvKiBBbGxFeGVjdXRlICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCBleGVjdXRhYmxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSB0cm91YmxlIGFjY2Vzc2luZyB0aGUgZmlsZSwgaWdub3JlIHRoZSBlcnJvciBhbmQgY29uc2lkZXIgaXQgXCJub3QgZXhlY3V0YWJsZVwiXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhhdCdzIHdoYXQgYSBzaGVsbCB3b3VsZCBkb1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZvbGRlcnMgd2hlcmUgd2Ugd2lsbCBzZWFyY2ggZm9yIGFuIGV4ZWN1dGFibGUsXG4gICAgICogYmFzZWQgb24gdGhlIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICovXG4gICAgc3RhdGljIF9nZXRTZWFyY2hGb2xkZXJzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGF0aExpc3QgPSBjb250ZXh0LmVudmlyb25tZW50LlBBVEggfHwgJyc7XG4gICAgICAgIGNvbnN0IGZvbGRlcnMgPSBbXTtcbiAgICAgICAgLy8gQXZvaWQgcHJvY2Vzc2luZyBkdXBsaWNhdGVzXG4gICAgICAgIGNvbnN0IHNlZW5QYXRocyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gTk9URTogQ21kLmV4ZSBvbiBXaW5kb3dzIGFsd2F5cyBzZWFyY2hlcyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBmaXJzdC5cbiAgICAgICAgLy8gUG93ZXJTaGVsbCBhbmQgVW5peCBzaGVsbHMgZG8gTk9UIGRvIHRoYXQsIGJlY2F1c2UgaXQncyBhIHNlY3VyaXR5IGNvbmNlcm4uXG4gICAgICAgIC8vIFdlIGZvbGxvdyB0aGVpciBiZWhhdmlvci5cbiAgICAgICAgZm9yIChjb25zdCBzcGxpdFBhdGggb2YgcGF0aExpc3Quc3BsaXQocGF0aC5kZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkUGF0aCA9IHNwbGl0UGF0aC50cmltKCk7XG4gICAgICAgICAgICBpZiAodHJpbW1lZFBhdGggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuUGF0aHMuaGFzKHRyaW1tZWRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGdW4gZmFjdDogSWYgeW91IHB1dCByZWxhdGl2ZSBwYXRocyBpbiB5b3VyIFBBVEggZW52aXJvbm1lbnQgdmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBzaGVsbHMgd2lsbCBkeW5hbWljYWxseSBtYXRjaCB0aGVtIGFnYWluc3QgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB0ZXJyaWJsZSBkZXNpZ24sIGFuZCBpbiBwcmFjdGljZSBub2JvZHkgZG9lcyB0aGF0LCBidXQgaXQgaXMgc3VwcG9ydGVkLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHBhdGgucmVzb2x2ZShjb250ZXh0LmN1cnJlbnRXb3JraW5nRGlyZWN0b3J5LCB0cmltbWVkUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlblBhdGhzLmhhcyhyZXNvbHZlZFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0uZXhpc3RzKHJlc29sdmVkUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xkZXJzLnB1c2gocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5QYXRocy5hZGQocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWVuUGF0aHMuYWRkKHRyaW1tZWRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlcnM7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0RXhlY3V0YWJsZUNvbnRleHQob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgcHJvY2Vzcy5lbnY7XG4gICAgICAgIGxldCBjdXJyZW50V29ya2luZ0RpcmVjdG9yeTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY3VycmVudFdvcmtpbmdEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRXb3JraW5nRGlyZWN0b3J5ID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3VycmVudFdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFdvcmtpbmdEaXJlY3RvcnkgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpbmRvd3NFeGVjdXRhYmxlRXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEV4dFZhcmlhYmxlID0gZW52aXJvbm1lbnQuUEFUSEVYVCB8fCAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BsaXRWYWx1ZSBvZiBwYXRoRXh0VmFyaWFibGUuc3BsaXQoJzsnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzcGxpdFZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtYWxmb3JtZWQgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgIGlmICgvXlxcLlthLXowLTlcXC5dKlthLXowLTldJC9pLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBzYW1lIGV4dGVuc2lvbiB0d2ljZVxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93c0V4ZWN1dGFibGVFeHRlbnNpb25zLmluZGV4T2YodHJpbW1lZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dzRXhlY3V0YWJsZUV4dGVuc2lvbnMucHVzaCh0cmltbWVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBjdXJyZW50V29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICAgIHdpbmRvd3NFeGVjdXRhYmxlRXh0ZW5zaW9uc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbnB1dCBzdHJpbmcgY29udGFpbmluZyBzcGVjaWFsIHN5bWJvbCBjaGFyYWN0ZXJzLCB0aGlzIGluc2VydHMgdGhlIFwiXlwiIGVzY2FwZVxuICAgICAqIGNoYXJhY3RlciB0byBlbnN1cmUgdGhlIHN5bWJvbHMgYXJlIGludGVycHJldGVkIGxpdGVyYWxseSBieSB0aGUgV2luZG93cyBzaGVsbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgX2dldEVzY2FwZWRGb3JXaW5kb3dzU2hlbGwodGV4dCkge1xuICAgICAgICBjb25zdCBlc2NhcGFibGVDaGFyUmVnRXhwID0gL1slXFxeJnw8PiBdL2c7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoZXNjYXBhYmxlQ2hhclJlZ0V4cCwgKHZhbHVlKSA9PiAnXicgKyB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY2hhcmFjdGVycyB0aGF0IGFyZSB1bnNhZmUgdG8gcGFzcyB0byBhIFdpbmRvd3MgYmF0Y2ggZmlsZVxuICAgICAqIGR1ZSB0byB0aGUgd2F5IHRoYXQgY21kLmV4ZSBpbXBsZW1lbnRzIGVzY2FwaW5nLlxuICAgICAqL1xuICAgIHN0YXRpYyBfdmFsaWRhdGVBcmdzRm9yV2luZG93c1NoZWxsKGFyZ3MpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lhbENoYXJSZWdFeHAgPSAvWyVcXF4mfDw+XFxyXFxuXS9nO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGFyZy5tYXRjaChzcGVjaWFsQ2hhclJlZ0V4cCk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBJdCBpcyBwb3NzaWJsZSB0byBlc2NhcGUgc29tZSBvZiB0aGVzZSBjaGFyYWN0ZXJzIGJ5IHByZWZpeGluZyB0aGVtXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhIGNhcmV0ICheKSwgd2hpY2ggYWxsb3dzIHRoZXNlIGNoYXJhY3RlcnMgdG8gYmUgc3VjY2Vzc2Z1bGx5IHBhc3NlZFxuICAgICAgICAgICAgICAgIC8vIHRocm91Z2ggdG8gdGhlIGJhdGNoIGZpbGUgJTEgdmFyaWFibGVzLiAgQnV0IHRoZXkgd2lsbCBiZSBleHBhbmRlZCBhZ2FpblxuICAgICAgICAgICAgICAgIC8vIHdoZW5ldmVyIHRoZXkgYXJlIHVzZWQuICBGb3IgZXhhbXBsZSwgTlBNJ3MgYmluYXJ5IHdyYXBwZXIgYmF0Y2ggZmlsZXNcbiAgICAgICAgICAgICAgICAvLyB1c2UgXCIlKlwiIHRvIHBhc3MgdGhlaXIgYXJndW1lbnRzIHRvIE5vZGUuZXhlLCB3aGljaCBjYXVzZXMgdGhlbSB0byBiZSBleHBhbmRlZFxuICAgICAgICAgICAgICAgIC8vIGFnYWluLiAgVW5mb3J0dW5hdGVseSB0aGUgQ21kLmV4ZSBiYXRjaCBsYW5ndWFnZSBwcm92aWRlcyBuYXRpdmUgZXNjYXBpbmdcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiAodGhhdCBjb3VsZCBiZSB1c2VkIHRvIGluc2VydCB0aGUgY2FyZXRzIGFnYWluKS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHdvcmsgYXJvdW5kIHRoYXQgYnkgYWRkaW5nIGRvdWJsZSBjYXJldHMsIGJ1dCBpbiBnZW5lcmFsIHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gaXMgbm8gd2F5IHRvIHByZWRpY3QgaG93IG1hbnkgdGltZXMgdGhlIHZhcmlhYmxlIHdpbGwgZ2V0IGV4cGFuZGVkLlxuICAgICAgICAgICAgICAgIC8vIFRodXMsIHRoZXJlIGlzIG5vIGdlbmVyYWxseSByZWxpYWJsZSB3YXkgdG8gcGFzcyB0aGVzZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudCAke0pTT04uc3RyaW5naWZ5KGFyZyl9IGNvbnRhaW5zIGFgXG4gICAgICAgICAgICAgICAgICAgICsgYCBzcGVjaWFsIGNoYXJhY3RlciAke0pTT04uc3RyaW5naWZ5KG1hdGNoWzBdKX0gdGhhdCBjYW5ub3QgYmUgZXNjYXBlZCBmb3IgdGhlIFdpbmRvd3Mgc2hlbGxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZSA9IEV4ZWN1dGFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeGVjdXRhYmxlLmpzLm1hcCJdfQ==