f5998a691a5ea887d4ce96abd13ba2a3
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const timsort_1 = require("timsort");
const semver = require("semver");
/**
 * Helper functions used when interacting with APIs that do not follow modern coding practices.
 * @public
 */
class LegacyAdapters {
    static convertCallbackToPromise(fn, arg1, arg2, arg3, arg4) {
        return new Promise((resolve, reject) => {
            const cb = (error, result) => {
                if (error) {
                    reject(LegacyAdapters.scrubError(error));
                } else {
                    resolve(result);
                }
            };
            try {
                if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {
                    fn(arg1, arg2, arg3, arg4, cb);
                } else if (arg1 !== undefined && arg2 !== undefined && arg3 !== undefined) {
                    fn(arg1, arg2, arg3, cb);
                } else if (arg1 !== undefined && arg2 !== undefined) {
                    fn(arg1, arg2, cb);
                } else if (arg1 !== undefined) {
                    fn(arg1, cb);
                } else {
                    fn(cb);
                }
            } catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Normalizes an object into an `Error` object.
     */
    static scrubError(error) {
        if (error instanceof Error) {
            return error;
        } else if (typeof error === 'string') {
            return new Error(error);
        } else {
            const errorObject = new Error('An error occurred.');
            errorObject.errorData = error; // eslint-disable-line @typescript-eslint/no-explicit-any
            return errorObject;
        }
    }
    /**
     * Prior to Node 11.x, the `Array.sort()` algorithm is not guaranteed to be stable.
     * If you need a stable sort, you can use `sortStable()` as a workaround.
     *
     * @remarks
     * On NodeJS 11.x and later, this method simply calls the native `Array.sort()`.
     * For earlier versions, it uses an implementation of Timsort, which is the same algorithm used by modern NodeJS.
     */
    static sortStable(array, compare) {
        if (LegacyAdapters._useTimsort === undefined) {
            LegacyAdapters._useTimsort = semver.major(process.versions.node) < 11;
        }
        if (LegacyAdapters._useTimsort) {
            timsort_1.sort(array, compare);
        } else {
            Array.prototype.sort.call(array, compare);
        }
    }
}
LegacyAdapters._useTimsort = undefined;
exports.LegacyAdapters = LegacyAdapters;
//# sourceMappingURL=LegacyAdapters.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxlZ2FjeUFkYXB0ZXJzLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidGltc29ydF8xIiwicmVxdWlyZSIsInNlbXZlciIsIkxlZ2FjeUFkYXB0ZXJzIiwiY29udmVydENhbGxiYWNrVG9Qcm9taXNlIiwiZm4iLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYiIsImVycm9yIiwicmVzdWx0Iiwic2NydWJFcnJvciIsInVuZGVmaW5lZCIsImUiLCJFcnJvciIsImVycm9yT2JqZWN0IiwiZXJyb3JEYXRhIiwic29ydFN0YWJsZSIsImFycmF5IiwiY29tcGFyZSIsIl91c2VUaW1zb3J0IiwibWFqb3IiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwic29ydCIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QyxFQUFFQyxPQUFPLElBQVQsRUFBN0M7QUFDQSxNQUFNQyxZQUFZQyxRQUFRLFNBQVIsQ0FBbEI7QUFDQSxNQUFNQyxTQUFTRCxRQUFRLFFBQVIsQ0FBZjtBQUNBOzs7O0FBSUEsTUFBTUUsY0FBTixDQUFxQjtBQUNqQixXQUFPQyx3QkFBUCxDQUFnQ0MsRUFBaEMsRUFBb0NDLElBQXBDLEVBQTBDQyxJQUExQyxFQUFnREMsSUFBaEQsRUFBc0RDLElBQXRELEVBQTREO0FBQ3hELGVBQU8sSUFBSUMsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUNwQyxrQkFBTUMsS0FBSyxDQUFDQyxLQUFELEVBQVFDLE1BQVIsS0FBbUI7QUFDMUIsb0JBQUlELEtBQUosRUFBVztBQUNQRiwyQkFBT1QsZUFBZWEsVUFBZixDQUEwQkYsS0FBMUIsQ0FBUDtBQUNILGlCQUZELE1BR0s7QUFDREgsNEJBQVFJLE1BQVI7QUFDSDtBQUNKLGFBUEQ7QUFRQSxnQkFBSTtBQUNBLG9CQUFJVCxTQUFTVyxTQUFULElBQXNCVixTQUFTVSxTQUEvQixJQUE0Q1QsU0FBU1MsU0FBckQsSUFBa0VSLFNBQVNRLFNBQS9FLEVBQTBGO0FBQ3RGWix1QkFBR0MsSUFBSCxFQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUJDLElBQXJCLEVBQTJCSSxFQUEzQjtBQUNILGlCQUZELE1BR0ssSUFBSVAsU0FBU1csU0FBVCxJQUFzQlYsU0FBU1UsU0FBL0IsSUFBNENULFNBQVNTLFNBQXpELEVBQW9FO0FBQ3JFWix1QkFBR0MsSUFBSCxFQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUJLLEVBQXJCO0FBQ0gsaUJBRkksTUFHQSxJQUFJUCxTQUFTVyxTQUFULElBQXNCVixTQUFTVSxTQUFuQyxFQUE4QztBQUMvQ1osdUJBQUdDLElBQUgsRUFBU0MsSUFBVCxFQUFlTSxFQUFmO0FBQ0gsaUJBRkksTUFHQSxJQUFJUCxTQUFTVyxTQUFiLEVBQXdCO0FBQ3pCWix1QkFBR0MsSUFBSCxFQUFTTyxFQUFUO0FBQ0gsaUJBRkksTUFHQTtBQUNEUix1QkFBR1EsRUFBSDtBQUNIO0FBQ0osYUFoQkQsQ0FpQkEsT0FBT0ssQ0FBUCxFQUFVO0FBQ05OLHVCQUFPTSxDQUFQO0FBQ0g7QUFDSixTQTdCTSxDQUFQO0FBOEJIO0FBQ0Q7OztBQUdBLFdBQU9GLFVBQVAsQ0FBa0JGLEtBQWxCLEVBQXlCO0FBQ3JCLFlBQUlBLGlCQUFpQkssS0FBckIsRUFBNEI7QUFDeEIsbUJBQU9MLEtBQVA7QUFDSCxTQUZELE1BR0ssSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ2hDLG1CQUFPLElBQUlLLEtBQUosQ0FBVUwsS0FBVixDQUFQO0FBQ0gsU0FGSSxNQUdBO0FBQ0Qsa0JBQU1NLGNBQWMsSUFBSUQsS0FBSixDQUFVLG9CQUFWLENBQXBCO0FBQ0FDLHdCQUFZQyxTQUFaLEdBQXdCUCxLQUF4QixDQUZDLENBRThCO0FBQy9CLG1CQUFPTSxXQUFQO0FBQ0g7QUFDSjtBQUNEOzs7Ozs7OztBQVFBLFdBQU9FLFVBQVAsQ0FBa0JDLEtBQWxCLEVBQXlCQyxPQUF6QixFQUFrQztBQUM5QixZQUFJckIsZUFBZXNCLFdBQWYsS0FBK0JSLFNBQW5DLEVBQThDO0FBQzFDZCwyQkFBZXNCLFdBQWYsR0FBNkJ2QixPQUFPd0IsS0FBUCxDQUFhQyxRQUFRQyxRQUFSLENBQWlCQyxJQUE5QixJQUFzQyxFQUFuRTtBQUNIO0FBQ0QsWUFBSTFCLGVBQWVzQixXQUFuQixFQUFnQztBQUM1QnpCLHNCQUFVOEIsSUFBVixDQUFlUCxLQUFmLEVBQXNCQyxPQUF0QjtBQUNILFNBRkQsTUFHSztBQUNETyxrQkFBTUMsU0FBTixDQUFnQkYsSUFBaEIsQ0FBcUJHLElBQXJCLENBQTBCVixLQUExQixFQUFpQ0MsT0FBakM7QUFDSDtBQUNKO0FBbkVnQjtBQXFFckJyQixlQUFlc0IsV0FBZixHQUE2QlIsU0FBN0I7QUFDQW5CLFFBQVFLLGNBQVIsR0FBeUJBLGNBQXpCO0FBQ0EiLCJmaWxlIjoiTGVnYWN5QWRhcHRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBTZWUgTElDRU5TRSBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdGltc29ydF8xID0gcmVxdWlyZShcInRpbXNvcnRcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHVzZWQgd2hlbiBpbnRlcmFjdGluZyB3aXRoIEFQSXMgdGhhdCBkbyBub3QgZm9sbG93IG1vZGVybiBjb2RpbmcgcHJhY3RpY2VzLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBMZWdhY3lBZGFwdGVycyB7XG4gICAgc3RhdGljIGNvbnZlcnRDYWxsYmFja1RvUHJvbWlzZShmbiwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2IgPSAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoTGVnYWN5QWRhcHRlcnMuc2NydWJFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhcmcxICE9PSB1bmRlZmluZWQgJiYgYXJnMiAhPT0gdW5kZWZpbmVkICYmIGFyZzMgIT09IHVuZGVmaW5lZCAmJiBhcmc0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcxICE9PSB1bmRlZmluZWQgJiYgYXJnMiAhPT0gdW5kZWZpbmVkICYmIGFyZzMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmbihhcmcxLCBhcmcyLCBhcmczLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZzEgIT09IHVuZGVmaW5lZCAmJiBhcmcyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oYXJnMSwgYXJnMiwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oYXJnMSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBhbiBvYmplY3QgaW50byBhbiBgRXJyb3JgIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2NydWJFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JPYmplY3QgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkLicpO1xuICAgICAgICAgICAgZXJyb3JPYmplY3QuZXJyb3JEYXRhID0gZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIE5vZGUgMTEueCwgdGhlIGBBcnJheS5zb3J0KClgIGFsZ29yaXRobSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzdGFibGUuXG4gICAgICogSWYgeW91IG5lZWQgYSBzdGFibGUgc29ydCwgeW91IGNhbiB1c2UgYHNvcnRTdGFibGUoKWAgYXMgYSB3b3JrYXJvdW5kLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBPbiBOb2RlSlMgMTEueCBhbmQgbGF0ZXIsIHRoaXMgbWV0aG9kIHNpbXBseSBjYWxscyB0aGUgbmF0aXZlIGBBcnJheS5zb3J0KClgLlxuICAgICAqIEZvciBlYXJsaWVyIHZlcnNpb25zLCBpdCB1c2VzIGFuIGltcGxlbWVudGF0aW9uIG9mIFRpbXNvcnQsIHdoaWNoIGlzIHRoZSBzYW1lIGFsZ29yaXRobSB1c2VkIGJ5IG1vZGVybiBOb2RlSlMuXG4gICAgICovXG4gICAgc3RhdGljIHNvcnRTdGFibGUoYXJyYXksIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKExlZ2FjeUFkYXB0ZXJzLl91c2VUaW1zb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIExlZ2FjeUFkYXB0ZXJzLl91c2VUaW1zb3J0ID0gc2VtdmVyLm1ham9yKHByb2Nlc3MudmVyc2lvbnMubm9kZSkgPCAxMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTGVnYWN5QWRhcHRlcnMuX3VzZVRpbXNvcnQpIHtcbiAgICAgICAgICAgIHRpbXNvcnRfMS5zb3J0KGFycmF5LCBjb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zb3J0LmNhbGwoYXJyYXksIGNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuTGVnYWN5QWRhcHRlcnMuX3VzZVRpbXNvcnQgPSB1bmRlZmluZWQ7XG5leHBvcnRzLkxlZ2FjeUFkYXB0ZXJzID0gTGVnYWN5QWRhcHRlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZWdhY3lBZGFwdGVycy5qcy5tYXAiXX0=