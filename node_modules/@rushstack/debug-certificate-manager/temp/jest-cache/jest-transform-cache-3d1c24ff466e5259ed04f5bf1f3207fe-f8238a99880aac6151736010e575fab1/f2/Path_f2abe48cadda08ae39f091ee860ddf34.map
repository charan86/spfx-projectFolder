{"version":3,"sources":["Path.js"],"names":["Object","defineProperty","exports","value","path","require","Path","isUnder","childPath","parentFolderPath","relativePath","relative","_relativePathRegex","test","isUnderOrEqual"],"mappings":"AAAA;AACA;AACA;;AACAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;AACA,MAAMC,OAAOC,QAAQ,MAAR,CAAb;AACA;;;;;;AAMA,MAAMC,IAAN,CAAW;AACP;;;;;;;;;;AAUA,SAAOC,OAAP,CAAeC,SAAf,EAA0BC,gBAA1B,EAA4C;AACxC;AACA;AACA;AACA,UAAMC,eAAeN,KAAKO,QAAL,CAAcH,SAAd,EAAyBC,gBAAzB,CAArB;AACA,WAAOH,KAAKM,kBAAL,CAAwBC,IAAxB,CAA6BH,YAA7B,CAAP;AACH;AACD;;;;;;;;;AASA,SAAOI,cAAP,CAAsBN,SAAtB,EAAiCC,gBAAjC,EAAmD;AAC/C,UAAMC,eAAeN,KAAKO,QAAL,CAAcH,SAAd,EAAyBC,gBAAzB,CAArB;AACA,WAAOC,iBAAiB,EAAjB,IAAuBJ,KAAKM,kBAAL,CAAwBC,IAAxB,CAA6BH,YAA7B,CAA9B;AACH;AA9BM;AAgCXJ,KAAKM,kBAAL,GAA0B,YAA1B;AACAV,QAAQI,IAAR,GAAeA,IAAf;AACA","file":"Path.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\n/**\n * Common operations for manipulating file and directory paths.\n * @remarks\n * This API is intended to eventually be a complete replacement for the NodeJS \"path\" API.\n * @public\n */\nclass Path {\n    /**\n     * Returns true if \"childPath\" is located inside the \"parentFolderPath\" folder\n     * or one of its child folders.  Note that \"parentFolderPath\" is not considered to be\n     * under itself.  The \"childPath\" can refer to any type of file system object.\n     *\n     * @remarks\n     * The indicated file/folder objects are not required to actually exist on disk.\n     * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\n     * If the paths are relative, they will first be resolved using path.resolve().\n     */\n    static isUnder(childPath, parentFolderPath) {\n        // If childPath is under parentPath, then relativePath will be something like\n        // \"../..\" or \"..\\\\..\", which consists entirely of periods and slashes.\n        // (Note that something like \"....t\" is actually a valid filename, but \"....\" is not.)\n        const relativePath = path.relative(childPath, parentFolderPath);\n        return Path._relativePathRegex.test(relativePath);\n    }\n    /**\n     * Returns true if \"childPath\" is equal to \"parentFolderPath\", or if it is inside that folder\n     * or one of its children.  The \"childPath\" can refer to any type of file system object.\n     *\n     * @remarks\n     * The indicated file/folder objects are not required to actually exist on disk.\n     * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\n     * If the paths are relative, they will first be resolved using path.resolve().\n     */\n    static isUnderOrEqual(childPath, parentFolderPath) {\n        const relativePath = path.relative(childPath, parentFolderPath);\n        return relativePath === '' || Path._relativePathRegex.test(relativePath);\n    }\n}\nPath._relativePathRegex = /^[.\\/\\\\]+$/;\nexports.Path = Path;\n//# sourceMappingURL=Path.js.map"]}