{"version":3,"sources":["JsonFile.js"],"names":["Object","defineProperty","exports","value","os","require","jju","Text_1","FileSystem_1","JsonFile","load","jsonFilename","FileSystem","exists","Error","contents","readFile","parse","error","EOL","message","loadAndValidate","jsonSchema","options","jsonObject","validateObject","loadAndValidateWithCallback","errorCallback","validateObjectWithCallback","stringify","updateString","previousJson","newJsonObject","validateNoUndefinedMembers","stringified","update","mode","indent","prettyFormatting","JSON","undefined","Text","ensureTrailingNewline","newlineConversion","convertTo","save","oldBuffer","updateExistingFile","onlyIfChanged","readFileToBuffer","jsonToUpdate","toString","newJson","newBuffer","Buffer","from","compare","writeFile","ensureFolderExists","_validateNoUndefinedMembers","keyPath","key","keys","push","fullPath","_formatKeyPath","pop","result","test","escapedKey","replace"],"mappings":"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","file":"JsonFile.js","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = require(\"os\");\nconst jju = require(\"jju\");\nconst Text_1 = require(\"./Text\");\nconst FileSystem_1 = require(\"./FileSystem\");\n/**\n * Utilities for reading/writing JSON files.\n * @public\n */\nclass JsonFile {\n    /**\n     * Loads a JSON file.\n     */\n    static load(jsonFilename) {\n        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {\n            throw new Error(`Input file not found: ${jsonFilename}`);\n        }\n        const contents = FileSystem_1.FileSystem.readFile(jsonFilename);\n        try {\n            return jju.parse(contents);\n        }\n        catch (error) {\n            throw new Error(`Error reading \"${jsonFilename}\":` + os.EOL + `  ${error.message}`);\n        }\n    }\n    /**\n     * Loads a JSON file and validate its schema.\n     */\n    static loadAndValidate(jsonFilename, jsonSchema, options) {\n        const jsonObject = JsonFile.load(jsonFilename);\n        jsonSchema.validateObject(jsonObject, jsonFilename, options);\n        return jsonObject;\n    }\n    /**\n     * Loads a JSON file and validate its schema, reporting errors using a callback\n     * @remarks\n     * See JsonSchema.validateObjectWithCallback() for more info.\n     */\n    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {\n        const jsonObject = JsonFile.load(jsonFilename);\n        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);\n        return jsonObject;\n    }\n    /**\n     * Serializes the specified JSON object to a string buffer.\n     * @param jsonObject - the object to be serialized\n     * @param options - other settings that control serialization\n     * @returns a JSON string, with newlines, and indented with two spaces\n     */\n    static stringify(jsonObject, options) {\n        return JsonFile.updateString('', jsonObject, options);\n    }\n    /**\n     * Serializes the specified JSON object to a string buffer.\n     * @param jsonObject - the object to be serialized\n     * @param options - other settings that control serialization\n     * @returns a JSON string, with newlines, and indented with two spaces\n     */\n    static updateString(previousJson, newJsonObject, options) {\n        if (!options) {\n            options = {};\n        }\n        JsonFile.validateNoUndefinedMembers(newJsonObject);\n        let stringified;\n        if (previousJson !== '') {\n            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON\n            stringified = jju.update(previousJson, newJsonObject, {\n                mode: 'cjson',\n                indent: 2\n            });\n        }\n        else if (options.prettyFormatting) {\n            stringified = jju.stringify(newJsonObject, {\n                mode: 'json',\n                indent: 2\n            });\n        }\n        else {\n            stringified = JSON.stringify(newJsonObject, undefined, 2);\n        }\n        // Add the trailing newline\n        stringified = Text_1.Text.ensureTrailingNewline(stringified);\n        if (options && options.newlineConversion) {\n            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);\n        }\n        return stringified;\n    }\n    /**\n     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.\n     * @param jsonObject - the object to be saved\n     * @param jsonFilename - the file path to write\n     * @param options - other settings that control how the file is saved\n     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise\n     */\n    static save(jsonObject, jsonFilename, options) {\n        if (!options) {\n            options = {};\n        }\n        // Do we need to read the previous file contents?\n        let oldBuffer = undefined;\n        if (options.updateExistingFile || options.onlyIfChanged) {\n            if (FileSystem_1.FileSystem.exists(jsonFilename)) {\n                try {\n                    oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);\n                }\n                catch (error) {\n                    // Ignore this error, and try writing a new file.  If that fails, then we should report that\n                    // error instead.\n                }\n            }\n        }\n        let jsonToUpdate = '';\n        if (options.updateExistingFile && oldBuffer) {\n            jsonToUpdate = oldBuffer.toString();\n        }\n        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);\n        const newBuffer = Buffer.from(newJson); // utf8 encoding happens here\n        if (options.onlyIfChanged) {\n            // Has the file changed?\n            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\n                // Nothing has changed, so don't touch the file\n                return false;\n            }\n        }\n        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(), {\n            ensureFolderExists: options.ensureFolderExists\n        });\n        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.\n        /*\n        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);\n        if (Buffer.compare(buffer, oldBuffer2) !== 0) {\n          console.log('new:' + buffer.toString('hex'));\n          console.log('old:' + oldBuffer2.toString('hex'));\n    \n          throw new Error('onlyIfChanged logic is broken');\n        }\n        */\n        return true;\n    }\n    /**\n     * Used to validate a data structure before writing.  Reports an error if there\n     * are any undefined members.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static validateNoUndefinedMembers(jsonObject) {\n        return JsonFile._validateNoUndefinedMembers(jsonObject, []);\n    }\n    // Private implementation of validateNoUndefinedMembers()\n    static _validateNoUndefinedMembers(jsonObject, keyPath) {\n        if (!jsonObject) {\n            return;\n        }\n        if (typeof jsonObject === 'object') {\n            for (const key of Object.keys(jsonObject)) {\n                keyPath.push(key);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const value = jsonObject[key];\n                if (value === undefined) {\n                    const fullPath = JsonFile._formatKeyPath(keyPath);\n                    throw new Error(`The value for ${fullPath} is \"undefined\" and cannot be serialized as JSON`);\n                }\n                JsonFile._validateNoUndefinedMembers(value, keyPath);\n                keyPath.pop();\n            }\n        }\n    }\n    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string \"with\" symbols\", 'type']\n    // Return this string:  items[4].syntax.parameters[\"string \\\"with\\\" symbols\"].type\n    static _formatKeyPath(keyPath) {\n        let result = '';\n        for (const key of keyPath) {\n            if (/^[0-9]+$/.test(key)) {\n                // It's an integer, so display like this:  parent[123]\n                result += `[${key}]`;\n            }\n            else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {\n                // It's an alphanumeric identifier, so display like this:  parent.name\n                if (result) {\n                    result += '.';\n                }\n                result += `${key}`;\n            }\n            else {\n                // It's a freeform string, so display like this:  parent[\"A path: \\\"C:\\\\file\\\"\"]\n                // Convert this:     A path: \"C:\\file\"\n                // To this:          A path: \\\"C:\\\\file\\\"\n                const escapedKey = key.replace(/[\\\\]/g, '\\\\\\\\') // escape backslashes\n                    .replace(/[\"]/g, '\\\\'); // escape quotes\n                result += `[\"${escapedKey}\"]`;\n            }\n        }\n        return result;\n    }\n}\nexports.JsonFile = JsonFile;\n//# sourceMappingURL=JsonFile.js.map"]}