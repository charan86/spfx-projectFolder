ffb6753435e41b9a4bbe55c55648592e
"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const jju = require("jju");
const Text_1 = require("./Text");
const FileSystem_1 = require("./FileSystem");
/**
 * Utilities for reading/writing JSON files.
 * @public
 */
class JsonFile {
    /**
     * Loads a JSON file.
     */
    static load(jsonFilename) {
        if (!FileSystem_1.FileSystem.exists(jsonFilename)) {
            throw new Error(`Input file not found: ${jsonFilename}`);
        }
        const contents = FileSystem_1.FileSystem.readFile(jsonFilename);
        try {
            return jju.parse(contents);
        } catch (error) {
            throw new Error(`Error reading "${jsonFilename}":` + os.EOL + `  ${error.message}`);
        }
    }
    /**
     * Loads a JSON file and validate its schema.
     */
    static loadAndValidate(jsonFilename, jsonSchema, options) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObject(jsonObject, jsonFilename, options);
        return jsonObject;
    }
    /**
     * Loads a JSON file and validate its schema, reporting errors using a callback
     * @remarks
     * See JsonSchema.validateObjectWithCallback() for more info.
     */
    static loadAndValidateWithCallback(jsonFilename, jsonSchema, errorCallback) {
        const jsonObject = JsonFile.load(jsonFilename);
        jsonSchema.validateObjectWithCallback(jsonObject, errorCallback);
        return jsonObject;
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static stringify(jsonObject, options) {
        return JsonFile.updateString('', jsonObject, options);
    }
    /**
     * Serializes the specified JSON object to a string buffer.
     * @param jsonObject - the object to be serialized
     * @param options - other settings that control serialization
     * @returns a JSON string, with newlines, and indented with two spaces
     */
    static updateString(previousJson, newJsonObject, options) {
        if (!options) {
            options = {};
        }
        JsonFile.validateNoUndefinedMembers(newJsonObject);
        let stringified;
        if (previousJson !== '') {
            // NOTE: We don't use mode=json here because comments aren't allowed by strict JSON
            stringified = jju.update(previousJson, newJsonObject, {
                mode: 'cjson',
                indent: 2
            });
        } else if (options.prettyFormatting) {
            stringified = jju.stringify(newJsonObject, {
                mode: 'json',
                indent: 2
            });
        } else {
            stringified = JSON.stringify(newJsonObject, undefined, 2);
        }
        // Add the trailing newline
        stringified = Text_1.Text.ensureTrailingNewline(stringified);
        if (options && options.newlineConversion) {
            stringified = Text_1.Text.convertTo(stringified, options.newlineConversion);
        }
        return stringified;
    }
    /**
     * Saves the file to disk.  Returns false if nothing was written due to options.onlyIfChanged.
     * @param jsonObject - the object to be saved
     * @param jsonFilename - the file path to write
     * @param options - other settings that control how the file is saved
     * @returns false if ISaveJsonFileOptions.onlyIfChanged didn't save anything; true otherwise
     */
    static save(jsonObject, jsonFilename, options) {
        if (!options) {
            options = {};
        }
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.updateExistingFile || options.onlyIfChanged) {
            if (FileSystem_1.FileSystem.exists(jsonFilename)) {
                try {
                    oldBuffer = FileSystem_1.FileSystem.readFileToBuffer(jsonFilename);
                } catch (error) {
                    // Ignore this error, and try writing a new file.  If that fails, then we should report that
                    // error instead.
                }
            }
        }
        let jsonToUpdate = '';
        if (options.updateExistingFile && oldBuffer) {
            jsonToUpdate = oldBuffer.toString();
        }
        const newJson = JsonFile.updateString(jsonToUpdate, jsonObject, options);
        const newBuffer = Buffer.from(newJson); // utf8 encoding happens here
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return false;
            }
        }
        FileSystem_1.FileSystem.writeFile(jsonFilename, newBuffer.toString(), {
            ensureFolderExists: options.ensureFolderExists
        });
        // TEST CODE: Used to verify that onlyIfChanged isn't broken by a hidden transformation during saving.
        /*
        const oldBuffer2: Buffer = FileSystem.readFileToBuffer(jsonFilename);
        if (Buffer.compare(buffer, oldBuffer2) !== 0) {
          console.log('new:' + buffer.toString('hex'));
          console.log('old:' + oldBuffer2.toString('hex'));
               throw new Error('onlyIfChanged logic is broken');
        }
        */
        return true;
    }
    /**
     * Used to validate a data structure before writing.  Reports an error if there
     * are any undefined members.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static validateNoUndefinedMembers(jsonObject) {
        return JsonFile._validateNoUndefinedMembers(jsonObject, []);
    }
    // Private implementation of validateNoUndefinedMembers()
    static _validateNoUndefinedMembers(jsonObject, keyPath) {
        if (!jsonObject) {
            return;
        }
        if (typeof jsonObject === 'object') {
            for (const key of Object.keys(jsonObject)) {
                keyPath.push(key);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const value = jsonObject[key];
                if (value === undefined) {
                    const fullPath = JsonFile._formatKeyPath(keyPath);
                    throw new Error(`The value for ${fullPath} is "undefined" and cannot be serialized as JSON`);
                }
                JsonFile._validateNoUndefinedMembers(value, keyPath);
                keyPath.pop();
            }
        }
    }
    // Given this input:    ['items', '4', 'syntax', 'parameters', 'string "with" symbols", 'type']
    // Return this string:  items[4].syntax.parameters["string \"with\" symbols"].type
    static _formatKeyPath(keyPath) {
        let result = '';
        for (const key of keyPath) {
            if (/^[0-9]+$/.test(key)) {
                // It's an integer, so display like this:  parent[123]
                result += `[${key}]`;
            } else if (/^[a-z_][a-z_0-9]*$/i.test(key)) {
                // It's an alphanumeric identifier, so display like this:  parent.name
                if (result) {
                    result += '.';
                }
                result += `${key}`;
            } else {
                // It's a freeform string, so display like this:  parent["A path: \"C:\\file\""]
                // Convert this:     A path: "C:\file"
                // To this:          A path: \"C:\\file\"
                const escapedKey = key.replace(/[\\]/g, '\\\\') // escape backslashes
                .replace(/["]/g, '\\'); // escape quotes
                result += `["${escapedKey}"]`;
            }
        }
        return result;
    }
}
exports.JsonFile = JsonFile;
//# sourceMappingURL=JsonFile.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkpzb25GaWxlLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwib3MiLCJyZXF1aXJlIiwiamp1IiwiVGV4dF8xIiwiRmlsZVN5c3RlbV8xIiwiSnNvbkZpbGUiLCJsb2FkIiwianNvbkZpbGVuYW1lIiwiRmlsZVN5c3RlbSIsImV4aXN0cyIsIkVycm9yIiwiY29udGVudHMiLCJyZWFkRmlsZSIsInBhcnNlIiwiZXJyb3IiLCJFT0wiLCJtZXNzYWdlIiwibG9hZEFuZFZhbGlkYXRlIiwianNvblNjaGVtYSIsIm9wdGlvbnMiLCJqc29uT2JqZWN0IiwidmFsaWRhdGVPYmplY3QiLCJsb2FkQW5kVmFsaWRhdGVXaXRoQ2FsbGJhY2siLCJlcnJvckNhbGxiYWNrIiwidmFsaWRhdGVPYmplY3RXaXRoQ2FsbGJhY2siLCJzdHJpbmdpZnkiLCJ1cGRhdGVTdHJpbmciLCJwcmV2aW91c0pzb24iLCJuZXdKc29uT2JqZWN0IiwidmFsaWRhdGVOb1VuZGVmaW5lZE1lbWJlcnMiLCJzdHJpbmdpZmllZCIsInVwZGF0ZSIsIm1vZGUiLCJpbmRlbnQiLCJwcmV0dHlGb3JtYXR0aW5nIiwiSlNPTiIsInVuZGVmaW5lZCIsIlRleHQiLCJlbnN1cmVUcmFpbGluZ05ld2xpbmUiLCJuZXdsaW5lQ29udmVyc2lvbiIsImNvbnZlcnRUbyIsInNhdmUiLCJvbGRCdWZmZXIiLCJ1cGRhdGVFeGlzdGluZ0ZpbGUiLCJvbmx5SWZDaGFuZ2VkIiwicmVhZEZpbGVUb0J1ZmZlciIsImpzb25Ub1VwZGF0ZSIsInRvU3RyaW5nIiwibmV3SnNvbiIsIm5ld0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJjb21wYXJlIiwid3JpdGVGaWxlIiwiZW5zdXJlRm9sZGVyRXhpc3RzIiwiX3ZhbGlkYXRlTm9VbmRlZmluZWRNZW1iZXJzIiwia2V5UGF0aCIsImtleSIsImtleXMiLCJwdXNoIiwiZnVsbFBhdGgiLCJfZm9ybWF0S2V5UGF0aCIsInBv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QUFYLENBQWdCUCxHQUFoQixDQUFKLEVBQTBCO0FBQ3RCO0FBQ0FNLDBCQUFXLElBQUdOLEdBQUksR0FBbEI7QUFDSCxhQUhELE1BSUssSUFBSSxzQkFBc0JPLElBQXRCLENBQTJCUCxHQUEzQixDQUFKLEVBQXFDO0FBQ3RDO0FBQ0Esb0JBQUlNLE1BQUosRUFBWTtBQUNSQSw4QkFBVSxHQUFWO0FBQ0g7QUFDREEsMEJBQVcsR0FBRU4sR0FBSSxFQUFqQjtBQUNILGFBTkksTUFPQTtBQUNEO0FBQ0E7QUFDQTtBQUNBLHNCQUFNUSxhQUFhUixJQUFJUyxPQUFKLENBQVksT0FBWixFQUFxQixNQUFyQixFQUE2QjtBQUE3QixpQkFDZEEsT0FEYyxDQUNOLE1BRE0sRUFDRSxJQURGLENBQW5CLENBSkMsQ0FLMkI7QUFDNUJILDBCQUFXLEtBQUlFLFVBQVcsSUFBMUI7QUFDSDtBQUNKO0FBQ0QsZUFBT0YsTUFBUDtBQUNIO0FBdkxVO0FBeUxmakUsUUFBUU8sUUFBUixHQUFtQkEsUUFBbkI7QUFDQSIsImZpbGUiOiJKc29uRmlsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGpqdSA9IHJlcXVpcmUoXCJqanVcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi9UZXh0XCIpO1xuY29uc3QgRmlsZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vRmlsZVN5c3RlbVwiKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciByZWFkaW5nL3dyaXRpbmcgSlNPTiBmaWxlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSnNvbkZpbGUge1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgSlNPTiBmaWxlLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkKGpzb25GaWxlbmFtZSkge1xuICAgICAgICBpZiAoIUZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLmV4aXN0cyhqc29uRmlsZW5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0IGZpbGUgbm90IGZvdW5kOiAke2pzb25GaWxlbmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50cyA9IEZpbGVTeXN0ZW1fMS5GaWxlU3lzdGVtLnJlYWRGaWxlKGpzb25GaWxlbmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gamp1LnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVhZGluZyBcIiR7anNvbkZpbGVuYW1lfVwiOmAgKyBvcy5FT0wgKyBgICAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBKU09OIGZpbGUgYW5kIHZhbGlkYXRlIGl0cyBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGxvYWRBbmRWYWxpZGF0ZShqc29uRmlsZW5hbWUsIGpzb25TY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QganNvbk9iamVjdCA9IEpzb25GaWxlLmxvYWQoanNvbkZpbGVuYW1lKTtcbiAgICAgICAganNvblNjaGVtYS52YWxpZGF0ZU9iamVjdChqc29uT2JqZWN0LCBqc29uRmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ganNvbk9iamVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBKU09OIGZpbGUgYW5kIHZhbGlkYXRlIGl0cyBzY2hlbWEsIHJlcG9ydGluZyBlcnJvcnMgdXNpbmcgYSBjYWxsYmFja1xuICAgICAqIEByZW1hcmtzXG4gICAgICogU2VlIEpzb25TY2hlbWEudmFsaWRhdGVPYmplY3RXaXRoQ2FsbGJhY2soKSBmb3IgbW9yZSBpbmZvLlxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkQW5kVmFsaWRhdGVXaXRoQ2FsbGJhY2soanNvbkZpbGVuYW1lLCBqc29uU2NoZW1hLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGpzb25PYmplY3QgPSBKc29uRmlsZS5sb2FkKGpzb25GaWxlbmFtZSk7XG4gICAgICAgIGpzb25TY2hlbWEudmFsaWRhdGVPYmplY3RXaXRoQ2FsbGJhY2soanNvbk9iamVjdCwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBqc29uT2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBzcGVjaWZpZWQgSlNPTiBvYmplY3QgdG8gYSBzdHJpbmcgYnVmZmVyLlxuICAgICAqIEBwYXJhbSBqc29uT2JqZWN0IC0gdGhlIG9iamVjdCB0byBiZSBzZXJpYWxpemVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBvdGhlciBzZXR0aW5ncyB0aGF0IGNvbnRyb2wgc2VyaWFsaXphdGlvblxuICAgICAqIEByZXR1cm5zIGEgSlNPTiBzdHJpbmcsIHdpdGggbmV3bGluZXMsIGFuZCBpbmRlbnRlZCB3aXRoIHR3byBzcGFjZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5naWZ5KGpzb25PYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEpzb25GaWxlLnVwZGF0ZVN0cmluZygnJywganNvbk9iamVjdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIHNwZWNpZmllZCBKU09OIG9iamVjdCB0byBhIHN0cmluZyBidWZmZXIuXG4gICAgICogQHBhcmFtIGpzb25PYmplY3QgLSB0aGUgb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG90aGVyIHNldHRpbmdzIHRoYXQgY29udHJvbCBzZXJpYWxpemF0aW9uXG4gICAgICogQHJldHVybnMgYSBKU09OIHN0cmluZywgd2l0aCBuZXdsaW5lcywgYW5kIGluZGVudGVkIHdpdGggdHdvIHNwYWNlc1xuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVTdHJpbmcocHJldmlvdXNKc29uLCBuZXdKc29uT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIEpzb25GaWxlLnZhbGlkYXRlTm9VbmRlZmluZWRNZW1iZXJzKG5ld0pzb25PYmplY3QpO1xuICAgICAgICBsZXQgc3RyaW5naWZpZWQ7XG4gICAgICAgIGlmIChwcmV2aW91c0pzb24gIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB1c2UgbW9kZT1qc29uIGhlcmUgYmVjYXVzZSBjb21tZW50cyBhcmVuJ3QgYWxsb3dlZCBieSBzdHJpY3QgSlNPTlxuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBqanUudXBkYXRlKHByZXZpb3VzSnNvbiwgbmV3SnNvbk9iamVjdCwge1xuICAgICAgICAgICAgICAgIG1vZGU6ICdjanNvbicsXG4gICAgICAgICAgICAgICAgaW5kZW50OiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnByZXR0eUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkID0gamp1LnN0cmluZ2lmeShuZXdKc29uT2JqZWN0LCB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGluZGVudDogMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KG5ld0pzb25PYmplY3QsIHVuZGVmaW5lZCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgIHN0cmluZ2lmaWVkID0gVGV4dF8xLlRleHQuZW5zdXJlVHJhaWxpbmdOZXdsaW5lKHN0cmluZ2lmaWVkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5uZXdsaW5lQ29udmVyc2lvbikge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBUZXh0XzEuVGV4dC5jb252ZXJ0VG8oc3RyaW5naWZpZWQsIG9wdGlvbnMubmV3bGluZUNvbnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIGZpbGUgdG8gZGlzay4gIFJldHVybnMgZmFsc2UgaWYgbm90aGluZyB3YXMgd3JpdHRlbiBkdWUgdG8gb3B0aW9ucy5vbmx5SWZDaGFuZ2VkLlxuICAgICAqIEBwYXJhbSBqc29uT2JqZWN0IC0gdGhlIG9iamVjdCB0byBiZSBzYXZlZFxuICAgICAqIEBwYXJhbSBqc29uRmlsZW5hbWUgLSB0aGUgZmlsZSBwYXRoIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBvdGhlciBzZXR0aW5ncyB0aGF0IGNvbnRyb2wgaG93IHRoZSBmaWxlIGlzIHNhdmVkXG4gICAgICogQHJldHVybnMgZmFsc2UgaWYgSVNhdmVKc29uRmlsZU9wdGlvbnMub25seUlmQ2hhbmdlZCBkaWRuJ3Qgc2F2ZSBhbnl0aGluZzsgdHJ1ZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgc2F2ZShqc29uT2JqZWN0LCBqc29uRmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byByZWFkIHRoZSBwcmV2aW91cyBmaWxlIGNvbnRlbnRzP1xuICAgICAgICBsZXQgb2xkQnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAob3B0aW9ucy51cGRhdGVFeGlzdGluZ0ZpbGUgfHwgb3B0aW9ucy5vbmx5SWZDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoRmlsZVN5c3RlbV8xLkZpbGVTeXN0ZW0uZXhpc3RzKGpzb25GaWxlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbGRCdWZmZXIgPSBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS5yZWFkRmlsZVRvQnVmZmVyKGpzb25GaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhpcyBlcnJvciwgYW5kIHRyeSB3cml0aW5nIGEgbmV3IGZpbGUuICBJZiB0aGF0IGZhaWxzLCB0aGVuIHdlIHNob3VsZCByZXBvcnQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQganNvblRvVXBkYXRlID0gJyc7XG4gICAgICAgIGlmIChvcHRpb25zLnVwZGF0ZUV4aXN0aW5nRmlsZSAmJiBvbGRCdWZmZXIpIHtcbiAgICAgICAgICAgIGpzb25Ub1VwZGF0ZSA9IG9sZEJ1ZmZlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0pzb24gPSBKc29uRmlsZS51cGRhdGVTdHJpbmcoanNvblRvVXBkYXRlLCBqc29uT2JqZWN0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gQnVmZmVyLmZyb20obmV3SnNvbik7IC8vIHV0ZjggZW5jb2RpbmcgaGFwcGVucyBoZXJlXG4gICAgICAgIGlmIChvcHRpb25zLm9ubHlJZkNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIEhhcyB0aGUgZmlsZSBjaGFuZ2VkP1xuICAgICAgICAgICAgaWYgKG9sZEJ1ZmZlciAmJiBCdWZmZXIuY29tcGFyZShuZXdCdWZmZXIsIG9sZEJ1ZmZlcikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBkb24ndCB0b3VjaCB0aGUgZmlsZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBGaWxlU3lzdGVtXzEuRmlsZVN5c3RlbS53cml0ZUZpbGUoanNvbkZpbGVuYW1lLCBuZXdCdWZmZXIudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgZW5zdXJlRm9sZGVyRXhpc3RzOiBvcHRpb25zLmVuc3VyZUZvbGRlckV4aXN0c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVEVTVCBDT0RFOiBVc2VkIHRvIHZlcmlmeSB0aGF0IG9ubHlJZkNoYW5nZWQgaXNuJ3QgYnJva2VuIGJ5IGEgaGlkZGVuIHRyYW5zZm9ybWF0aW9uIGR1cmluZyBzYXZpbmcuXG4gICAgICAgIC8qXG4gICAgICAgIGNvbnN0IG9sZEJ1ZmZlcjI6IEJ1ZmZlciA9IEZpbGVTeXN0ZW0ucmVhZEZpbGVUb0J1ZmZlcihqc29uRmlsZW5hbWUpO1xuICAgICAgICBpZiAoQnVmZmVyLmNvbXBhcmUoYnVmZmVyLCBvbGRCdWZmZXIyKSAhPT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCduZXc6JyArIGJ1ZmZlci50b1N0cmluZygnaGV4JykpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvbGQ6JyArIG9sZEJ1ZmZlcjIudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHlJZkNoYW5nZWQgbG9naWMgaXMgYnJva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdmFsaWRhdGUgYSBkYXRhIHN0cnVjdHVyZSBiZWZvcmUgd3JpdGluZy4gIFJlcG9ydHMgYW4gZXJyb3IgaWYgdGhlcmVcbiAgICAgKiBhcmUgYW55IHVuZGVmaW5lZCBtZW1iZXJzLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIHZhbGlkYXRlTm9VbmRlZmluZWRNZW1iZXJzKGpzb25PYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEpzb25GaWxlLl92YWxpZGF0ZU5vVW5kZWZpbmVkTWVtYmVycyhqc29uT2JqZWN0LCBbXSk7XG4gICAgfVxuICAgIC8vIFByaXZhdGUgaW1wbGVtZW50YXRpb24gb2YgdmFsaWRhdGVOb1VuZGVmaW5lZE1lbWJlcnMoKVxuICAgIHN0YXRpYyBfdmFsaWRhdGVOb1VuZGVmaW5lZE1lbWJlcnMoanNvbk9iamVjdCwga2V5UGF0aCkge1xuICAgICAgICBpZiAoIWpzb25PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGpzb25PYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhqc29uT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGtleVBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBqc29uT2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBKc29uRmlsZS5fZm9ybWF0S2V5UGF0aChrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdmFsdWUgZm9yICR7ZnVsbFBhdGh9IGlzIFwidW5kZWZpbmVkXCIgYW5kIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFzIEpTT05gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSnNvbkZpbGUuX3ZhbGlkYXRlTm9VbmRlZmluZWRNZW1iZXJzKHZhbHVlLCBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICBrZXlQYXRoLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdpdmVuIHRoaXMgaW5wdXQ6ICAgIFsnaXRlbXMnLCAnNCcsICdzeW50YXgnLCAncGFyYW1ldGVycycsICdzdHJpbmcgXCJ3aXRoXCIgc3ltYm9sc1wiLCAndHlwZSddXG4gICAgLy8gUmV0dXJuIHRoaXMgc3RyaW5nOiAgaXRlbXNbNF0uc3ludGF4LnBhcmFtZXRlcnNbXCJzdHJpbmcgXFxcIndpdGhcXFwiIHN5bWJvbHNcIl0udHlwZVxuICAgIHN0YXRpYyBfZm9ybWF0S2V5UGF0aChrZXlQYXRoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5UGF0aCkge1xuICAgICAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhbiBpbnRlZ2VyLCBzbyBkaXNwbGF5IGxpa2UgdGhpczogIHBhcmVudFsxMjNdXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGBbJHtrZXl9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXlthLXpfXVthLXpfMC05XSokL2kudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciwgc28gZGlzcGxheSBsaWtlIHRoaXM6ICBwYXJlbnQubmFtZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAke2tleX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIGZyZWVmb3JtIHN0cmluZywgc28gZGlzcGxheSBsaWtlIHRoaXM6ICBwYXJlbnRbXCJBIHBhdGg6IFxcXCJDOlxcXFxmaWxlXFxcIlwiXVxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhpczogICAgIEEgcGF0aDogXCJDOlxcZmlsZVwiXG4gICAgICAgICAgICAgICAgLy8gVG8gdGhpczogICAgICAgICAgQSBwYXRoOiBcXFwiQzpcXFxcZmlsZVxcXCJcbiAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkS2V5ID0ga2V5LnJlcGxhY2UoL1tcXFxcXS9nLCAnXFxcXFxcXFwnKSAvLyBlc2NhcGUgYmFja3NsYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcIl0vZywgJ1xcXFwnKTsgLy8gZXNjYXBlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgW1wiJHtlc2NhcGVkS2V5fVwiXWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkpzb25GaWxlID0gSnNvbkZpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uRmlsZS5qcy5tYXAiXX0=