/**
 * @copyright Microsoft Corporation. All rights reserved.
 *
 * @file This file contains an inventory of all of our framework's polyfills.
 * All webpart and application code can rely on these libraries being polyfilled by our framework.
 */
"use strict";
/**
 * ES6 Harmony Collections Polyfill
 * ES6 Harmony Collections  was added as a polyfill to provide a lightweight unobtrusive shim for
 * ES2015 collections. The implementations of Map, Set, and WeakMap provided by this polyfill
 * adhere to the ES2015 standard. Functions that abide by the ES2015 standard such as Map.get()
 * and Set.has() are guaranteed to run in sublinear time rather than the expected constant time
 * for a standard hashmap implementation. (See http://stackoverflow.com/a/31092145) The alternative
 * popular library to ES6 Harmony Collections is ES6 shim. After running some samples tests, we have
 * determined that ES6 Harmony Collections performs better on a larger set of operations than
 * the es6-shim. (Tests were run here: https://jsperf.com/es6-shim-vs-es6-collections/2 ).
 * ES6 shim is also a much larger library in size, so the decision stick with ES6 collections
 * was easy to make.
 * https://github.com/WebReflection/es6-collections
 */
require('es6-collections');
/**
 * ES6 Promise Polyfill
 * Adds an implementation of the ES2015-Promise to the browser. The implementation is a subset
 * of rsvp.js.
 * (See: https://github.com/tildeio/rsvp.js) ES6 Promise is compliant with Promises/A+
 * (See: https://promisesaplus.com/)
 * Very useful for using Promise in the Safari/IE/Edge (already supported by Chrome/Firefox)
 * https://github.com/jakearchibald/es6-promise
 */
require('es6-promise');
/**
 * Edge has a bug in their fetch implementation, which will cause an exception to be thrown if
 * there are unicode characters in the body. The issue was first found in 14.14393 and is fixed in
 * the Redstone 2 build of Edge (verified with a pre-release build). Until the fix is released,
 * we will fall back to the polyfill on Edge. [VSO:SPPPlat #239938]
 * https://microsoft.visualstudio.com/DefaultCollection/OS/_workitems?id=8475223&fullScreen=false&_a=edit
 */
if (navigator.userAgent.indexOf('Edge/') >= 0) {
    // Set window.fetch to undefined so whatwg-fetch polyfill will redefine it.
    window.fetch = undefined;
}
/**
 * Window.Fetch PolyFill
 * Adds an implementation of the Fetch standard to the browser.
 * Very useful for using the fetch api in the Safari/IE (already supported by Chrome/Firefox/Edge)
 * https://github.com/github/fetch
 */
require('whatwg-fetch');
/**
 * We don't load whatwg-fetch polyfill for Firefox because it has a native implementation, but
 * (unlike Chrome) it is missing the forEach() method.  Ideally we should be using for..of
 * instead of forEach(), however TypeScript won't support that syntax until version 2.0.
 * As a temporary workaround, we will polyfill the missing forEach() method for Firefox.
 * Discussion: https://github.com/github/fetch/issues/149
 */
if (typeof Headers.prototype.forEach === 'undefined') {
    Headers.prototype.forEach = function (callback) {
        var iterator = this.entries();
        for (;;) {
            var entry = iterator.next();
            if (entry.done) {
                break;
            }
            // NOTE: The array returns [name,value] but the callback takes (value, name).
            callback(entry.value[1], entry.value[0]);
        }
    };
}
// TypeScript 2.0 Typings have location.origin and performance as readonly properties.
/**
 * This is a polyfill for window.location.origin, which is not supported by the IE browser
 */
if (!window.location.origin) {
    window.location.origin = window.location.protocol // tslint:disable-line:no-any
        + '//'
        + window.location.hostname
        + (window.location.port ? ':' + window.location.port : '');
}
/**
 * IE9 doesn't support performance.now(), so we need to polyfill that
 */
if (!window.performance) {
    window.performance = {}; // tslint:disable-line:no-any
}
if (!window.performance.now) {
    /**
     * Polyfill performance.now with a function that returns the number of milliseconds since the moduler loader loaded.
     *  Not as accurate as the real performance.now() function, but as accurate as we're able to get with a polyfill.
     */
    var pageLoadTime_1 = Date.now();
    window.performance.now = function () { return Date.now() - pageLoadTime_1; };
}

//# sourceMappingURL=FrameworkPolyfills.js.map
