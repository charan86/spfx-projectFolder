/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file SystemJsWrapper.ts
 */
"use strict";
var loadSystemPolyfills = typeof Promise === 'undefined';
if (loadSystemPolyfills) {
    require('raw-script!systemjs/dist/system-polyfills');
}
var system = require('raw-script!systemjs/dist/system');
var sp_module_interfaces_1 = require('@microsoft/sp-module-interfaces');
var SPModuleLoaderProvider_1 = require('./SPModuleLoaderProvider');
var stringFormat_1 = require('./utilities/stringFormat');
var SystemJsWrapper_resx_1 = require('./SystemJsWrapper.resx');
/**
 * Our wrapper around SystemJS for loading our own modules.
 */
var SystemJsWrapper = (function () {
    function SystemJsWrapper() {
        /**
         * Map from a serial ID to the associated loader config.
         */
        this._manifestMap = new Map();
        /* tslint:disable:no-any */
        this._componentCache = new Map();
        /* tslint:enable:no-any */
        this._parentMap = new Map();
    }
    Object.defineProperty(SystemJsWrapper, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new SystemJsWrapper();
                this._instance._initialize();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Given a loader config, load a module.
     *
     * @param {manifest} A manifest loader config.
     * @param {id} The manifest's ID
     * @returns A promise containing the loaded module.
     */
    /* tslint:disable:no-any */
    SystemJsWrapper.prototype.loadManifestModules = function (id, manifest, entryName, preloadDependencies) {
        var _this = this;
        if (preloadDependencies === void 0) { preloadDependencies = true; }
        if (!this._componentCache.has(id)) {
            this._componentCache.set(id, new Map());
        }
        var componentModuleCache = this._componentCache.get(id);
        if (!componentModuleCache.has(id)) {
            this._manifestMap.set(id, manifest);
            componentModuleCache.set(id, system.import(id));
        }
        // The manifest may or may not have been loaded with preloadDependencies
        var dependencies = Object.keys(manifest.scriptResources).map(function (resource) {
            if (resource !== manifest.entryModuleId) {
                // Preload unless shouldNotPreload flag is true
                if (!componentModuleCache.has(resource) && manifest.scriptResources[resource].shouldNotPreload !== true) {
                    _this._parentMap.set(resource, id);
                    var dependency = system.import(resource);
                    componentModuleCache.set(resource, dependency);
                    return dependency;
                }
            }
        });
        return Promise.all([componentModuleCache.get(id)].concat(dependencies)).then(function (entry) {
            var result = entry[0];
            if (entryName) {
                result = result[entryName];
            }
            if (manifest.exportedModuleName) {
                result = result[manifest.exportedModuleName];
            }
            return result;
        });
    };
    /* tslint:enable:no-any */
    /**
     * Given a URL, load a script.
     *
     * @param {scriptSrc} The script URL.
     * @param {globalExportsName} (optional) If the script isn't an AMD module and loads a global member on the page,
     *                  specify the global member's name.
     * @return A promise containing the loaded module.
     */
    SystemJsWrapper.prototype.loadScript = function (scriptSrc, globalExportsName) {
        if (globalExportsName) {
            var globalMetaConfig = {
                meta: {}
            };
            globalMetaConfig.meta[scriptSrc] = {
                format: 'global',
                exports: globalExportsName
            };
            system.config(globalMetaConfig);
        }
        return system.import(scriptSrc);
    };
    Object.defineProperty(SystemJsWrapper.prototype, "currentLocale", {
        /**
         * Set the current locale.
         *
         * @param {locale} The user's locale.
         */
        set: function (locale) {
            if (locale) {
                locale = locale.toLowerCase();
            }
            this._currentLocale = locale;
        },
        enumerable: true,
        configurable: true
    });
    SystemJsWrapper.prototype._initialize = function () {
        var _this = this;
        var pluginName = 'sp-module-loader-resolver';
        var placeholderBaseUrl = 'https://placeholder-base-url/';
        /**
         * Resolve a localized module config to a URL.
         */
        var resolveLocalizedModuleConfig = function (moduleConfig) {
            if (moduleConfig.paths) {
                // Workaround for temporary issue in SPOREL. VSO#238501
                if ('default' in moduleConfig.paths && Object.keys(moduleConfig.paths).length === 1) {
                    // IFF only a "default" path is provided, use that path.
                    return moduleConfig.paths['default'];
                }
                else if (_this._currentLocale) {
                    for (var locale in moduleConfig.paths) {
                        if (locale && locale.toLowerCase() === _this._currentLocale && moduleConfig.paths[locale]) {
                            return moduleConfig.paths[locale];
                        }
                    }
                }
            }
            return moduleConfig.defaultPath;
        };
        /**
         * Resolve a IModuleConfig to a URL
         *
         * Take a look at the IModuleConfig documentation for more information.
         */
        var resolveModuleConfig = function (moduleName, moduleConfig) {
            if (moduleConfig) {
                switch (moduleConfig.type) {
                    case 'framework':
                        return moduleName;
                    case 'internal':
                        return _this._resolvePath(moduleConfig.path);
                    case 'localized':
                        return _this._resolvePath(resolveLocalizedModuleConfig(moduleConfig));
                    case null: // tslint:disable-line:no-null-keyword
                    case undefined:
                    default:
                        return moduleName;
                }
            }
            else {
                return moduleName;
            }
        };
        /**
         * We need to keep track of each imported module's parent module so we can resolve its manifest. This
         * small wrapper around the system normalize function records the parent name of each module because that field
         * doesn't get passed to the loader.
         */
        var self = this;
        var oldNormalize = system.normalize;
        system.normalize = function (name, parentName, parentAddress) {
            // parentName           == "https://baseURL/4d5eb168-6729-49a8-aec7-0e397f486b6e"
            // normalizedParentName == "4d5eb168-6729-49a8-aec7-0e397f486b6e"
            var normalizedParentName = (parentName &&
                parentName.length > placeholderBaseUrl.length &&
                parentName.substr(0, placeholderBaseUrl.length) === placeholderBaseUrl)
                ? parentName.substr(placeholderBaseUrl.length)
                : parentName;
            // @todo VSO #212246: this naive mapping strategy has several issues, replace with more robust solution
            var parent = self._parentMap.get(name) || normalizedParentName;
            while (parent && !self._manifestMap.has(parent)) {
                parent = self._parentMap.get(parent);
            }
            self._parentMap.set(name, parent);
            return oldNormalize.call(this, name, parentName, parentAddress);
        };
        var loader = {
            /**
             * This step's purpose is to reolve a resource's name to its location. There are three different types of resource
             * references in our manifest schema, and there are four different types of address resolutions:
             * - If we pass a URL directly into this function, just return the URL. This means that we aren't loading a
             *    manifest.
             * - If we resolve to an internal module, pass the path and fetch will load that
             * - If we resolve a localized module, pick the current locale (or default) and pass the path to fetch like
             *    an internal module
             * - If we resolve an framework module, pass the name to fetch and let fetch find it by name
             */
            locate: function (module) {
                var moduleName = (module.address.indexOf(placeholderBaseUrl) === 0)
                    ? module.address.substring(placeholderBaseUrl.length)
                    : module.address;
                // Get the manifest either by the identifier that was passed to SystemJS, or if this is a child dependency,
                // resolve the parent name and find the manifest based on that.
                var parentName = _this._parentMap.get(moduleName);
                var manifest = _this._manifestMap.get(moduleName);
                var moduleConfig;
                if (manifest) {
                    moduleConfig = manifest.scriptResources[manifest.entryModuleId];
                }
                else if (parentName) {
                    manifest = _this._manifestMap.get(parentName);
                    moduleConfig = manifest.scriptResources[moduleName];
                }
                if (!moduleConfig) {
                    console.log(stringFormat_1.default(SystemJsWrapper_resx_1.default.unableToResolveConfigError, moduleName));
                }
                // Populate some important properties we need to persist in the SystemJS module object
                module.name = moduleName;
                var metadata = module.metadata;
                metadata.manifest = manifest;
                metadata.moduleConfig = moduleConfig;
                // Resolve the path or name.
                return resolveModuleConfig(moduleName, moduleConfig);
            },
            /**
             * This step's purpose is to go out and get the module that "locate" found. There are three different core
             * scenarios in this function:
             * - The simplest is if this function recieves a path or a full URL. If it recieves a path, the
             *    internalModuleBaseUrls from the manifest is prepended. Now with a full URL, we fall through to the OOB
             *    SystemJS scriptLoad fetch step.
             * - If we recieve a module name that we have bundled with the loader (react, flux, etc), we'll have webpack load
             *    that module and return a promise that resolves to a SystemJS module containing the requested object.
             *    NOTE: this method will go away when we support bundling multiple modules in a single manifest.
             * - If we recieve a module name that resolves to one of the standard modules with an associated manifest, we'll
             *    load that manifest using the same pipeline that we use to load any other manifest.
             */
            fetch: function (module) {
                var metadata = module.metadata;
                var address = module.address;
                // Check if we're looking at an framework moduleConfig
                if (metadata.moduleConfig && metadata.moduleConfig.type === 'framework') {
                    var moduleConfig = metadata.moduleConfig;
                    var standardLibraryModule = sp_module_interfaces_1.standardLibraryModules[address];
                    if (standardLibraryModule) {
                        // Special case where the module loader is an external package
                        if (address === '@microsoft/sp-module-loader') {
                            // Grab instance module to ensure we can hand exactly the same interface to packages were built against
                            return Promise.resolve({ module: require('./index'), match: function () { return undefined; } });
                        }
                        try {
                            return SPModuleLoaderProvider_1.default.instance.loadStandardLibraryModule(standardLibraryModule, address)
                                .then(function (loadedModule) {
                                // Wrap the loaded module so it falls through the rest of SystemJS
                                return { module: loadedModule, match: function () { return undefined; } };
                            });
                        }
                        catch (e) {
                        }
                    }
                    // If we make it here, we weren't able to load the module by its manifest, so let's fall back to the path
                    //   provided in the manfiest
                    if (moduleConfig.failoverPath) {
                        address = _this._resolvePath(moduleConfig.failoverPath);
                    }
                    else {
                        throw new Error(stringFormat_1.default(SystemJsWrapper_resx_1.default.invalidFrameworkModuleError, module.address));
                    }
                }
                // Fall back to the default systemJS loader if we make it here
                metadata.scriptLoad = true;
                metadata.loaderModule = undefined;
                metadata.loader = undefined;
                // Prepend the base URL if this isn't a fully-qualified URL.
                if (!module.address.match(/^https?\:\/\//)) {
                    // Replace this with shared URL concatenation logic. VSO#249681
                    var moduleBaseUrl = (metadata.manifest.internalModuleBaseUrls[0] || placeholderBaseUrl).replace(/\/+$/, '');
                    module.address = moduleBaseUrl + "/" + address;
                }
                var modulesToLoad = [];
                // If this is a non-AMD module, inject dependency and globalName information
                var internalModuleLoaderConfig = metadata.moduleConfig;
                if (metadata.moduleConfig && internalModuleLoaderConfig.globalName) {
                    // Load the script via XHR so we can execute in a sandbox
                    metadata.scriptLoad = false;
                    // @todo VSO #246501: load most externals scripts into a semi sandboxed/railed environment,
                    // which will neccesitate the use of XHR.
                    // Configure SystemJS to load this module correctly
                    module.metadata.scriptLoad = true;
                    module.metadata.format = 'global';
                    module.metadata.exports = internalModuleLoaderConfig.globalName;
                    // Manually ensure dependencies are loaded
                    modulesToLoad = (internalModuleLoaderConfig.globalDependencies || []).map(function (dependencyName) {
                        return system.import(dependencyName);
                    });
                }
                // Call the OOB SystemJS fetch code.
                modulesToLoad.unshift(system.fetch(module));
                var loadNecessaryModules = Promise.all(modulesToLoad);
                return loadNecessaryModules.then(function (loadedModules) {
                    return loadedModules[0];
                });
            },
            /**
             * Not doing anything here - just passing the source module through.
             */
            translate: function (module) {
                return module.source.module;
            },
            /**
             * Not doing anything here - just passing the source module through.
             */
            instantiate: function (module) {
                return module.source.module;
            }
        };
        /**
         * Create a default SystemJS config that passes everything to our loader.
         */
        var systemConfig = {
            baseURL: placeholderBaseUrl,
            defaultJsExtensions: false,
            meta: {
                '*': {
                    loader: pluginName,
                    scriptLoad: true
                }
            }
        };
        // Load the loader as a system module and then set the system config. We need to do this is this order, otherwise
        // SystemJS will try to load our loader with itself, and will throw.
        system.set(pluginName, system.newModule(loader));
        system.config(systemConfig);
    };
    /**
     * Resolve a path to the min or debug version of a script. Currently only min versions are supported.
     */
    SystemJsWrapper.prototype._resolvePath = function (path) {
        if (typeof path === 'string') {
            return path;
        }
        else {
            return path.default;
        }
    };
    return SystemJsWrapper;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SystemJsWrapper;

//# sourceMappingURL=SystemJsWrapper.js.map
