/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file DebugManifestProvider.ts
 */
"use strict";
var SystemJsWrapper_1 = require('./SystemJsWrapper');
var SPModuleLoader_1 = require('./SPModuleLoader');
var debugManifestsQueryParameterName = 'debugManifests';
var debugManifestsFileQueryParameterName = 'debugManifestsFile';
var sessionStorageKey = 'sp-module-loader_debugManifests';
/**
 * This class assists with parsing debug manifests from the URL fragment or from sessionStorage.
 *
 * --- NEW APPROACH ---
 * We allow developers to specify a set of manifests in the URL to override the manifests we get from the server.
 * The format is: <url-to-page>.aspx#debugManifestsFile=<path to manfiests init script>
 *
 * When a manifest file is specified in the URL, we cache its contents in sessionStorage so the developer doesn't need
 * to supply it on every request. This class also reads the "reset=1" query parameter to clear the cached debug
 * manifests from sessionStorage.
 *
 * --- OLD APPROACH ---
 * We allow developers to specify a set of manifests in the URL to override the manifests we get from the server.
 * The format is: <url-to-page>.aspx#debugManifests=<URL-encoded JSON object>
 * And the format of the JSON object is:
 *  {
 *    "manifest-id-1": { <manifest object> },
 *    "manifest-id-2": { <manifest object> }
 *  }
 *
 * When a manifest is specified in the URL, we cache it in sessionStorage so the developer doesn't need to
 * supply it on every request. This class also reads the "reset=1" query parameter to clear the cached debug
 * manifests from sessionStorage.
 *
 * This is a temporary implementation until we update the build tools to support a more developer-friendly approach.
 * VSO#201640.
 */
var DebugManifestProvider = (function () {
    function DebugManifestProvider() {
    }
    Object.defineProperty(DebugManifestProvider, "instance", {
        get: function () {
            if (!this._instance) {
                this._instance = new DebugManifestProvider();
            }
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    DebugManifestProvider.prototype.getDebugManifests = function (noCache, alternativeManifestsFiles) {
        var _this = this;
        if (noCache === void 0) { noCache = false; }
        return new Promise(function (resolve) {
            var localDebugManifests = _this._parseManifestsFromFragementQueryParameter();
            if (window.location.search.match(/\breset\b/)) {
                try {
                    window.sessionStorage.removeItem(sessionStorageKey);
                }
                catch (e) {
                    /* tslint:disable:no-console */
                    console.debug("Error clearing session storage. Error: " + e);
                }
                resolve({});
            }
            else {
                var existingManifests_1 = {};
                try {
                    existingManifests_1 = JSON.parse(window.sessionStorage.getItem(sessionStorageKey)) || {};
                }
                catch (e) {
                    /* tslint:disable:no-console */
                    console.debug("Error querying session storage. Error: " + e);
                }
                Object.keys(existingManifests_1).forEach(function (existingManifestKey) {
                    if (!localDebugManifests[existingManifestKey]) {
                        localDebugManifests[existingManifestKey] = existingManifests_1[existingManifestKey];
                    }
                });
                var queryParameterManifestsFile = _this._parseManifestsFileFromFragementQueryParameter(false);
                var manifestsFiles_1 = !!queryParameterManifestsFile
                    ? [queryParameterManifestsFile]
                    : alternativeManifestsFiles;
                if (manifestsFiles_1 && manifestsFiles_1.length > 0 && SPModuleLoader_1.ensureDebugAllowed()) {
                    var tryGetDebugManifests_1 = function (promise) {
                        return promise.then(function (manifestsScript) {
                            _this._parseManifestsFileFromFragementQueryParameter(true); // Clear the parameter only if file loaded
                            var manifests = manifestsScript.getManifests();
                            manifests.forEach(function (manifest) {
                                localDebugManifests[manifest.id] = manifest;
                            });
                            if (!noCache) {
                                _this._trySetSessionStorageManifests(localDebugManifests);
                            }
                            resolve(localDebugManifests);
                        });
                    };
                    var debugManifestsScriptPromise = tryGetDebugManifests_1(SystemJsWrapper_1.default.instance.loadScript(manifestsFiles_1[0]));
                    // We may have multiple URLs for the debug manifests file (i.e. - one for HTTPS, one for HTTP),
                    // so we'll try them sequentally until one of them is successfully loaded.
                    var _loop_1 = function(i) {
                        var oldPromise = debugManifestsScriptPromise;
                        debugManifestsScriptPromise = oldPromise.catch(function () {
                            return tryGetDebugManifests_1(SystemJsWrapper_1.default.instance.loadScript(manifestsFiles_1[i]));
                        });
                    };
                    for (var i = 1; i < manifestsFiles_1.length; i++) {
                        _loop_1(i);
                    }
                    debugManifestsScriptPromise.catch(function (error) {
                        alert(("Error loading debug manifest script. (" + (error.message ? error.message : error) + ") \n\n") +
                            'Ensure loading unsafe scripts is allowed.');
                    });
                }
                else {
                    if (!noCache) {
                        _this._trySetSessionStorageManifests(localDebugManifests);
                    }
                    resolve(localDebugManifests);
                }
            }
        });
    };
    DebugManifestProvider.prototype._trySetSessionStorageManifests = function (localDebugManifests) {
        try {
            window.sessionStorage.setItem(sessionStorageKey, JSON.stringify(localDebugManifests));
        }
        catch (e) {
            /* tslint:disable:no-console */
            console.debug("Error setting session storage. Error: " + e);
        }
    };
    DebugManifestProvider.prototype._parseManifestsFileFromFragementQueryParameter = function (clearParamter) {
        return this._getAndClearFragmentQueryParameter(debugManifestsFileQueryParameterName, clearParamter);
    };
    DebugManifestProvider.prototype._parseManifestsFromFragementQueryParameter = function () {
        var debugManifestsString = this._getAndClearFragmentQueryParameter(debugManifestsQueryParameterName);
        if (debugManifestsString) {
            try {
                return JSON.parse(debugManifestsString);
            }
            catch (e) {
                /* tslint:disable:no-console */
                console.debug("Error parsing manifests query parameter. Error: " + e);
            }
        }
        else {
            return {};
        }
    };
    DebugManifestProvider.prototype._getAndClearFragmentQueryParameter = function (parameter, clearParamter) {
        if (clearParamter === void 0) { clearParamter = true; }
        var result = undefined;
        if (window.location.hash) {
            var fragment = window.location.hash.indexOf('#') === 0
                ? window.location.hash.substr(1)
                : window.location.hash;
            var fragmentQueryParameters = this._parseQueryParameters(fragment);
            if (fragmentQueryParameters &&
                fragmentQueryParameters[parameter]) {
                result = decodeURIComponent(fragmentQueryParameters[parameter]);
                if (clearParamter) {
                    // Re-generate the fragment without the parameter.
                    var newFragment = fragment.replace(parameter + "=" + fragmentQueryParameters[parameter], '');
                    if (newFragment !== '') {
                        window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search + "#" + newFragment);
                    }
                    else {
                        window.history.replaceState('', document.title, "" + window.location.pathname + window.location.search);
                    }
                }
            }
        }
        return result;
    };
    /**
     * Parse a string as querystring parameters. VSO:201753 to replace with standard library.
     */
    DebugManifestProvider.prototype._parseQueryParameters = function (queryParameterString) {
        if (queryParameterString) {
            if (queryParameterString.indexOf('?') === 0) {
                queryParameterString = queryParameterString.substr(1);
            }
            var queryParameters = queryParameterString.split('&');
            var result_1 = {};
            queryParameters.forEach(function (queryParameter) {
                var equalsIndex = queryParameter.indexOf('=');
                if (equalsIndex === -1) {
                    result_1[queryParameter] = '';
                }
                else {
                    result_1[queryParameter.substr(0, equalsIndex)] = queryParameter.substr(equalsIndex + 1);
                }
            });
            return result_1;
        }
        else {
            return undefined;
        }
    };
    return DebugManifestProvider;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DebugManifestProvider;

//# sourceMappingURL=DebugManifestProvider.js.map
