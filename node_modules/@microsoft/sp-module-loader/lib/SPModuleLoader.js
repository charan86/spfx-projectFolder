/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file SPModuleLoader.ts
 */
"use strict";
require('set-webpack-public-path!');
var Combokeys = require('combokeys');
var sp_module_interfaces_1 = require('@microsoft/sp-module-interfaces');
// Keep DeveloperToolsLoader at the top to keep the chunks ordered correctly
var DeveloperToolsLoader_1 = require('./DeveloperTools/DeveloperToolsLoader');
var SystemJsWrapper_1 = require('./SystemJsWrapper');
var ManifestStore_1 = require('./stores/ManifestStore');
var ModuleStore_1 = require('./stores/ModuleStore');
var DebugManifestProvider_1 = require('./DebugManifestProvider');
var SPFlight_1 = require('./staticLinks/SPFlight');
var stringFormat_1 = require('./utilities/stringFormat');
var SPModuleLoader_resx_1 = require('./SPModuleLoader.resx');
var basePlatformPackageName = '@microsoft/sp-client-preview';
var _allowDebug = undefined;
function ensureDebugAllowed(ask) {
    if (ask === void 0) { ask = true; }
    if (!ask || _allowDebug !== undefined) {
        return !!_allowDebug;
    }
    else {
        // Inform the user that they might be loading debug manifests
        _allowDebug = confirm(SPModuleLoader_resx_1.default.debugManifestLoadingWarning);
        return _allowDebug;
    }
}
exports.ensureDebugAllowed = ensureDebugAllowed;
/**
 * The global module loader for SP client-side applications and webparts.
 *
 * This is an API that lives in a global variable on the window, similar to how systemJS works.
 *
 * @public
 */
var SPModuleLoader = (function () {
    // Initialization
    function SPModuleLoader() {
        // Watching for hotkeys on the whole document.
        var fullWindowCombokeys = new Combokeys(document.documentElement);
        // Bind the debugger to "ctrl+shift+`"
        fullWindowCombokeys.bind('ctrl+shift+`', function () { return DeveloperToolsLoader_1.default.instance.toggleDeveloperTools(); });
        if (!SPModuleLoader._headElement) {
            SPModuleLoader._headElement = document.getElementsByTagName('head')[0];
        }
    }
    SPModuleLoader.prototype.initialize = function (preloadedData) {
        var _this = this;
        return new Promise(function (resolve) {
            ManifestStore_1.default.instance.populateManifests(preloadedData);
            _this._loadDebugManifests().then(function () {
                if (preloadedData && preloadedData.spPageContextInfo) {
                    SystemJsWrapper_1.default.instance.currentLocale = preloadedData.spPageContextInfo.currentUICultureName;
                }
                resolve();
            });
        });
    };
    /**
     * This is called by the page scripts to start loading the framework. Do not call it from your own code.
     */
    /* tslint:disable:no-any */
    SPModuleLoader.prototype.start = function (preloadedData) {
        var _this = this;
        if (preloadedData && preloadedData.spPageContextInfo) {
            SPFlight_1.default.initialize(preloadedData.spPageContextInfo.ExpFeatures);
        }
        var result = new Promise(function (resolve, reject) {
            /* tslint:enable:no-any */
            _this.initialize(preloadedData).then(function () {
                if (preloadedData) {
                    var applicationManifestId = preloadedData.clientSideApplicationId
                        ? preloadedData.clientSideApplicationId
                        : (preloadedData.clientSideApplicationManifest
                            ? preloadedData.clientSideApplicationManifest.id
                            : undefined);
                    var manifest_1 = ManifestStore_1.default.instance.getManifestById(applicationManifestId);
                    if (manifest_1) {
                        var platformModule = sp_module_interfaces_1.standardLibraryModules[basePlatformPackageName];
                        var loadingComplete_1 = false;
                        Promise.all([
                            // Load the platform in addition to the application
                            _this.loadStandardLibraryModule(platformModule, basePlatformPackageName),
                            SystemJsWrapper_1.default.instance.loadManifestModules(manifest_1.id, manifest_1.loaderConfig)
                        ])
                            .then(function (modules) {
                            loadingComplete_1 = true;
                            var platform = modules[0]; // tslint:disable-line:no-any
                            var application = modules[1];
                            if (!platform || !application) {
                                reject(new Error(stringFormat_1.default(SPModuleLoader_resx_1.default.platformOrApplicationFailedToLoadError, basePlatformPackageName, manifest_1.loaderConfig.entryModuleId)));
                            }
                            else {
                                platform._spShell.start(application, preloadedData)
                                    .then(function (application) { return resolve(application); }) // tslint:disable-line:no-any
                                    .catch(function (error) {
                                    console.error(stringFormat_1.default(SPModuleLoader_resx_1.default.applicationFailedToInitializeError, error));
                                    reject(error);
                                });
                            }
                            // @todo VSO #210443: preload WebPart manifests
                        }).catch(function (e) {
                            if (!loadingComplete_1) {
                                console.error(stringFormat_1.default(SPModuleLoader_resx_1.default.applicationFailedToLoadError, manifest_1.loaderConfig.entryModuleId, e));
                            }
                            reject(e);
                        });
                    }
                    else {
                        reject(new Error(stringFormat_1.default(SPModuleLoader_resx_1.default.invalidManifestError, applicationManifestId)));
                    }
                }
                else {
                    reject(new Error(SPModuleLoader_resx_1.default.invaliPreloadedDataError));
                }
            });
        });
        result.catch(function (error) {
            // Log and re-throw errors
            console.error(error);
            throw error;
        });
        return result;
    };
    // Public API
    /**
     * Given a URL, load a script.
     *
     * @param scriptSource      - The script URL.
     * @param globalExportsName - If the script isn't an AMD mdoule and loads a global member on the page,
     *                              specify the global member's name.
     * @returns                   A promise containing the loaded module.
     */
    SPModuleLoader.prototype.loadScript = function (scriptSource, globalExportsName) {
        return SystemJsWrapper_1.default.instance.loadScript(scriptSource, globalExportsName);
    };
    /**
     * Loads a module from a manifest.
     *
     * @param manifest - Manifest of the module to load.
     * @returns          A promise containing the loaded module.
     */
    SPModuleLoader.prototype.loadModule = function (manifest) {
        return this._internalLoadModule(manifest);
    };
    /**
     * Resolve a component id and version, and load it.
     *
     * @param id      - The id of the component to load.
     * @param version - The version of the component to load. If version is not defined, the method
     *                    will load the last version of the component.
     * @returns         A promise containing the loaded module.
     */
    SPModuleLoader.prototype.loadModuleById = function (id, version) {
        return this._internalLoadModule([{
                id: id
            }]);
    };
    /**
     * Loads additional manifests into the manifest store, updating existing manifests.
     *
     * @param manifests         - The manifests to load into the store.
     * @param overwriteExisting - If true, overwrite the stored manifest with the provided ones
     */
    SPModuleLoader.prototype.importManifests = function (manifests, overwriteExisting) {
        if (overwriteExisting === void 0) { overwriteExisting = false; }
        ManifestStore_1.default.instance.importManifests(manifests, overwriteExisting);
    };
    /**
     * Get all registered manifests.
     *
     * @returns All registered manifests.
     */
    SPModuleLoader.prototype.getManifests = function () {
        return ManifestStore_1.default.instance.getAllManifests();
    };
    /**
     * Inserts a <link ... /> tag for a stylesheet.
     *
     * @param url - The CSS file URL.
     */
    SPModuleLoader.prototype.loadCss = function (url) {
        var linkTag = document.createElement('link');
        linkTag.rel = 'stylesheet';
        linkTag.type = 'text/css';
        linkTag.href = url;
        SPModuleLoader._headElement.appendChild(linkTag);
    };
    // Internal methods
    /**
     * If manifests from localhost haven't already been loaded, force them to load without prompting the user.
     *
     * @returns A promise that is fulfilled when the manifests are loaded.
     *
     * @internal
     */
    SPModuleLoader.prototype.forceLocalManifests = function () {
        return this._loadDebugManifests(true, true, ['https://localhost:4321/temp/manifests.js',
            'http://localhost:4321/temp/manifests.js']);
    };
    /**
     * Get the component manifest by id.
     *
     * @param id - GUID id of the component.
     *
     * @internal
     */
    SPModuleLoader.prototype.getManifestById = function (id, version) {
        return ManifestStore_1.default.instance.getManifestById(id);
    };
    /**
     * Registers a tab in the developer tools. The developer tools are invoked by pressing "CTRL+SHIFT+~".
     *
     * @param developerToolsTab - The tab definition.
     *
     * @internal
     */
    SPModuleLoader.prototype.registerDeveloperToolsTab = function (developerToolsTab) {
        DeveloperToolsLoader_1.default.instance.registerDeveloperToolsTab(developerToolsTab);
    };
    // Methods to be deprecated
    /**
     * If debug manfiests haven't already been loaded, force them to load without prompting the user.
     *
     * @returns A promise that is fulfilled when the manifests are loaded.
     *
     * @deprecated
     */
    SPModuleLoader.prototype.forceLoadDebugManifests = function () {
        return this.forceLocalManifests();
    };
    /**
     * Load a manifest, or resolve a manifest ID and load it.
     *
     * @param idOrManifest - The ID of a manifest, the manifest payload, or an array of IDs. In the case of an array
     *                        of IDs, all of the IDs are considered equally valid, so pick the first one that's resolvable
     *                        to a manifest.
     * @returns A promse containing the loaded module.
     *
     * @deprecated
     */
    SPModuleLoader.prototype.loadManifestModules = function (idOrManifest) {
        if (typeof idOrManifest === 'string') {
            return this.loadModuleById(idOrManifest);
        }
        else {
            return this.loadModule(idOrManifest);
        }
    };
    /**
     * Load a standard library manifest.
     *
     * @param standardLibraryModule - The standard library module object.
     * @returns A promse containing the loaded module.
     */
    SPModuleLoader.prototype.loadStandardLibraryModule = function (standardLibraryModule, moduleName) {
        var resultPromise; // tslint:disable-line:no-any
        if (NPM_BUILD) {
            // Special case for NPM modules to resolve React, React-DOM, and Flux
            resultPromise = ModuleStore_1.default.instance.npmLoadPackage(moduleName);
        }
        if (!NPM_BUILD || !resultPromise) {
            var references = [standardLibraryModule.bundleReference].concat(standardLibraryModule.aliases || []);
            resultPromise = this._internalLoadModule(references);
        }
        return resultPromise.then(function (module) {
            ModuleStore_1.default.instance.storeModuleById(moduleName, module);
            return module;
        });
    };
    SPModuleLoader.prototype._loadDebugManifests = function (noPrompt, noCache, alternativeManifestsFiles) {
        if (noPrompt === void 0) { noPrompt = false; }
        if (noCache === void 0) { noCache = false; }
        if (noPrompt) {
            _allowDebug = true;
        }
        return DebugManifestProvider_1.default.instance.getDebugManifests(noCache, alternativeManifestsFiles).then(function (debugManifests) {
            ManifestStore_1.default.instance.populateDebugManifests(debugManifests);
            ensureDebugAllowed(debugManifests && Object.keys(debugManifests).length > 0);
        });
    };
    SPModuleLoader.prototype._internalLoadModule = function (referenceOrManifest) {
        var references = referenceOrManifest;
        var manifest;
        var entryName;
        if (references.length) {
            // We have an array of manifests, so find the first one that matches
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var reference = references_1[_i];
                manifest = ManifestStore_1.default.instance.getManifestById(reference.id);
                if (manifest) {
                    entryName = reference.entryName;
                    break;
                }
            }
        }
        else {
            manifest = referenceOrManifest;
        }
        if (manifest) {
            return SystemJsWrapper_1.default.instance.loadManifestModules(manifest.id, manifest.loaderConfig, entryName);
        }
        else {
            throw new Error(stringFormat_1.default(SPModuleLoader_resx_1.default.manifestNotFoundError, JSON.stringify(referenceOrManifest)));
        }
    };
    return SPModuleLoader;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SPModuleLoader;

//# sourceMappingURL=SPModuleLoader.js.map
