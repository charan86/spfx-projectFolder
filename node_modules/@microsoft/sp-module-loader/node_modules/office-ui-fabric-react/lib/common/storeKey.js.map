{"version":3,"sources":["common/storeKey.ts"],"names":[],"mappings":";AAAA,0BAAsB,cAAc,CAAC,CAAA;AAOrC;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACU,gBAAQ,GAAG,UAAI,IAAY,IAAK,OAAA,CAAC,EAAE,MAAA,IAAI,EAAE,EAAE,EAAE,iBAAK,CAAC,IAAI,CAAC,EAAE,CAAiB,EAA3C,CAA2C,CAAC","file":"common/storeKey.js","sourcesContent":["import { getId } from '../Utilities';\n\nexport interface IStoreKey<T> {\n  name: string;\n  id: string;\n}\n\n/**\n * Store keys are a very simple abstraction that maps a string name to an interface type.\n * The enables a type-safe contract for store dependencies when you connect dumb components\n * to stores.\n *\n * @example\n * let selectionKey = storeKey<ISelection>('selection');\n *\n * let stores = new StoreSet()\n *   .add(selectionKey, new Selection());\n *\n * <StoreHost stores={ stores }>\n *   ...\n * </StoreHost>\n *\n * connect(DumbComponent, [ selectionKey ], (props, selection) => ({\n *   isSelected: selection.getSelected(props.item.key)\n * });\n *\n * Note that the \"selection\" reference in the connect callback would be of type ISelection due\n * to the selectionKey reference, and you will get TypeScript errors by referring to selection\n * member that aren't in that interface.\n */\nexport const storeKey = <T>(name: string) => ({ name, id: getId(name) }) as IStoreKey<T>;\n"],"sourceRoot":"/src"}