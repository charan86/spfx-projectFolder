{"version":3,"sources":["components/Layer/LayerHost.tsx"],"names":[],"mappings":"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","file":"components/Layer/LayerHost.js","sourcesContent":["import * as React from 'react';\nimport { Fabric } from '../../Fabric';\nimport { autobind, css, findIndex } from '../../Utilities';\nimport { ProjectedLayer } from './ProjectedLayer';\nimport { ILayerProps } from './Layer.Props';\nimport { ILayerHostProps } from './LayerHost.Props';\n\nexport interface ILayer {\n  id: string;\n  parentElement: HTMLElement;\n  props: ILayerProps;\n  onMounted: (projectedLayer: ProjectedLayer) => void;\n}\n\n/**\n * LayerHost provides a wrapper that acts as a passthrough, rendering the given children within it, but also\n * appending a div at the end, which projects all content wrapped in the Layer components within. Projecting\n * DOM to the end of the document allows for overlaying and stacking scenarios.\n *\n * Normally you do not need to interact directly with LayerHost. If you render Layers within content that isn't\n * wrapped within a LayerHost, a LayerHost will be created and appended to the end of the document body, where\n * layer content will then be projected. However in some circumstances you want Layered content to be rendered\n * in a specific place rather than document body (for example in a popup window or contained within a scrollable\n * region.) In those cases, wrap the content wihtin a LayerHost.\n *\n * @example\n * <LayerHost>\n *   <Layer>I will at the end of LayerHost.</Layer>\n *   <div>I will render normally.</div>\n * </LayerHost>\n **/\nexport class LayerHost extends React.Component<ILayerHostProps, {}> {\n  public static childContextTypes = {\n    layerHost: React.PropTypes.object\n  };\n\n  private _layers: ILayer[];\n  private _layerRefs: {\n    [key: string]: ProjectedLayer\n  };\n\n  constructor(props: {}) {\n    super(props);\n\n    this.state = {\n      layers: []\n    };\n\n    this._layers = [];\n    this._layerRefs = {};\n  }\n\n  public getChildContext() {\n    return {\n      layerHost: this as LayerHost\n    };\n  }\n\n  public render() {\n    return (\n      <div { ...this.props } className={ css('ms-LayerHost', this.props.className) }>\n        <Fabric>\n          { this.props.children }\n          <div className='ms-LayerHost-overlay'>\n            { this._layers.map(layer => (\n              <ProjectedLayer\n                key={ layer.id }\n                layerId={ layer.id }\n                parentElement={ layer.parentElement }\n                defaultRemoteProps={ layer.props }\n                ref={ this._resolveLayer }\n                />\n            )) }\n          </div>\n        </Fabric>\n      </div>\n    );\n  }\n\n  public addLayer(id: string, parentElement: HTMLElement, props: ILayerProps, onMounted: (proxyLayer: ProjectedLayer) => void) {\n    this._layers.push({\n      id,\n      parentElement,\n      props,\n      onMounted\n    });\n    this.forceUpdate();\n  }\n\n  public removeLayer(id: string) {\n    let index = findIndex(this._layers, layer => layer.id === id);\n\n    if (index >= 0) {\n      this._layers.splice(index, 1);\n      delete this._layerRefs[id];\n      this.forceUpdate();\n    }\n  }\n\n  @autobind\n  private _resolveLayer(projectedLayer: ProjectedLayer) {\n    if (projectedLayer) {\n      let layerId = projectedLayer.getId();\n      let index = findIndex(this._layers, layer => layer.id === layerId);\n\n      if (index >= 0 && this._layerRefs[layerId] !== projectedLayer) {\n        this._layerRefs[layerId] = projectedLayer;\n        this._layers[index].onMounted(projectedLayer);\n      }\n    }\n  }\n\n}"],"sourceRoot":"/src"}